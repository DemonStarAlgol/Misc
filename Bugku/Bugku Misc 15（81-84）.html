<html>
<head>
  <title>Bugku Misc 15（81-84）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3735"/>
<h1>Bugku Misc 15（81-84）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">81 闹酒狂欢</span></div><div><br/></div><div>下载得到txt格式文件，内容为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>EF81B5EF81B3EF81A9EF81AEEF81A7EF80A0EF8193EF81B9EF81B3EF81B4EF81A5EF81ADEF80BB0A0AEF81AEEF81A1EF81ADEF81A5EF81B3EF81B0EF81A1EF81A3EF81A5EF80A0EF8183EF81AFEF81AEEF81B3EF81AFEF81ACEF81A5EF8181EF81B0EF81B0EF80B10AEF81BB0AEF80A0EF80A0EF80A0EF80A0EF81A3EF81ACEF81A1EF81B3EF81B3EF80A0EF8190EF81B2EF81AFEF81A7EF81B2EF81A1EF81AD0AEF80A0EF80A0EF80A0EF80A0EF81BB0AEF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF81B3EF81B4EF81A1EF81B4EF81A9EF81A3EF80A0EF81B6EF81AFEF81A9EF81A4EF80A0EF818DEF81A1EF81A9EF81AEEF80A8EF81B3EF81B4EF81B2EF81A9EF81AEEF81A7EF819BEF819DEF80A0EF81A1EF81B2EF81A7EF81B3EF80A90AEF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF81BB0AEF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF8183EF81AFEF81AEEF81B3EF81AFEF81ACEF81A5EF80AEEF8197EF81B2EF81A9EF81B4EF81A5EF818CEF81A9EF81AEEF81A5EF80A8EF80A2EF8182EF81B5EF81A7EF81ABEF81B5EF81BBEF8197EF80B0EF81B2EF81A4EF819FEF80B1EF81B3EF819FEF81B4EF81A8EF81A5EF819FEF81A2EF81A5EF80B5EF81B4EF819FEF8189EF8184EF8185EF81BDEF80A1EF80A2EF80A9EF80BB0A0AEF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF80A0EF81BD0AEF80A0EF80A0EF80A0EF80A0EF81BD0AEF81BD</div></div><div>很明显是十六进制格式的字节码。可以看到其中除0A外，均为EF 81或EF 80开头的三个字节一段，联想到UTF-8字符。用十六进制编辑器将其转为文本文件：</div><div><img src="Bugku Misc 15（81-84）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>所有字符均不可见，因为这些字符确实不在常规的字符集里。注意到题目名称，“闹酒狂欢”对应wingding，联想到Windows自带的Wingdings系列字体，将上述文本复制到Microsoft Word中，设置字体为任意Wingdings字体：</div><div><img src="Bugku Misc 15（81-84）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>Wingdings字体的每个符号都对应键盘上一种按键，例如第一个黑色菱形方块即对应小写的u。从而可以将全部字符翻译为可识读的文字。较简便的做法是直接全部再次复制，全部粘贴到比如说微信的输入框里：</div><div><img src="Bugku Misc 15（81-84）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>using System;</div><div>namespace ConsoleApp1</div><div>{</div><div>    class Program</div><div>    {</div><div>        static void Main(string[] args)</div><div>        {</div><div>            Console.WriteLine(&quot;<font color="#FF0000">Bugku{W0rd_1s_the_be5t_IDE}</font>!&quot;);</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div>flag：Bugku{W0rd_1s_the_be5t_IDE}</div><div><br/></div><div><span style="font-weight: bold;">82 blind_injection</span></div><div><br/></div><div>下载得到pcap格式文件，wireshark打开，导出HTTP对象列表：</div><div><img src="Bugku Misc 15（81-84）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>可以看到大量SQL盲注痕迹。基本思路是，先从1开始依次判断表名的总长度，直到判断正确为止就停止。然后依次对表名的每一位，从 'a' 开始判断其字符是否相等，判断正确后继续下一位字符。从而可以得出结论：</div><div>1、表名的总长度为67；</div><div>2、对表名的每一位，大小为704字节时所判断的字符，就是表名该位的字符。</div><div>接下来需要从盲注payload中导出正确的字符，最简单的方法就是按大小排列所有HTTP对象：</div><div><img src="Bugku Misc 15（81-84）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>注意大小为704字节的对象，其对应的字符就是表名每一位上的字符，不过这里缺少第15位：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>emails,flag_e6<span style="color: rgb(255, 0, 0);">?</span>d3da86fe34a83bbfbdb9d3177a641,referers,uagents,users</div></div><div>可以从HTTP对象列表中判断对15位的最后一次试验为字符2。从而得到完整的flag。</div><div><br/></div><div>另一种方法，先用strings命令提取所有盲注payload：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# strings cap.pcap | grep &quot;substr&quot; &gt; bi.txt</div></div><div>然后用脚本逐行提取每一位对应的字符：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('C:/Users/Administrator/Desktop/bi.txt', 'r').readlines()</div><div><br/></div><div>res = [''] * 67</div><div>for line in f:</div><div>    try:</div><div>        i = line.split('schema=database()),')[1].split(',')[0]</div><div>        i = int(i)</div><div>        s = line.split('\'%20--+')[0].split('\'')[-1]</div><div>        res[i-1] = s</div><div>    except:</div><div>        pass</div><div>print(''.join(res))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>emails,flag_e6<span style="color: rgb(255, 0, 0);">3</span>d3da86fe34a83bbfbdb9d3177a641,referers,uagents,users</div></div><div>这种方法在第15位同样存在一点问题，需要手动修复。</div><div><br/></div><div>flag：flag{e62d3da86fe34a83bbfbdb9d3177a641}</div><div><br/></div><div><span style="font-weight: bold;">83 简单套娃plus</span></div><div><br/></div><div>出了个简单的图片隐写题，卡了大家两天，最后在群里直接公布了答案。很好玩，下次还来。WP如下：</div><div><br/></div><div>比较常见的图片隐写四连，为了符合套娃的主题，全程使用同一张图片，但越来越小。此外把提示写成了童谣的形式。</div><div><br/></div><div>1、“长长的云杉木板”，即Long Spruce Board，提示LSB。但不一样的地方在于，本次的LSB不是从第0行0列开始写的，而是从中间的行开始写的（“从中间把它打开”）。为了降低难度，选择了从200行这个能被8整除的行数开始写，从而可以直接用Stegsolve梭出结果：</div><div><img src="Bugku Misc 15（81-84）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>Save Bin后直接用foremost处理，即可得到一张PNG格式图片，即第二层套娃。</div><div><br/></div><div>2、“腹中空空什么也找不到”，提示图片内容里没有隐写信息。根据“往深处看了又看”，十六进制编辑器查看图片：</div><div><img src="Bugku Misc 15（81-84）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>倒数第二个IDAT块并未达到长度上限，因此最后一个IDAT块很可能有问题。显然这个块也并非图片本身的数据，符合“在外面找到第三层套娃”的提示。实际上这个块里包含了zlib压缩数据，解压就可以得到下一层图片。需要注意的是，zlib压缩数据的来源是一个RAR格式压缩包，在压缩时刻意保留了Rar!文件头，因此这张图在foremost时会提取出RAR压缩包，但很遗憾是无法解压的。比较简单的做法是直接对整张图片使用binwalk，这样会提取出最后一个IDAT块内的zlib数据并将其解压：</div><div><img src="Bugku Misc 15（81-84）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>注意，17363.rar是错误的RAR压缩包，1735C才是从zlib中解压得到的正确压缩包。</div><div><br/></div><div>3、直接解压会发现仅有一张3.bmp，这里有一个比较常见的NTFS流隐写，用对应工具或者直接用7zip打开都可以找到另一张3.bmp。对应“双胞胎”和“藏在影子中”的提示。</div><div>两张bmp（NTFS流中得到的暂且命名为3_2.bmp）大致相似，但也可以明显看到不一样的色块。根据提示“有哪里不一样，其中藏着第四层套娃”，需要从差异中得到结果。如果用逐像素比较的方法是无法得到结果的，因为这里实际上利用了BMP图片格式直接在字节中存储像素的RGB值，但排序并非通常的RGB这一特征，将信息直接写在了字节的差异中。</div><div>将3_2.bmp逐字节减去3.bmp的字节并模256，会发现结果只有0、1、2、3四种，且前面一大段均为0，中间到结尾处才有1、2、3出现。容易联想到四进制数，而四进制数每4位对应一个字节，从而可以从结尾处逐个上溯来判断隐写的开头位置。更简单的方法则是以尾部优先的顺序把所有差值逐4位转成字节，然后用binwalk等工具寻找文件头。脚本如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>path = 'C:/Users/Administrator/Desktop/taowaplus/'</div><div><br/></div><div>b1 = open(path + '3.bmp', 'rb').read()</div><div>b2 = open(path + '3_2.bmp', 'rb').read()</div><div><br/></div><div>l = len(b1)</div><div>m = []</div><div>for i in range(l):</div><div>    n = int(b2[l-i-1]) - int(b1[l-i-1])</div><div>    m += [str(n % 256)]</div><div><br/></div><div>b = b''</div><div>for i in range(0, len(m), 4):</div><div>    s = ''.join(reversed(m[i:i+4]))</div><div>    n = int(s, 4)</div><div>    b = n.to_bytes(1, 'big') + b</div><div><br/></div><div>res = open(path + 'res', 'wb')</div><div>res.write(b)</div></div><div>得到输出文件res后，直接binwalk处理：</div><div><img src="Bugku Misc 15（81-84）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>得到的tar.gz压缩包内就是第四层图片。</div><div><br/></div><div>4、最后一步相对来说比较简单。根据提示“有话想说”“话的个子也很小”可以联想到，隐藏的信息是文本，且被压缩了。实际上十六进制编辑器可以很容易看到痕迹：</div><div><img src="Bugku Misc 15（81-84）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>这一步简单粗暴地把一个7z压缩包的字节塞进了IDAT块的后半部分，并且相应调整了IDAT块的长度位和CRC校验位。binwalk可以看到7z文件头的提示，但可能无法成功提取。不过手动提取也很方便，从37 7A的文件头提取到CRC校验位之前即可。再解压就得到了flag：</div><div><img src="Bugku Misc 15（81-84）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{Matryoshka_Universe_Makes_U_Zoom_In}</div><div><br/></div><div><span style="font-weight: bold;">84 blind_injection2</span></div><div><br/></div><div>下载得到pcap格式文件，wireshark打开，导出HTTP对象：</div><div><img src="Bugku Misc 15（81-84）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>很明显是用时间盲注判断某个对象名的长度位数后，再利用二分法逐位判断具体字符。需要注意的是整个过程中，对每个字符最后一次盲注均为一条带=号的payload用于确认该字符内容，因此只需要关注带有此类特征的payload即可得到完整对象名。同样先用strings命令提取所有payload：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# strings time.pcap | grep &quot;substr&quot; &gt; bi.txt</div></div><div>然后用Python脚本从payload中提取正确的字符组成对象名：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('C:/Users/Administrator/Desktop/bi.txt', 'r').readlines()</div><div><br/></div><div>res = ''</div><div>for line in f:</div><div>    if '%20=%20' in line:</div><div>        n = line.split(',sleep(0.4)')[0].split('%20')[-1]</div><div>        n = int(n)</div><div>        res += chr(n)</div><div>print(res)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>information_schemachallengesflag_8af8e03c6892476f84d1e347187b2449</div></div><div><br/></div><div>flag：flag{8af8e03c6892476f84d1e347187b2449}</div></span>
</div></body></html> 