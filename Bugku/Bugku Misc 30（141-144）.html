<html>
<head>
  <title>Bugku Misc 30（141-144）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="8744"/>
<h1>Bugku Misc 30（141-144）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">141 </span><span style="font-weight: bold;">yst的小游戏</span></div><div><br/></div><div>下载得到BMP格式文件。尝试各种隐写工具，wbStego可以提取出一段十六进制形式字符串：</div><div><img src="Bugku Misc 30（141-144）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>23636F64696E673D7574662D380A0A696D706F7274206F732C746872656164696E670A0A636C617373207573</div><div>……（后略）</div></div><div>转为UTF-8格式文本，是一段Python代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#coding=utf-8</div><div><br/></div><div>import os,threading</div><div><br/></div><div>class user():</div><div>    MAX_HP=400</div><div>    HP=400</div><div>    MP=200</div><div>    Danger=30</div><div>    Defence=20</div><div>class HP():</div><div>    name_1='小瓶生命药水'</div><div>    HP_1=50</div><div>    name_2='大瓶生命药水'</div><div>    HP_2=100</div><div>    name_3='满血药水'</div><div>    HP_3=user.HP</div><div>class MP():</div><div>    name_1='小瓶魔法药水'</div><div>    MP_1=50</div><div>    name_2='大瓶魔法药水'</div><div>    MP_2=100</div><div>    name_3='满魔药水'</div><div>    MP_3=user.MP</div><div>class USE():</div><div>    name_1='普通攻击'</div><div>    MP_1=0</div><div>    Danger_1=user.Danger</div><div>    name_2='磨刀石'</div><div>    MP_2=10</div><div>    Danger_2=user.Danger*2</div><div>    name_3='鸡汤'</div><div>    MP_3=20</div><div>    Danger_3=user.Danger*3</div><div>    name_4='攻击强化'</div><div>    MP_4=50</div><div>print('开始游戏'.center(100,'*'))</div><div>print('yst的属性值\t生命值%s\t魔法值%s\t攻击力%s\t防御值%s\t'%(user.HP,user.MP,user.Danger,user.Defence))</div><div>level=129</div><div>class Boss():</div><div>    HP=300</div><div>    Danger=30</div><div>    Defence=20</div><div>    HP=HP+20*level</div><div>    MP=400</div><div>    Danger=Danger+3*level</div><div>    Defence=Defence+level*4</div><div>user.Danger=user.Danger-Boss.Defence</div><div>Boss.Danger=Boss.Danger-user.Defence</div><div>if user.Danger &lt;=0:</div><div>    user.Danger=1</div><div>if Boss.Danger &lt;=0:</div><div>    Boss.Danger=1</div><div>print('树木的属性值\t生命值%s\t魔法值%s\t攻击力%s\t防御值%s\t'%(Boss.HP,Boss.MP,Boss.Danger,Boss.Defence))</div><div>print('战斗开始'.center(100,'*'))</div><div>ran=0</div><div>while 1:</div><div>    ran=ran+1</div><div>    print('可用技能\t%s 攻击力%s\t%s 攻击力%s\t%s 攻击力%s\t%s 攻击力%s\t'%(USE.name_1,user.Danger,USE.name_2,user.Danger*2,USE.name_3,user.Danger*3,USE.name_4,user.Danger*2))</div><div>    print('可用药水\t%s 回复生命值%s\t%s 回复生命值%s\t%s 回复生命值%s\t\n\t\t%s 回复魔法值%s\t%s 回复魔法值%s\t%s 回复魔法值%s\t'%(HP.name_1,HP.HP_1,HP.name_2,HP.HP_2,HP.name_3,HP.HP_3,MP.name_1,MP.MP_1,MP.name_2,MP.MP_2,MP.name_3,MP.MP_3))</div><div>    use=input('使用:')</div><div>    if USE.name_1 in use:</div><div>        user.MP=user.MP-USE.MP_1</div><div>        if user.MP&lt;USE.MP_1:</div><div>            print('魔力不足,自动使用普通攻击')</div><div>            Boss.HP=Boss.HP-user.Danger</div><div>            print('yst使用了%s 对怪物造成了%s伤害'%(USE.name_1,user.Danger))</div><div>        else:</div><div>            user.MP=user.MP-USE.MP_1</div><div>            print('yst使用了%s 对怪物造成了%s伤害'%(USE.name_1,user.Danger))</div><div>            Boss.HP=Boss.HP-user.Danger</div><div>    elif USE.name_2 in use:</div><div>        if user.MP&lt;USE.MP_2:</div><div>            print('魔力不足,自动使用普通攻击')</div><div>            Boss.HP=Boss.HP-user.Danger</div><div>            print('yst使用了%s 对怪物造成了%s伤害'%(USE.name_1,user.Danger))</div><div>        else:</div><div>            user.MP=user.MP-USE.MP_2</div><div>            print('yst使用了%s 对怪物造成了%s伤害'%(USE.name_2,user.Danger*2))</div><div>            Boss.HP=Boss.HP-user.Danger*2</div><div>    elif USE.name_3 in use:</div><div>        if user.MP&lt;USE.MP_3:</div><div>            print('魔力不足,自动使用普通攻击')</div><div>            Boss.HP=Boss.HP-user.Danger</div><div>            print('yst使用了%s 对怪物造成了%s伤害'%(USE.name_1,user.Danger))</div><div>        else:</div><div>            user.MP=user.MP-USE.MP_3</div><div>            print('yst使用了%s 对怪物造成了%s伤害'%(USE.name_3,user.Danger*3))</div><div>            Boss.HP=Boss.HP-user.Danger*3</div><div>    elif USE.name_4 in use:</div><div>        if user.MP&lt;USE.MP_4:</div><div>            print('魔力不足,自动使用普通攻击')</div><div>            Boss.HP=Boss.HP-user.Danger</div><div>            print('yst使用了%s 对树木造成了%s伤害'%(USE.name_1,user.Danger))</div><div>        else:</div><div>            user.MP=user.MP-USE.MP_4</div><div>            user.Danger=user.Danger*2</div><div>            print('yst使用了%s 对树木造成了%s伤害'%(USE.name_4,user.Danger))</div><div>            Boss.HP=Boss.HP-user.Danger</div><div>    elif HP.name_1 in use:</div><div>        user.HP=user.HP+HP.HP_1</div><div>        print('yst使用了%s 恢复了%s生命值'%(HP.name_1,HP.HP_1))</div><div>    elif HP.name_2 in use:</div><div>        user.HP=user.HP+HP.HP_2</div><div>        print('yst使用了%s 恢复了%s生命值'%(HP.name_2,HP.HP_2))</div><div>    elif HP.name_3 in use:</div><div>        user.HP=user.HP+HP.HP_3</div><div>        print('yst使用了%s 恢复了%s生命值'%(HP.name_3,HP.HP_3))</div><div>    elif MP.name_1 in use:</div><div>        user.MP=user.MP+MP.MP_1</div><div>        print('yst使用了%s 恢复了%s魔力值'%(MP.name_1,MP.MP_1))</div><div>    elif MP.name_2 in use:</div><div>        user.MP=user.MP+MP.MP_2</div><div>        print('yst使用了%s 恢复了%s魔力值'%(MP.name_2,MP.MP_2))</div><div>    elif MP.name_3 in use:</div><div>        user.MP=user.MP+MP.MP_3</div><div>        print('yst使用了%s 恢复了%s魔力值'%(MP.name_3,MP.MP_3))</div><div>    else:</div><div>        print('没有该道具 自动使用普通攻击')</div><div>        print('yst使用了%s 对树木造成了%s伤害'%(USE.name_1,user.Danger))</div><div>        Boss.HP=Boss.HP-user.Danger</div><div>    user.HP=user.HP-Boss.Danger</div><div>    print('树木对你造成了%s伤害'%(Boss.Danger))</div><div>    print('yst\t剩余生命值%s\t攻击力%s\t\t防御力%s\t魔法值%s'%(user.HP,user.Danger,user.Defence,user.MP))</div><div>    print('树木\t剩余生命值%s\t攻击力%s\t防御力%s\t\n'%(Boss.HP,Boss.Danger,Boss.Defence))</div><div>    print('第%s回合,结束!!!'%ran)</div><div>    if Boss.HP&lt;=0 and user.HP&lt;=0:</div><div>        print('平局!!!')</div><div>        break</div><div>    if Boss.HP &lt;=0:</div><div>        print('树木被砍翻了，你赢了!!!\t')</div><div>        break</div><div>    if user.HP &lt;=0:</div><div>        print('你寄了!!!\t')</div><div>        break</div></div><div>根据题目要求，需要计算最快胜利回合数。</div><div><br/></div><div>首先是双方的固定属性：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>user HP  400 MP 200 攻击  30 防御  20</div><div>BOSS HP 2880 MP -   攻击 417 防御 536</div></div><div>伤害公式为攻击减防御，且最低伤害为1。因此BOSS每次对玩家固定造成397点伤害，相当于每次补充HP以外的有效行动需要消耗397点HP。另一方面，药水没有数量限制，因此默认仅使用满血药水和满魔药水即可，且HP和MP均可补充到超出最大值。从而有如下的策略雏形：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>不断使用满血药水直到HP足够X次有效行动消耗</div><div>进行X次有效行动削减BOSS HP至0取得胜利</div></div><div>那么关键是确定有效行动的最少次数，也即暂时不考虑自身HP的情况下，最快速削减BOSS HP的方法。</div><div><br/></div><div>代码中给出了四种可用技能。和HP同理，我们可以先把MP补充到足够后续步骤消耗的数值，再进行攻击。即：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>不断使用满血药水直到HP足够M+N次有效行动消耗</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">使用M次满魔药水直到MP足够N次攻击行动消耗</span></div><div>进行N次攻击行动削减BOSS HP至0取得胜利</div></div><div>和HP的情况不同，攻击行动需要考虑补充MP使用的回合数，即需要考虑收益/回合比最大的行动策略。而四种攻击行动的收益和消耗分别是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>普通攻击 MP  0 攻击力1倍伤害</div><div>磨刀石   MP 10 攻击力2倍伤害</div><div>鸡汤    MP 20 攻击力3倍伤害</div><div>攻击强化 MP 50 当前攻击力2倍伤害 回合结束后攻击力加倍</div></div><div>由于攻击力加倍效果的存在，一个最优的攻击序列必定满足这样的条件：任何使用攻击加倍的回合，必定早于任何使用其他技能的回合。证明也很显然：对于任意在其他技能后使用攻击加倍的攻击序列，只要将两者的回合交换一下，总伤害必然是增加的。从而最优攻击序列必然是如下的形式：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>先使用P次攻击强化</div><div>再使用Q次其他三种技能，Q可以为0</div></div><div>由于已知BOSS HP为2880，容易算出P的上界：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>TD      P     D</div><div>2       1     2</div><div>6       2     4</div><div>14      3     8</div><div>30      4     16</div><div>62      5     32</div><div>126     6     64</div><div>254     7     128</div><div>510     8     256</div><div>1022    9     512</div><div>2046    10    1024</div><div>4094    11    2048</div></div><div>即11次攻击强化造成的伤害已经超出了BOSS的HP，因此P最多为11。这种情况下需要消耗MP总数为550，计入初始MP值200，还需要2回合使用满魔药水，即 P=11, Q=0, N=P+Q=11, M=2 。我们的目的是令X=M+N达到最小值（从而使用满血药水的回合数也达到最小值），因此可以对所有可能的P值进行规划，把各个数值都计算出来。<span style="font-size: unset; color: unset; font-family: unset;">其中补充HP回合的计算思路是：一个补充HP回合对HP的净增为3（400点药水补充-397点BOSS伤害），一个有效行动回合需要的HP为397，初始HP为400，同时由于HP在任一回合都不能为0（否则会提前失败或在最终回合平局），因此补充HP的回合数应为 (X * 397 - 400) // 3 + 1。</span></div><div><br/></div><div>脚本如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from math import ceil</div><div><br/></div><div>def gao(P):</div><div>    HP, D, TD, Q1, Q2, Q3 = 2880, 1, 0, 0, 0, 0</div><div>    for i in range(P):  # 先使用P次攻击加倍</div><div>        TD += D * 2</div><div>        D *= 2</div><div>    while TD &lt; HP:  # 然后使用其他技能</div><div>        if HP - TD &gt; 2 * D:</div><div>            Q3 += 1  # 使用三号攻击技能</div><div>            TD += 3 * D</div><div>        elif HP - TD &gt; D:</div><div>            Q2 += 1  # 使用二号攻击技能</div><div>            TD += 2 * D</div><div>        else:</div><div>            Q1 += 1  # 使用一号攻击技能</div><div>            TD += D</div><div>    MP = P * 50 + Q2 * 10 + Q3 * 20  # 合计需要的MP</div><div>    M = ceil(MP / 200 - 1)  # 需要使用满魔药水次数，注意MP可以为0，所以直接取整即可</div><div>    N = P + Q1 + Q2 + Q3  # 合计需要的攻击回合数</div><div>    X = M + P + Q1 + Q2 + Q3  # 合计需要的有效行动回合数（攻击回合+补充MP回合）</div><div>    Y = (X * 397 - 400) // 3 + 1  # 合计需要的补充HP回合数</div><div>    A = X + Y  # 整个流程的总回合数</div><div>    print(f'P={P} Q1={Q1} Q2={Q2} Q3={Q3} N={N} M={M} X={X} Y={Y} A={A}')</div><div><br/></div><div>for i in range(1, 12):</div><div>    gao(i)</div></div><div>运行结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>P=1 Q1=0 Q2=1 Q3=479 N=481 M=48 X=529 Y=69872 A=70401</div><div>P=2 Q1=0 Q2=1 Q3=239 N=242 M=24 X=266 Y=35068 A=35334</div><div>P=3 Q1=0 Q2=1 Q3=119 N=123 M=12 X=135 Y=17732 A=17867</div><div>P=4 Q1=0 Q2=1 Q3=59 N=64 M=6 X=70 Y=9131 A=9201</div><div>P=5 Q1=0 Q2=1 Q3=29 N=35 M=4 X=39 Y=5028 A=5067</div><div>P=6 Q1=0 Q2=1 Q3=14 N=21 M=2 X=23 Y=2911 A=2934</div><div>P=7 Q1=0 Q2=0 Q3=7 N=14 M=2 X=16 Y=1985 A=2001</div><div>P=8 Q1=1 Q2=0 Q3=3 N=12 M=2 X=14 Y=1720 A=1734</div><div>P=9 Q1=1 Q2=0 Q3=1 N=11 M=2 X=13 Y=1588 A=1601</div><div>P=10 Q1=1 Q2=0 Q3=0 N=11 M=2 X=13 Y=1588 A=1601</div><div>P=11 Q1=0 Q2=0 Q3=0 N=11 M=2 X=13 Y=1588 A=1601</div></div><div>从而有三个方案可以达成最小回合数，具体为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco">1-1588回合，使用满血药水，HP为5164</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco">1589-1590回合，使用满魔药水，MP为600，HP为4370</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco">1591-1601回合，攻击11次，HP为3，获得胜利</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco"><br/></font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco">可选攻击流程有三种：</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco">（1）使用9次攻击加倍，MP剩余150，攻击力512，总伤害1022</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco">使用1次鸡汤，MP剩余130，总伤害1022+512*3=2558</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Monaco">使用1次普通攻击，MP剩余130，总伤害2558+512=3070&gt;2880</font></span></div><div><font face="Monaco"><span style="font-size: 9pt; color: rgb(51, 51, 51);">（2）</span>使用10次攻击加倍，MP剩余100，攻击力1024，总伤害2046</font></div><div><font face="Monaco">使用1次普通攻击，MP剩余100，总伤害2046+1024=3070&gt;2880</font></div><div><font face="Monaco">（3）使用11次攻击加倍，MP剩余50，攻击力2048，总伤害4094&gt;2880</font></div></div><div>最后flag为1601的32位md5。<span style="font-size: unset; color: unset; font-family: unset;">顺带一提，中间的分析步骤可以省略掉一部分，把最后脚本里的循环改成range(1, 100)暴力计算更多情况然后手动从中选择最低回合数也是可行的。</span></div><div><br/></div><div>flag：flag{c559da2ba967eb820766939a658022c8}</div><div><br/></div><div><span style="font-weight: bold;">142 神秘的宴会</span></div><div><br/></div><div>好，是我最喜欢的 想不出怎么出题了所以让我们来往题目里塞围棋/脑筋急转弯/脑电波频率对对碰/二次元小常识/我玩过所以全世界都应该玩过的游戏/传统灯谜/你画我猜 的musc题。只要不断出题，套娃就会不断延伸，所以不要停下来啊！</div><div><img src="Bugku Misc 30（141-144）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>上图为musc创始神谈musc题（左起第一为musc创始神）.png。</div><div><br/></div><div>下载到的附件里是一个加密的zip格式压缩包，以及一张图片和一道题：</div><div><img src="Bugku Misc 30（141-144）_files/123.png" type="image/png" data-filename="123.png"/></div><div>在misc题里你甚至可以做另外一道题，里面甚至还有错别字：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>在一个神秘的地方，两位主持人正主持这宴会，随着时间的推移，宴会也迎来了高潮</div><div>一男一女两位主持人对大家说消失的文本名就在某个人的身上且文本名是（他的桌号加他的位置号的md5值）</div><div>#例E5的md5为    f9f2d672039ed5d04839b769ad71e1b0 所以消失的文本名为  f9f2d672039ed5d04839b769ad71e1b0.txt</div><div><br/></div><div>宴会共有13个人 你能找到ta吗</div><div><br/></div><div>以知桌号只有男主持知道，位置号只有女主持人知道</div><div>两个主持人的对话如下：</div><div>    女主持人说：我不知道是谁</div><div>    男主持人说：我知道你不知道是谁</div><div>    女主持人说：现在我知道是谁了</div><div>    男主持人说：我也知道是谁了</div></div><div>常见的逻辑题，按顺序排除即可：</div><div>1、女主持人不知道是谁，说明位置号至少出现在两桌，即2、5、6、8；</div><div>2、男主持人知道女主持人不知道是谁，说明该桌上有且仅有上述四种位置号，即B桌或C桌；</div><div>3、女主持人说现在知道了，说明位置号不是2，否则无法判断是B或C桌；</div><div>4、男主持人说也知道了，说明桌子上除了2仅有一个其他位置号，因此答案是C6。</div><div>按照题目说明，消失的文本名为7e8b9f5cab4a8fe24fad9fe4b7452702.txt。</div><div><br/></div><div>接下来就是大家都很喜欢的猜谜时间。看一下加密压缩包flag.zip：</div><div><img src="Bugku Misc 30（141-144）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>没有其他提示，只能猜测出题人的意思也许大概有可能说不定是在暗示Themissingtextnameishere.zip中包含了名为7e8b9f5cab4a8fe24fad9fe4b7452702.txt的这个文件。假定这个猜测是真的并且其他一切条件都刚好满足，包括但不限于这个Themissingtextnameishere.zip是标准zip格式而且里面只有txt这一个文件，那么zip文件的部分字节和偏移量是可以确定的，可以尝试部分明文爆破。</div><div><br/></div><div>首先来确定部分字节和偏移量：</div><div>1、zipfile record的<span style="font-size: unset; color: unset; font-family: unset;">文件头50 4B 03 04；</span></div><div>2、zipfile record末尾的被压缩文件名，从zip文件第31字节开始，7e8b9f5cab4a8fe24fad9fe4b7452702.txt；</div><div>3、zipfile endlocator的文件头，文件最后22字节的前8字节，50 4B 05 06 00 00 00 00。</div><div>创建plain.txt并写入内容为7e8b9f5cab4a8fe24fad9fe4b7452702.txt，然后用bkcrack：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>bkcrack -C flag.zip -c Themissingtextnameishere.zip -p plain.txt -o 30 -x 0 504b0304 -x 283 504b050600000000</div></div><div>然后坐下来祈祷猜对了出题人的脑电波，毕竟如果电脑比较烂，bkcrack爆破一次密钥也得不少时间：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>bkcrack 1.3.1 - 2021-08-16</div><div>[00:00:01] Z reduction using 28 bytes of known plaintext</div><div>100.0 % (28 / 28)</div><div>[00:00:01] Attack on 263216 Z values at index 37</div><div>Keys: e7ee1595 9752b53e 4c35945e</div><div>11.2 % (29563 / 263216)</div><div>[23:59:59] Keys</div><div>e7ee1595 9752b53e 4c35945e</div></div><div>爆破了一整天得到密钥后同样用bkcrack解密原来的flag.zip：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>bkcrack -C flag.zip -c Themissingtextnameishere.zip  -k e7ee1595 9752b53e 4c35945e -d 1.zip</div><div>bkcrack -C flag.zip -c 1.jpg -k e7ee1595 9752b53e 4c35945e -d 2.jpg</div></div><div>得到的zip压缩包里的7e8b9f5cab4a8fe24fad9fe4b7452702.txt里只有一句话：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>你想要的flag可不在这里呦，再去找找吧，相信你可以的，离成功越来越近了</div></div><div><br/></div><div>那就看看2.jpg，但这时候会发现它打不开，这是因为原压缩包里的1.jpg是用deflate算法压缩的，简单解压即可：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import zlib</div><div><br/></div><div>data = open('2.jpg', 'rb').read()</div><div>data = zlib.decompress(data, -zlib.MAX_WBITS)</div><div>with open('1.jpg', 'wb') as f:</div><div>    f.write(data)</div></div><div>得到正常的jpg图像：</div><div><img src="Bugku Misc 30（141-144）_files/1.jpg" type="image/jpeg" data-filename="1.jpg"/></div><div>和一开始得到的123.png内容差不多，说明可能是双图隐写。尝试后发现是盲水印：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/blind-watermark-python3/BlindWaterMark# python3 bwmforpy3.py decode 123.png 1.jpg res.png</div><div>image&lt;123.png&gt; + image(encoded)&lt;1.jpg&gt; -&gt; watermark&lt;res.png&gt;</div></div><div><img src="Bugku Misc 30（141-144）_files/res.png" type="image/png" data-filename="res.png"/></div><div><br/></div><div>flag：flag{Y0u_@r3_sO_cL3v3r}</div><div><br/></div><div><span style="font-weight: bold;">143 OSINT</span></div><div>题目：图片拍摄于2021年6月23日，请找出图片中小镇的名称及图片的拍摄时间 提示：flag形式flag{yuntaizhen,2121}</div><div><br/></div><div>附件图片：</div><div><img src="Bugku Misc 30（141-144）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>看了下这题目还是中途换过的，换之前是搬的题，就离谱。</div><div><br/></div><div>首先从飞机机翼上可以看到一个编号B-1902，结合题目给出的日期2021年6月23日，用飞常准提供的Flightadsb服务可以查询到<a href="https://flightadsb.variflight.com/track-data/B-1902/1624377600000">当日该架飞机的航班信息</a>：</div><div><img src="Bugku Misc 30（141-144）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>共有两趟航班四次飞行，西安咸阳经停通辽至海拉尔东山，以及原路返回。由于图片里没有更多信息能够判断时间，暂时先把全部四次飞行纳入考虑。</div><div><br/></div><div>接下来从图片中提取可以找到的地理特征：</div><div>1、飞机右侧主要为山地地形，当前正经过一处山谷，山谷底部有一条河；</div><div>2、河流经过一处城镇（即题目要求找到名字的小镇），且从城镇中间经过，将其切分为两部分；</div><div>3、由于科里奥利力的作用，北半球的河流一般冲刷右岸比左岸更猛烈，从而右岸的弯曲通常大于左岸，因此可以判断图中的河流右岸位于图片的左方，换言之，该河流是从图片上方流向下方的；</div><div>4、图中靠下方有两处较大面积的水域（见下图），从地形来说可以排除海面，因此可能为湖泊，结合附近的山地地形以及水域的边缘形状，大概率是水库。</div><div><img src="Bugku Misc 30（141-144）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>然后点击航班飞行信息后的“回放”按钮，查看当日飞行轨迹，首先是第一次飞行从西安咸阳到通辽：</div><div><img src="Bugku Misc 30（141-144）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>然而到通辽机场前的最后一段数据缺失了……不过还是可以勉强看一下。根据航线右侧有大片山地、右侧有流向朝向飞机的河流两个条件，可以排除离开咸阳机场后约北偏东60度方向飞行至渤海的一段（因为该段右侧基本为平原地形，且没有流向为朝向西北的河流），以及从渤海绕过辽东半岛飞行的一段（因为该段右侧都是海面）。</div><div><br/></div><div>放大地图查看刚离开咸阳机场飞行的一段以及进入辽东半岛后的一段，根据前文分析的第4个特征，重点关注航线附近的水库和其他大面积水域。沿航线查找，可以找到这里：</div><div><img src="Bugku Misc 30（141-144）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>可以看到截图上方的城镇形状和题目给出的照片中非常相似，尤其是被河流分割出一块，以及对侧延伸出Y形区域这两个特征，而且不知道为什么这形状看着还有点像美国。对比一下：</div><div><img src="Bugku Misc 30（141-144）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><img src="Bugku Misc 30（141-144）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>与飞机的相对方位、河流的形状以及地形等特征也能够对应，因此这应该就是题目要求寻找的小镇。</div><div><br/></div><div>用任意地图工具查询上图中的飞机坐标，然后根据相对方位找到小镇所在位置：</div><div><img src="Bugku Misc 30（141-144）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>如图，左下定位点为上图中飞机实时位置，根据水库、河流和飞机的相对方位，可以确定要找的小镇为南杂木镇。</div><div><br/></div><div>最后确定拍摄时间，由于飞机和小镇的连线经过水库，因此拍摄时两者的相对位置大约在这附近：</div><div><img src="Bugku Misc 30（141-144）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>因此拍摄时间大约是09:08前后。</div><div><br/></div><div>flag：flag{nanzamuzhen,0908}</div><div><br/></div><div><span style="font-weight: bold;">144 粉色的猫</span></div><div><br/></div><div>下载得到加密的zip格式压缩包：</div><div><img src="Bugku Misc 30（141-144）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>有一段注释：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>TCAACTTAGCTGTGATGATGTTCAGATTAGCTA</div></div><div><br/></div><div>ACGT是DNA的四种碱基，那么容易想到的有两种可能性：1、基于四进制的某种编码的字符替换；2、三个DNA碱基对应一种氨基酸。但两种思路都无法得到正确的压缩包密码，例如<a href="http://db.systemsbiology.net:8080/proteomicsToolkit/DNAServlet?code=Standard&amp;sequence=TCAACTTAGCTGTGATGATGTTCAGATTAGCTA&amp;stopFormat=*&amp;outputSeq=yes">后一种思路</a>，在5'3' Frame2、5'3' Frame3和3'5' Frame3三种顺序下能够得到不含终止密码子的氨基酸序列，但这些结果均不是压缩包的密码。</div><div>那么，基于对同一出题人其他题目的了解，我们需要考虑这样一种可能性：出题人只是随便找了一个把字符串转为DNA碱基序列的在线“加密”工具，而该工具使用的替换/编码/加密逻辑也是开发者自行定义的，并没有什么道理可言。尝试使用“DNA encode”“DNA cipher”“DNA translate”等关键词查询，排除掉大量真正的生物学页面和论文之后，运气好的话可以找到这个<a href="https://earthsciweb.org/js/bio/dna-writer/index.html">Simple DNA Writer</a>：</div><div><img src="Bugku Misc 30（141-144）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div>这个页面还给出了一段关于该工具的<a href="https://montessorimuddle.org/2013/02/02/dna-writer/">blog文章</a>，注意到Update 5中作者提到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>In constructing the codon-to-english conversion table I had to decide if I wanted to go with the standard coding (e.g. letting GTC which codes for alanine represent A) or make up a random encoding. I opted for the random approach for a number of reasons, ...</div></div><div>机翻一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>在构建密码子到英语的转换表时，我必须决定是要使用标准编码（例如，让 GTC 的丙氨酸编码代表 A）还是组成一个随机编码。出于多种原因，我选择了随机方法……</div></div><div>换言之，该工具的替换表完全是随机生成的（所以作者才在更新中又做了一个较为尊重标准密码子的替换表，但本题使用的还是随机替换表版本），因此密文本身没有任何道理可言，唯一解决它的方法是找到这个工具。相信大家到这里可能也和我一样不知道应该说什么，那么只需要微笑就好了。</div><div><br/></div><div>用密码 CATISSOCUTE 解压压缩包，得到key.txt和无后缀名的文件1。先看前者：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>0001000D91683106019196F4000872003800390035003000340045003400370030004400300041003100410030004100300030003000300030003000300044003400390034003800340034003500320030003000300030003000300034003700300030003000300030003000300038003000380030003200300030003000300030</div><div>0001000D91683106019196F4000872003000320034004400430037003500460031003000300030003000300030004200430034003900340034003400310035003400370038003500450044004400390032003400310031003200380035003300300030003800340033004200390031003900460037003300460031003500390046</div><div>0001000D91683106019196F400087000380034004600410038003700310032003100370036004500370034003500310032003600450033004400340041003600320044003700390035003500420033003800380032003100310037003900390042004200320045004100420039003500410036004200330042004200450037</div><div>0001000D91683106019196F400086E0042003600300039003900330045004500360033004600320036004600440044003100420043004400410042003300300033003300310046004500350045003600440039003300370035004200300036003500360036004100320031003000410033004100420037003100440038</div><div>0001000D91683106019196F400087000450033004400370032003100300031004400420034003900310036003900360038003000310033003200340046003800450046003200380034004500420033003500430030004600420036003400450046003100300030004100310042004100300043003200300044004400450042</div><div>0001000D91683106019196F400086E0038003400410032004200440038004200350038004200330039004500410043003600450030004100420031003000380044003600440036004600340034004300460044003800310044003000330042003600390034004200430039003400430032003300310033004400340046</div><div>0001000D91683106019196F400087000360038003900390031003600440036003200360041003700390035003800460035004300440039003500390042004500320038004300340034003300410045003700360043003100300035003800380030003200380035003900320039003600310042004600430044003400300044</div><div>0001000D91683106019196F4000872003100350037004600310033003400310033003800390043004600410042003600410045003500460032003300300038003700370035004500380031004500420032003000330030004300300035003000340037003500310044003900460041003400450045004600320032004600440030</div><div>0001000D91683106019196F400085200300037004400450044003500420036003800410033003100350046004400310031003000300030003000300030003000300034003900340035003400450034003400410045003400320036003000380032</div></div><div>每行开头都是0001000D9168，可以看出这是<a href="https://www.cnblogs.com/polar-lights/p/8457814.html">PDU模式的手机短信编码</a>，有<a href="http://www.sendsms.cn/pdu/">在线解码工具</a>。由于行数不多，这里直接在网页上解密即可（调用js批量解密的方法参见 <a href="evernote:///view/30668439/s39/884ea996-15b8-4567-9749-9f47442ef1f5/884ea996-15b8-4567-9749-9f47442ef1f5/" style="color: rgb(105, 170, 53);">2021CISCN线上赛 隔空传话</a>一题）。得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>89504E470D0A1A0A0000000D494844520000004700000008080200000</div><div>024DC75F1000000BC49444154785EDD92411285300843B919F73F159F</div><div>84FA8712176E745126E3D4A62D7955B388211799BB2EAB95A6B3BBE7</div><div>B60993EE63F26FDD1BCDAB30331FE5E6D9375B06566A210A3AB71D8</div><div>E3D72101DB491696801324F8EF284EB35C0FB64EF100A1BA0C20DDEB</div><div>84A2BD8B58B39EAC6E0AB108D6D6F44CFD81D03B694BC94C2313D4F</div><div>689916D626A7958F5CD959BE28C443AE76C10588028592961BFCD40D</div><div>157F1341389CFAB6AE5F2308775E81EB2030C0504751D9FA4EEF22FD0</div><div>07DED5B68A315FD110000000049454E44AE426082</div></div><div><br/></div><div><span style="font-size: unset; color: unset; font-family: unset;">很显然是某个PNG图像文件的十六进制形式编码，将其还原得到图片（已放大）：</span></div><div><img src="Bugku Misc 30（141-144）_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>看起来有点像<a href="https://esolangs.org/wiki/Piet">Piet</a>，但过多的黑色块在Piet代码中并不常见。另一方面，Piet用到的所有颜色，RGB颜色分量均由FF、C0和00组成：</div><div><img src="Bugku Misc 30（141-144）_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>而如果统计该图像中的像素颜色，会发现RGB颜色分量均由FF、3F和00组成。换言之，其组成颜色全都是Piet颜色表的反色。那么就很清楚了，需要先把得到的图像反色，再在piet解释器里运行：</div><div><img src="Bugku Misc 30（141-144）_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\信息隐藏\npiet-1.3a-win32&gt;npiet.exe 2.png</div><div>a=13b=14</div></div><div><br/></div><div>最后看无后缀名的文件1，十六进制编辑器看一下文件头：</div><div><img src="Bugku Misc 30（141-144）_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>是<a href="https://bellard.org/bpg/">BPG格式</a>图像，转成PNG来看看：</div><div><img src="Bugku Misc 30（141-144）_files/out.png" type="image/png" data-filename="out.png"/></div><div>看起来是某种有规律的条纹，结合另一边得到的两个参数，猜测可能是<a href="https://en.wikipedia.org/wiki/Arnold%27s_cat_map">Arnold's cat map</a>，一种循环变换后会回归自身的混沌映射。根据变换算法，写个脚本将图像还原：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>from numpy import array, meshgrid</div><div><br/></div><div>def cat(img, times, path):</div><div>    # load image</div><div>    im = array(img)</div><div>    N = im.shape[0]</div><div><br/></div><div>    # create x and y components of Arnold's cat mapping</div><div>    x, y = meshgrid(range(N), range(N))</div><div>    xmap = (14 * x + y) % N</div><div>    ymap = ((13 * 14 + 1) * x + 13 * y) % N</div><div><br/></div><div>    for i in range(times):</div><div>        im = im[xmap, ymap]</div><div>        result = Image.fromarray(im)</div><div>        result.save(f'{path}{i}.png')</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/cat/out.png')</div><div>N = img.size[0]</div><div>cat(img, N, 'C:/Users/Administrator/Desktop/cat/')</div></div><div>然后发现用不着循环那么多次，第一次变换就得到了结果：</div><div><img src="Bugku Misc 30（141-144）_files/0.png" type="image/png" data-filename="0.png"/></div><div><br/></div><div>flag：flag{c159549a-5604-4bb7-8a6e-9db9d8b1426a}</div></span>
</div></body></html> 