<html>
<head>
  <title>Bugku Misc 7（49-52）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2320"/>
<h1>Bugku Misc 7（49-52）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">49 cisco</span></div><div>题目描述：密码是flag</div><div><br/></div><div>下载得到1.txt和2.txt。其中前者疑似乱码，很可能是某个特定格式文件的扩展名被改成了txt。后者内容为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>U2FsdGVkX19T7VS86emCFReuh2Tjc3ZtbB5HMHebPd8=</div></div><div>base64解码后以Salted__开头，可能是AES、DES或Rabbit等现代密码的base64形式密文。这些现代密码解密都需要密钥，但尝试cisco、flag等均无结果。最后发现用<a href="https://github.com/guyoung/CaptfEncoder">CaptfEncoder</a>的AES模块可以在未输入密钥的情况下解得明文（可能是因为工具中内置了某个默认密钥，待考）：</div><div><img src="Bugku Misc 7（49-52）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>明文为“文件后缀”，同样暗示1.txt是其他格式文件修改了扩展名的结果。搜索“思科 文件格式”，找到大量与思科设备有关的文件格式，排除部分非思科设备专用格式，并下载相应格式文件进行对比后，猜测1.txt很可能是<a href="https://www.netacad.com/courses/packet-tracer">Cisco Packet Tracer</a>对应的pka/pkt格式文件。</div><div><br/></div><div>安装Cisco Packet Tracer（旧版本可能无法打开文件，需要最新版7.3.1）后，将1.txt重命名为pka或pkt，打开：</div><div><img src="Bugku Misc 7（49-52）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>如图，有一台路由器，一台交换机和四台客户端。联系题目给出的“密码是flag”，在设备中尝试需要密码的操作，用该密码成功进入交换机CLI的特权模式。操作步骤如下：</div><div>1、点击画面中的交换机，切换到CIL标签页；</div><div>2、按回车键进入命令输入模式，输入特权模式命令en或enable；</div><div>3、提示输入密码，输入flag后回车，进入特权模式。</div><div><img src="Bugku Misc 7（49-52）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>输入?可以查看当前模式下的可用命令：</div><div><img src="Bugku Misc 7（49-52）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>考虑到flag应为固定字符串，尝试查看配置文件，如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Switch#show startup-config</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Switch#show running-config</span></div></div><div>最后发现flag在当前运行配置running-config中：</div><div><img src="Bugku Misc 7（49-52）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：<span style="text-indent: 0px;">flag{wenzi_houzhui_sike}</span></div><div><br/></div><div><span style="font-weight: bold;">50 插画</span></div><div><br/></div><div>下载得到zip格式文件，有注释：</div><div><img src="Bugku Misc 7（49-52）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>RnJlZV9GaWxlX0NhbW91ZmxhZ2UsIOmimOebruWlveWDj+aYr+aMuumHjeimgeeahOagt+WtkC4u</div></div><div>base64解码得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Free_File_Camouflage, 题目好像是挺重要的样子..</div></div><div>Free_File_Camouflage是一种隐写工具，且题目已经给出密码提示：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>密码：我都没听说过</div></div><div><br/></div><div>解压得到pl.jpg，用Free_File_Camouflage提取隐写信息：</div><div><img src="Bugku Misc 7（49-52）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>得到pl.txt：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>length q caller lc and print chr ord uc q ge log and print chr ord q eval ge and print chr ord q ge log and print chr ord q qr eq and print chr ord q my alarm and print chr ord qq q q and print chr ord q msgctl m and print chr ord q sin s and print chr ord qw q ne q and print chr ord qw q gt q and print chr ord q else and print chr ord q ge log and print chr ord q q q and print chr ord q lt eval and print chr ord q tie lt and print chr ord qw q m q and print chr ord q ge log and print chr ord qq q q and print chr ord q my m and print chr ord q xor x and print chr ord qw q use q and print chr ord qq q q and print chr ord q map m and print chr ord q oct do and print chr ord q oct no and print chr ord q ref or and print chr ord qw q sin q and print chr ord qw q sin q and print chr ord q q q and print chr ord q each le and print chr ord qq q q and print chr ord q qw q and print chr ord q ref or and print chr ord qw q bless q and print chr ord q msgctl m and print chr ord q tie gt and print chr ord q lt eval and print chr ord q ge log and print chr oct oct ord uc qw q bind q and print chr ord q q q and print chr ord q my m and print chr ord q local and print chr ord qw q use q and print chr ord q q q and print chr ord q else and print chr ord q ref or and print chr ord q map m and print chr ord q eval ge and print chr ord q ge log and print chr ord q q q and print chr ord q lt eval and print chr ord q qr q and print chr ord q each ne and print chr ord q oct no and print chr ord qw q keys q and print chr ord qw q sin q and print chr oct oct ord uc qw q fcntl q and print chr ord q q eq and print chr ord uc q lt eval and print chr ord q qr q and print chr ord q each le and print chr ord q lc eval and print chr ord qw q keys q and print chr ord qw q s q and print chr ord q q q and print chr ord q stat s and print chr ord q chr uc and print chr ord q each ne and print chr ord q lt eval and print chr ord qq q q and print chr ord q local and print chr ord q gt log and print chr ord q chop uc and print chr ord q ge log and print chr ord q qr eq and print chr ord qw q s q and print chr ord q q q and print chr ord q lc eval and print chr ord q map m and print chr ord qw q ne q and print chr ord qq q q and print chr ord q map m and print chr ord q lc eval and print chr ord q oct no and print chr ord q ref or and print chr ord qw q s q and print chr ord q msgctl m and print chr oct oct ord uc qw q for q and print chr ord q q q and print chr ord uc q sin s and print chr ord qw q fcntl q and print chr ord q q q and print chr ord q my alarm and print chr ord q local and print chr ord q dump and and print chr ord q q eq and print chr ord qw q do q and print chr ord q pop and print chr ord qw q ne q and print chr oct oct oct ord uc qw q gt q and print chr ord q lt eval and print chr ord q q eq and print chr ord q else and print chr ord q tie lt and print chr ord qw  or and print chr ord q map m and print chr oct oct ord uc qw q bless q and print chr ord q q eq and print chr ord qw q fcntl q and print chr ord q sin s and print chr ord qw q no q and print chr ord qw q die q and print chr ord q q eq and print chr ord q local and print chr ord qw q uc q and print chr ord q gt log and print chr ord q q q and print chr ord q qw q and print chr ord q chr uc and print chr ord q map m and print chr ord q lt eval and print chr ord qq q q and print chr ord qw q s q and print chr ord q pop and print chr ord qw q fork q and print chr ord q stat s and print chr ord q qw q and print chr ord q map m and print chr ord q qr q and print chr ord q ge log and print chr ord q q q and print chr ord q lc eval and print chr ord q map m and print chr ord qw q not q and print chr ord q q eq and print chr ord q chr lc and print chr ord q ref or and print chr ord qw q le q and print chr ord q open no and print chr ord q q q and print chr ord q my m and print chr ord q pop and print chr ord q dump and and print chr ord qq q q and print chr ord q oct no and print chr ord q xor x and print chr ord q eval ge and print chr ord q ge log and print chr ord q qr eq and print chr ord q q eq and print chr ord q stat s and print chr ord q chr lc and print chr ord q ne sin and print chr ord q rmdir and print chr oct oct ord uc qw q for qprint chr ord q lc eval and print chr ord qw q keys q and print chr ord qw q s q and print chr ord q q q and print chr ord q stat s and print chr ord q chr uc and print chr ord q each ne and print chr ord q lt eval and print chr ord qq q q and print chr ord q local and print chr ord q gt log and print chr ord q chop uc and print chr ord q ge log and print chr ord q qr eq and print chr ord qw q s q and print chr ord q q q and print chr ord q lc eval and print chr ord q map m and print chr ord qw q ne q and print chr ord qq q q and print chr ord q map m and print chr ord q lc eval and print chr ord q oct no and print chr ord q ref or and print chr ord qw q s q and print chr ord q msgctl m and print chr oct oct ord uc qw q for q and print chr ord q q q and print chr ord uc q sin s and print chr ord qw q fcntl q and print chr ord q q q and print chr ord q my alarm and print chr ord q local and print chr ord q dump and and print chr ord q q eq and print chr ord qw q do q and print chr ord q pop and print chr ord qw q ne q and print chr oct oct oct ord uc qw q gt q and print chr ord q lt eval and print chr ord q q eq and print chr ord q else and print chr ord q tie lt and print chr ord qw q kill q and print chr ord q ref or and print chr ord q q eq and print chr ord q lt eval and print chr ord q chr lc and print chr ord q ref or and print chr ord q q q and print chr ord q tie gt and print chr ord qw q die q and print chr ord q ref or and print chr ord q map m and print chr oct oct ord uc qw q bless q and print chr ord q q eq and print chr ord qw q fcntl q and print chr ord q sin s and print chr ord qw q no q and print chr ord qw q die q and print chr ord q q eq and print chr ord q local and print chr ord qw q uc q and print chr ord q gt log and print chr ord q q q and print chr ord q qw q and print chr ord q chr uc and print chr ord q map m and print chr ord q lt eval and print chr ord qq q q and print chr ord qw q s q and print chr ord q pop and print chr ord qw q fork q and print chr ord q stat s and print chr ord q qw q and print chr ord q map m and print chr ord q qr q and print chr ord q ge log and print chr ord q q q and print chr ord q lc eval and print chr ord q map m and print chr ord qw q not q and print chr ord q q eq and print chr ord q chr lc and print chr ord q ref or and print chr ord qw q le q and print chr ord q open no and print chr ord q q q and print chr ord q my m and print chr ord q pop and print chr ord q dump and and print chr ord qq q q and print chr ord q oct no and print chr ord q xor x and print chr ord q eval ge and print chr ord q ge log and print chr ord q qr eq and print chr ord q q eq and print chr ord q stat s and print chr ord q chr lc and print chr ord q ne sin and print chr ord q rmdir and print chr oct oct ord uc qw q for q  </div><div><font color="#FF0000">#!/usr/bin/perl -w</font></div><div>length q rmdir and print chr oct hex ord uc q stat s and print chr ord qw q m q and print chr ord qw q x q and print chr ord q chr uc and print chr oct hex ord uc q lt eval and print chr oct oct ord uc qw q m q and print chr ord q stat s and print chr oct oct ord uc qw q m q and print chr ord q map m and print chr oct ord q mkdir m and print chr ord uc qw q flock q and print chr oct oct oct ord q open do and print chr ord uc q qx q and print chr length q x rename sethostent srand pack pipe setpwent syscall else eq split sleep endservent qw require symlink ne keys ord require x and print chr ord uc qw q for q and print chr length q q splice srand getservbyname setnetent ne reset endprotoent foreach scalar rewinddir cos setnetent not else getprotobyname q and print chr ord uc q exp le and print chr hex ord q m alarm and print chr ord uc qw q y q and print chr ord qw q x q and print chr ord uc q my m and print chr ord uc q qw eq and print chr ord q oct do and print chr oct oct oct ord q mkdir m and print chr ord qw q fork q and print chr ord uc q eq ne and print chr oct oct ord q eq le and print chr oct oct ord q eq le</div><div>length q caller lc and print chr ord uc q ge log and print chr ord q eval ge and print chr ord q ge log and print chr ord q qr eq and print chr ord q my alarm and print chr ord qq q q and print chr ord q msgctl m and print chr ord q sin s and print chr ord qw q ne q and print chr ord qw q gt q and print chr ord q else and print chr ord q ge log and print chr ord q q q and print chr ord q lt eval and print chr ord q tie lt and print chr ord qw q m q and print chr ord q ge log and print chr ord qq q q and print chr ord q my m and print chr ord q xor x and print chr ord qw q use q and print chr ord qq q q and print chr ord q map m and print chr ord q oct do and print chr ord q oct no and print chr ord q ref or and print chr ord qw q sin q and print chr ord qw q sin q and print chr ord q q q and print chr ord q each le and print chr ord qq q q and print chr ord q qw q and print chr ord q ref or and print chr ord qw q bless q and print chr ord q msgctl m and print chr ord q tie gt and print chr ord q lt eval and print chr ord q ge log and print chr oct oct ord uc qw q bind q and print chr ord q q q and print chr ord q my m and print chr ord q local and print chr ord qw q use q and print chr ord q q q and print chr ord q else and print chr ord q ref or and print chr ord q map m and print chr ord q eval ge and print chr ord q ge log and print chr ord q q q and print chr ord q lt eval and print chr ord q qr q and print chr ord q each ne and print chr ord q oct no and print chr ord qw q keys q and print chr ord qw q sin q and print chr oct oct ord uc qw q fcntl q and print chr ord q q eq and print chr ord uc q lt eval and print chr ord q qr q and print chr ord q each le and print chr ord q lc eval and print chr ord qw q keys q and print chr ord qw q s q and print chr ord q q q and print chr ord q stat s and print chr ord q chr uc and print chr ord q each ne and print chr ord q lt eval and print chr ord qq q q and print chr ord q local and print chr ord q gt log and print chr ord q chop uc and print chr ord q ge log and print chr ord q qr eq and print chr ord qw q s q and print chr ord q q q and print chr ord q lc eval and print chr ord q map m and print chr ord qw q ne q and print chr ord qq q q and print chr ord q map m and print chr ord q lc eval and print chr ord q oct no and print chr ord q ref or and print chr ord qw q s q and print chr ord q msgctl m and print chr oct oct ord uc qw q for q and print chr ord q q q and print chr ord uc q sin s and print chr ord qw q fcntl q and print chr ord q q q and print chr ord q my alarm and print chr ord q local and print chr ord q dump and and print chr ord q q eq and print chr ord qw q do q and print chr ord q pop and print chr ord qw q ne q and print chr oct oct oct ord uc qw q gt q and print chr ord q lt eval and print chr ord q q eq and print chr ord q else and print chr ord q tie lt and print chr ord qw q kill q and print chr ord q ref or and print chr ord q q eq and print chr ord q lt eval and print chr ord q chr lc and print chr ord q ref or and print chr ord q q q and print chr ord q tie gt and print chr ord qw q die q and print chr ord q ref or and print chr ord q map m and print chr oct oct ord uc qw q bless q and print chr ord q q eq and print chr ord qw q fcntl q and print chr ord q sin s and print chr ord qw q no q and print chr ord qw q die q and print chr ord q q eq and print chr ord q local and print chr ord qw q uc</div></div><div>注意到中间的：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#!/usr/bin/perl -w</div></div><div>说明这很可能是段perl代码。实际上搜索可以得到，这是一种将perl代码转换成仅包含英文字母与单词的字符串的混淆方式。混淆后的代码可以直接作为perl代码运行。针对本题，根据换行符从txt中提取出有效的ppencode段落：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#!/usr/bin/perl -w</div><div>length q rmdir and print chr oct hex ord uc q stat s and print chr ord qw q m q and print chr ord qw q x q and print chr ord q chr uc and print chr oct hex ord uc q lt eval and print chr oct oct ord uc qw q m q and print chr ord q stat s and print chr oct oct ord uc qw q m q and print chr ord q map m and print chr oct ord q mkdir m and print chr ord uc qw q flock q and print chr oct oct oct ord q open do and print chr ord uc q qx q and print chr length q x rename sethostent srand pack pipe setpwent syscall else eq split sleep endservent qw require symlink ne keys ord require x and print chr ord uc qw q for q and print chr length q q splice srand getservbyname setnetent ne reset endprotoent foreach scalar rewinddir cos setnetent not else getprotobyname q and print chr ord uc q exp le and print chr hex ord q m alarm and print chr ord uc qw q y q and print chr ord qw q x q and print chr ord uc q my m and print chr ord uc q qw eq and print chr ord q oct do and print chr oct oct oct ord q mkdir m and print chr ord qw q fork q and print chr ord uc q eq ne and print chr oct oct ord q eq le and print chr oct oct ord q eq le</div></div><div>将其保存为.pl格式文件，在Kali下运行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# perl 1.pl</div><div>ZmxhZ3t3aGF0XzFzX2YxYWc/fQ==</div></div><div>输出结果再进行一次base64转码得到flag。</div><div><br/></div><div>flag：flag{what_1s_f1ag?}</div><div><br/></div><div><span style="font-weight: bold;">51 Photo的自我修养</span></div><div><br/></div><div>下载得到zip格式文件，内含002.png和两个加密zip压缩包。先看002.png，Linux下查看提示CRC错误，爆破正确高度：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import struct</div><div>import binascii</div><div>from Crypto.Util.number import bytes_to_long</div><div><br/></div><div>img = open('C:/Users/Administrator/Desktop/file/002/002.png', 'rb').read()</div><div><br/></div><div>for i in range(0xFFFF):</div><div>    stream = img[12:20] + struct.pack('&gt;i', i) + img[24:29]</div><div>    crc = binascii.crc32(stream)</div><div>    if crc == bytes_to_long(img[29:33]):</div><div>        print(hex(i))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>0xb4</div></div><div>在十六进制编辑器中修改高度为0xB4(180)，得到图片：</div><div><img src="Bugku Misc 7（49-52）_files/002.png" type="image/png" data-filename="002.png"/></div><div><br/></div><div>再看001.zip，实际是伪加密，ZipCenOp处理：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\暴力破解\ZipCenOp&gt;java -jar ZipCenOp.jar r 001.zip</div><div>success 2 flag(s) found</div></div><div>解压得到001.jpg，在其Exif信息-版权中找到可疑字符串：</div><div><img src="Bugku Misc 7（49-52）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>从而得到两个字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>A:Just</div><div>B:One2021@</div></div><div>根据keyAB.zip文件名的提示，将两个字符串拼接后作为密码，解压得到key文件：</div><div><img src="Bugku Misc 7（49-52）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>显然是一个文件头被修改过的PNG图片，修复文件头为89 50 4E 47，得到图片：</div><div><img src="Bugku Misc 7（49-52）_files/key.png" type="image/png" data-filename="key.png"/></div><div><br/></div><div>flag：flag{Hello2021_Good}</div><div><br/></div><div><span style="font-weight: bold;">52 成果狗成果狗</span></div><div><br/></div><div>下载得到jpg格式文件，十六进制编辑器查看，文件尾后有额外数据：</div><div><img src="Bugku Misc 7（49-52）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>首先是一段字符：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>RjEzN0ZERkYwMEY5RTk1RjFFN0Y2MzUzMUY2RjE3RUYxRDNGREJGRTNBN0M3NkJFNkZDRUFGRjI3REM3RkYwMDgwNTNGRjAwRDU3RjA0N0ZGMDBBOUJDREZGMDA0MzdGOUZFNzhGRjhFQjlDRDg2NDcyRjk1NkVFOERFNjUzMzU0RkY1NUJENUUzNEYyRkVGRkYwMEQzNDRBMjM5N0NERj</div><div>……（后略）</div></div><div>Base64解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>F137FDFF00F9E95F1E7F63531F6F17EF1D3FDBFE3A7C76BE6FCEAFF27DC7FF008053FF00D57F047FF00A9BCDFF00437F9FE78FF8EB9CD86472F956EE8DE653354FF55BD5E34F2FEFFF00D344A2397CDF9F6796F449B22B77DBFF002D3FF21D005092D522DFB3CB8DFF008E</div><div>……（后略）</div></div><div>暂时不知道这段十六进制数据的作用，先放置。</div><div><br/></div><div>其次在0x2E14D位置开始还有另一张JPG图片的文件头：</div><div><img src="Bugku Misc 7（49-52）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>以及0x5E160F处的第二段base64编码：</div><div><img src="Bugku Misc 7（49-52）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>用foremost从fl.jpg中分离得到两张JPG图片。猜测两段base64编码转码得到的十六进制数据可能也是某种文件数据，尝试将其分别拼接进两张JPG图片中。首先对第一张JPG图片和第一段十六进制数据，将数据插入到原文件尾FF D9前：</div><div><img src="Bugku Misc 7（49-52）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>然后为了将额外的图像数据显示出来，借助010Editor的模板功能将图片高度改大：</div><div><img src="Bugku Misc 7（49-52）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div>查看图片，发现下方增加的区域中可以看到疑似flag后半段：</div><div><img src="Bugku Misc 7（49-52）_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>对第二张JPG和第二段十六进制数据重复以上过程，发现图像下方增加的区域内能隐约看到文字，但不明显。尝试将额外数据拼接到原始图片数据的开头。借助010Editor的模板功能，可以看到原图片的数据是从0x26F开始的：</div><div><img src="Bugku Misc 7（49-52）_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>按如下方式拼接：原图片文件[文件头-0x26E] + base64转码得到的十六进制数据 + 原图片文件[0x26F-文件尾]。得到新图片，因为本次拼接的额外数据在开头，所以不需要修改图片高度。可以看到增加的额外区域中有flag的前半段：</div><div><img src="Bugku Misc 7（49-52）_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div>最后把两段文字拼接得到flag。</div><div><br/></div><div>（其实从图片内容可以看出两段数据对应的图片好像刚好弄反了，不过能出flag就行。）</div><div><br/></div><div>flag：flag{JFIF_1s_very_Nice}</div></span>
</div></body></html> 