<html>
<head>
  <title>Bugku Misc 31（145-）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="8910"/>
<h1>Bugku Misc 31（145-）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">145 Where is flag Plus</span></div><div><br/></div><div>下载得到1936个txt格式文件：</div><div><img src="Bugku Misc 31（145-）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>每个文件均包含12个字符，且均来自base64字符集。但直接拼接无法得到有意义的base64编码串，为了确认这些字符串是否随机生成，计算一下字频：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from collections import Counter</div><div><br/></div><div>s = ''.join([open(f'C:/Users/Administrator/Desktop/dir/{i}.txt').read() for i in range(1936)])</div><div>c = Counter(s)</div><div>print(len(c))</div><div>print(''.join([i for i in c]))</div><div>print(c)</div></div><div>运行结果中可以看出三个特征：</div><div>1、字符数实际只有63个，包括大小写字母、数字和等号；</div><div>2、字符间的字频差异存在但很小，有几组字符的字频非常相近或相等。</div><div>因此有理由认为这些字符具有一定随机特性，算一下香农信息熵：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from math import log</div><div><br/></div><div>print(-sum([(c[i] / len(s)) * log(c[i] / len(s), 2) for i in c]))</div><div># 5.97540626686171</div></div><div>略微符合一个随机生成的字符串的信息熵，因此暂时先不管文件内容，看一下这些文本文件的其他信息。</div><div><br/></div><div>用7-Zip打开原本的附件压缩包，依次查看各个文件的属性信息：</div><div><img src="Bugku Misc 31（145-）_files/Image [1].png" type="image/png" data-filename="Image.png" width="306"/><img src="Bugku Misc 31（145-）_files/Image [2].png" type="image/png" data-filename="Image.png" width="294"/></div><div>显然，各个文件的创建时间存在差异，并且不是按文件序号递进的。另一方面，由于有部分文件的创建时间完全相同，很难做到按时间排列并拼接文本。尝试<span style="font-size: unset; color: unset; font-family: unset;">查看部分文件的修改时间戳：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import os</div><div><br/></div><div>for i in range(40):</div><div>    print(os.path.getmtime(f'C:/Users/Administrator/Desktop/dir/{i}.txt'))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1651437998.0</div><div>1651437990.0</div><div>1651438003.0</div><div>1651438006.0</div><div>1651437994.0</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">……（中略）</span></div><div>1651437991.0</div><div>1651437993.0</div><div>1651438006.0</div><div>1651438003.0</div><div>1651438003.0</div></div><div>时间戳范围在 1651437990 - 1651438010 之间。<span style="font-size: unset; color: unset; font-family: unset;">考虑文件的创建时间戳序列携带了某种信息的可能性：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">1、21种时间戳携带了某种21进制信息；</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">2、时间戳的某个特征携带了二进制信息。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">由于</span><span style="font-size: unset; color: unset; font-family: unset;">文本文件总共有1936个，是8的整数倍，首先考虑第二种可能性。携带二进制信息的特征也有多种可能，例如：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">（1）时间戳的个位（同时也是转换为标准时间格式后秒数的个位）奇偶性或其他二值特征；</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">（2）时间戳的千位（仅出现7和8两种数字，本身即为二值信息）。</span></div><div><span style="font-size: unset;"><br/></span></div><div>对以上可能性逐一检查后，确认携带信息的特征为时间戳千位，且7对应二进制位0，8对应1，得到的结果为一个7z格式压缩包。按照惯例，尝试用一行Python代码将其提取：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>open('C:/Users/Administrator/Desktop/1.7z', 'wb').write(int(''.join([str(int(__import__('os').path.getmtime(f'C:/Users/Administrator/Desktop/dir/{i}.txt') &gt;= 1651438000)) for i in range(1936)]), 2).to_bytes(1936//8, 'big'))</div></div><div><br/></div><div>解压7z格式压缩包，得到snow.txt：</div><div><img src="Bugku Misc 31（145-）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>其中包含大量空格和Tab等不可见字符，结合文件名，猜测为SNOW工具隐写。但直接提取隐写信息无法得到有效结果，因此可能在隐写时使用了密码。在没有其他线索的情况下，尝试根据flag格式进行弱密码爆破：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import os</div><div><br/></div><div>password = open('C:/Users/Administrator/Desktop/top1000.txt').read().split('\n')</div><div>for i in password:</div><div>    try:</div><div>        res = os.popen(f'D:/CTFToolkit-v1.1.0/信息隐藏/snow/snow.exe -C -p {i} C:/Users/Administrator/Desktop/snow.txt').read()</div><div>        if res.startswith('flag{'):</div><div>            print(i, res)</div><div>            break</div><div>    except:</div><div>        pass</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>5201314 flag{P6pbgN53q7l5D/ffTY2jH3uJVTQ7}</div></div><div><br/></div><div>flag：flag{P6pbgN53q7l5D/ffTY2jH3uJVTQ7}</div><div><br/></div><div><span style="font-weight: bold;">146 simple MQTT</span></div><div><br/></div><div>下载得到pcapng格式文件，wireshark打开：</div><div><img src="Bugku Misc 31（145-）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>全部都是MQTT协议。</div><div><br/></div><div>参考<a href="https://blog.csdn.net/qq_28877125/article/details/78325003">MQTT协议入门</a>，依次查看数据包，发现13号数据包在 /game/flag 这一topic下发送了Public Message：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>526172211a0701003392b5e50a01050600050101808000597b62d05d02033cb00004a6002073a10fe780030010666c61675f69735f686572652e747874300100030f17f69e4634a29347a81d0d9d379bec15d4c6c6c0dc85da4401b6192e03c639bae9ae8c2120ef8b93160855850a0302aa1f181e4ad8d70197fa95c70fd8084ee40579c7f99a91074ef0a9639880df0411126ed5c146bc11b1984e922c547be3a2fe07ac071651281d77565103050400</div></div><div>十六进制转码可以得到一个加密的RAR格式压缩包。</div><div><br/></div><div>继续往下看，21号数据包在 /game/flag/find_flag 这一topic下发送了Public Message：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>th1s_1s_rar_p@ssw0rd</div></div><div>以此为密码解压刚才的压缩包，得到flag。</div><div><br/></div><div>flag：flag{46ee7eb02d4c3b504ce79c054464bfd2}</div><div><br/></div><div><span style="font-weight: bold;">147 真正的爱情</span></div><div><br/></div><div>下载附件得到两个jpg格式文件。聊天记录.jpg：</div><div><img src="Bugku Misc 31（145-）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>每句话前后中间都有毫无意义的点，如果把汉字看作长音，点看作短音，那就是摩斯电码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>.-- .- -. -.. .-- -... -..- -.. .-- -.</div></div><div>解码得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>wandwbxdwn</div></div><div><br/></div><div>另一张 女朋友的表情包.jpg 文件尾后有额外数据，为加密的zip格式压缩包。提取后用上述密码解压，可以得到一个mp3格式音频文件和memory.zip。后者又是一个加密压缩包，那么先看前者。播放一下发现很明显是电话拨号音，导出成wav格式然后上工具：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\信息隐藏\dtmf2num&gt;dtmf2num.exe 1.wav</div><div><br/></div><div>DTMF2NUM 0.1.1</div><div>by Luigi Auriemma</div><div>e-mail: aluigi@autistici.org</div><div>web:    aluigi.org</div><div><br/></div><div>- open 1.wav</div><div>  wave size      587708</div><div>  format tag     1</div><div>  channels:      2</div><div>  samples/sec:   44100</div><div>  avg/bytes/sec: 176400</div><div>  block align:   4</div><div>  bits:          16</div><div>  samples:       293854</div><div>  bias adjust:   11</div><div>  volume peaks:  -16396 16397</div><div>  normalize:     16370</div><div>  resampling to: 8000hz</div><div><br/></div><div>- MF numbers:    7</div><div><br/></div><div>- DTMF numbers:  <font color="#FF0000">19865153975</font></div></div><div><br/></div><div>解压memory.zip得到memory.pptx和flag.zip，后者又是一个加密压缩包，那么先看前者。打开PPT发现是28页图像和1页文字，但如果用压缩软件打开这个pptx，查看 ppt\media\ 目录，会发现28个net格式文件以外还有两个jpg格式图像：</div><div><img src="Bugku Misc 31（145-）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>前者对应28页PPT里的图像，后两者却没有在PPT里直接显示，提取出来看一下，image30没有用，看image29：</div><div><img src="Bugku Misc 31（145-）_files/image29.jpg" type="image/jpeg" data-filename="image29.jpg"/></div><div>搜图发现这是独立游戏<a href="https://zh.wikipedia.org/wiki/%E8%8F%B2%E6%96%AF_(%E6%B8%B8%E6%88%8F)">《FEZ》</a>中的原创字母表：</div><div><img src="Bugku Misc 31（145-）_files/R4xDh.png" type="image/png" data-filename="R4xDh.png"/></div><div>对照一下即可得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>wdxcyyyzyq</div></div><div>为什么最后一位是q呢，因为出题人压根不会画FEZ字母表，把KQ字符画错成了X，所以乍一看都会觉得最后一位应该是x。但仔细看可以注意到图中第三个字符和最后一个字符是有略微差异的，所以这两位其实是不同字符，懒得试的情况下，用wd?cyyyzy?掩码爆破一下就能得到密码了。这也教育我们，画错了就画错了，在题目评论里给一堆似是而非的提示反而更加令人迷惑。</div><div><br/></div><div>解压最后这个压缩包得到mp4格式视频文件，视频内容没有什么意义，考虑从视频本身入手。在视频开头暂停仔细看了看，发现右下角有个flag{。如果看不到也可以试试换块屏幕：</div><div><img src="Bugku Misc 31（145-）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>视频长度约24秒，帧率为60，把每帧都提取成图像：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ffmpeg -i flag.mp4 -r 60 -f image2 ./frame/frame%4d.png</div></div><div>最后得到1444个帧图像，把第一帧放到Stegsolve里看看：</div><div><img src="Bugku Misc 31（145-）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>在R/G/B Plane 0的右下角确实能看到flag痕迹。一帧一帧看问题其实也不大，不过还是写个脚本把部分帧的低位右下角拿出来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>def cut(frame):</div><div>    img = Image.open(f'C:/Users/Administrator/Desktop/frame/frame{frame}.png')</div><div>    img = img.crop((1700, 1900, 2335, 2159))</div><div>    p = img.load()</div><div>    w, h = img.size</div><div>    for x in range(w):</div><div>        for y in range(h):</div><div>            p[x, y] = tuple([(p[x, y][c] % 2) * 255 for c in range(3)])</div><div>    img.save(f'C:/Users/Administrator/Desktop/frame2/frame{frame}.png')</div><div><br/></div><div>for i in range(1, 1445, 50):  # 每隔50帧提取一次</div><div>    cut(str(i).zfill(4))</div></div><div>得到：</div><div><img src="Bugku Misc 31（145-）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{1_Wi1l_L0ve_You_fore5er}</div></span>
</div></body></html> 