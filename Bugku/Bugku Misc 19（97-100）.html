<html>
<head>
  <title>Bugku Misc 19（97-100）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4146"/>
<h1>Bugku Misc 19（97-100）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">97 FileStoragedat</span></div><div><br/></div><div>下载得到dat格式文件。十六进制编辑器或file命令查看，均无法判断文件格式，猜测文件可能被按字节加密。根据提示，搜索题目名称，发现FileStorage是PC端微信用于存放聊天记录内图片等文件缓存的目录名称，且存放的文件被按字节异或加密。尝试寻找异或密钥。十六进制编辑器打开附件，观察字节特征：</div><div><img src="Bugku Misc 19（97-100）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>已知异或密钥长度为1字节，因此源文件中第5和第7个字节是相同的。同时异或加密后的文件中存在大量连在一起的9E字节。此外，文件末尾的12个字节中，前4个字节也均为9E：</div><div><img src="Bugku Misc 19（97-100）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>结合上述特征可以判断，源文件为PNG格式图片，加密后的9E字节对应源文件的00字节，从而异或密钥也为9E。验证一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>s = '17CED0D9'</div><div>for i in range(0, 8, 2):</div><div>    n = int(s[i:i+2], 16)</div><div>    print(hex(n ^ 0x9E), end = ' ')</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>0x89 0x50 0x4e 0x47 </div></div><div>验证通过，异或解密得到源文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('C:/Users/Administrator/Desktop/keli.dat', 'rb').read()</div><div>new = open('C:/Users/Administrator/Desktop/keli.png', 'ab')</div><div><br/></div><div>for i in f:</div><div>    n = int(i) ^ 0x9E</div><div>    new.write(int(n).to_bytes(1, 'big'))</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">得到图像：</span></div><div><img src="Bugku Misc 19（97-100）_files/keli.png" type="image/png" data-filename="keli.png"/></div><div><br/></div><div>flag：bugku{WeChatwithSteg0}</div><div><br/></div><div><span style="font-weight: bold;">98 一切有为法如梦幻泡影</span></div><div><br/></div><div>下载得到zero.png和加密的zip压缩包。先看前者，十六进制编辑器打开，文件尾后有额外数据：</div><div><img src="Bugku Misc 19（97-100）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>分解得到zip格式压缩包，解压得到另一张png格式图片：</div><div><img src="Bugku Misc 19（97-100）_files/问.png" type="image/png" data-filename="问.png"/></div><div>注意到边角的花纹，与最初的Zero.png是一样的，如果以三角形为界，横向和竖向的花纹实际上是对称的。取出一半：</div><div><img src="Bugku Misc 19（97-100）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>显然是摩斯电码，对应的字符是42。</div><div><br/></div><div>尝试以42为密码解压加密的zip压缩包，得到one.png和第二个加密zip压缩包。同样先看前者，同样在文件尾后有额外数据，同样可以分离出zip格式压缩包，同样解压得到另一张png格式图片：</div><div><img src="Bugku Misc 19（97-100）_files/感.png" type="image/png" data-filename="感.png"/></div><div>先不说这个设计感觉有点中二，但里面还有错别字就令人感觉有点尴尬……<span style="font-size: unset; color: unset; font-family: unset;">从提示中可以猜测为LSB隐写，用zsteg：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# zsteg 00000000.png</div><div>b1,rgb,lsb,xy       .. text: &quot;ZipPassword{Z8Kt%}&quot;</div></div><div><br/></div><div>再次解压得到Tow.jpg、Tow.mp3和第三个加密zip压缩包。惯例先看前者，惯例文件尾后有额外数据，惯例可以分离出zip格式压缩包，惯例解压得到另一张jpg格式图片：</div><div><img src="Bugku Misc 19（97-100）_files/思.jpg" type="image/jpeg" data-filename="思.jpg"/></div><div>分解Tow.mp3同样可以得到两张png格式图片，但内容与两张jpg格式图片一致。Audacity打开Tow.mp3，切换到频谱图：</div><div><img src="Bugku Misc 19（97-100）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>以jBL7@为密码解压加密的zip格式压缩包，得到Treee.jpg。（这时候我突然发现难道前面的文件名Tow是Two打错了……）总之文件尾后还是有额外数据，还是可以分离出zip格式压缩包，还是解压得到另一张jpg格式图片（以及一个号称是彩蛋的加密zip压缩包）：</div><div><img src="Bugku Misc 19（97-100）_files/疑.jpg" type="image/jpeg" data-filename="疑.jpg"/></div><div>彩蛋的密码比较简单，注意到上述几张图下方都有数量不等的圆点，数量依次是2、7、6、5，彩蛋压缩包的密码就是2765。解压后得到txt格式文本，内容是机核网的<a href="https://www.gcores.com/articles/95210">一篇投稿文章</a>。</div><div><br/></div><div>回到正题，十六进制编辑器打开Three.jpg，文件末尾（即zip压缩包的数据之后）有一段base64密文：</div><div><img src="Bugku Misc 19（97-100）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>YnVna3V7d2lzaHlvdWFoYXBweWRheX0=</div></div><div>转码得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>bugku{wishyouahappyday}</div></div><div><br/></div><div>flag：bugku{wishyouahappyday}</div><div><br/></div><div><span style="font-weight: bold;">99 低位的色彩</span></div><div>flag格式为：flag图片背景颜色+flag字体颜色+flag内容。<span style="font-size: unset; color: unset; font-family: unset;">如：</span><span style="font-size: unset; color: unset; font-family: unset;">flag图片背景颜色为红色，</span><span style="font-size: unset; color: unset; font-family: unset;">flag字体颜色为蓝色，</span><span style="font-size: unset; color: unset; font-family: unset;">flag内容为flag{this_is_a_fake_flag}，</span><span style="font-size: unset; color: unset; font-family: unset;">则正确的flag为：flag{red_blue_this_is_a_fake_flag}。</span></div><div><br/></div><div>下载得到png格式文件。Stegsolve查看，在G/B Plane 0和R Plane 5-0处均可以看到LSB隐写痕迹：</div><div><img src="Bugku Misc 19（97-100）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><img src="Bugku Misc 19（97-100）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><img src="Bugku Misc 19（97-100）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>显然flag图像被隐藏在了颜色通道的低位。但按二进制提取低位，无论位数取多少均无法得到清晰的图像，尝试按十进制低位提取。对原图的每一像素的RGB通道，各提取其十进制个位并放大到0-255范围：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/flag.png')</div><div>res = Image.new('RGB', img.size)</div><div>w, h = img.size</div><div><br/></div><div>for x in range(w):</div><div>    for y in range(h):</div><div>        p1 = img.getpixel((x, y))</div><div>        p2 = [0, 0, 0]</div><div>        for i in range(3):</div><div>            p2[i] = (p1[i] % 10) * 255 // 9</div><div>        res.putpixel((x, y), tuple(p2))</div><div>res.save('C:/Users/Administrator/Desktop/goudoubuzuo.png')</div></div><div>运行结果：</div><div><img src="Bugku Misc 19（97-100）_files/goudoubuzuo.png" type="image/png" data-filename="goudoubuzuo.png"/></div><div>按照出题人出完题发现Stegsolve可以直接看到flag从而强行找补的flag格式拼接，得到flag。</div><div><br/></div><div>flag：flag{red_black_happy_bugku_y0000}</div><div><br/></div><div><b>100 where is flag</b></div><div><br/></div><div>下载得到1-10.txt共十个文本文件。稍作观察可以发现，所有文件的内容均为大量00字节，没有其他信息，但每个文件的长度均不相同。将文件长度依次读取列出：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for i in range(1, 11):</div><div>    path = 'C:/Users/Administrator/Desktop/file/' + str(i) + '.txt'</div><div>    file = open(path, 'rb').read()</div><div>    print(len(file), end = ' ')</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>98117 10310 71171 23110 9748 100481 10103 10097 10797 49125</div></div><div>很明显是十进制ASCII码，重新排列一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>98 117 103 107 117 123 110 97 48 100 48 110 103 100 97 107 97 49 125</div></div><div>直接转码得到flag。</div><div><br/></div><div>flag：bugku{na0d0ngdaka1}</div></span>
</div></body></html> 