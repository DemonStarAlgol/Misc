<html>
<head>
  <title>Bugku Misc 23（113-116）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4717"/>
<h1>Bugku Misc 23（113-116）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">113 蜜雪冰城~</span></div><div><br/></div><div>普通套娃题，没什么特别好说的。</div><div><br/></div><div>下载附件得到三个文件，先看encode.py：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>f = open(&quot;你爱我呀我爱你.txt&quot;, 'w+')  </div><div>im = Image.open('flag.jpg')</div><div>width = 10</div><div>height = 20</div><div>rgb_im = im.convert('RGB')</div><div>for i in range(width):</div><div>    for j in range(height):</div><div>        print(rgb_im.getpixel((i, j)))</div><div>        print(rgb_im.getpixel((i, j)),file=f)</div><div>f.close()</div></div><div>把一张图片的RGB颜色值写入txt文件，再看给出的txt文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(255, 255, 255)</div><div>(0, 0, 0)</div><div>(255, 255, 255)</div><div>(0, 0, 0)</div><div>(255, 255, 255)</div><div>(255, 255, 255)</div><div>(0, 0, 0)</div><div>(0, 0, 0)</div><div>(255, 255, 255)</div><div>(0, 0, 0)</div><div>(0, 0, 0)</div><div>(255, 255, 255)</div><div>……（后略）</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">注意到txt文本共有200行，且仅出现黑白两种颜色，考虑将其替换成0和1后二进制ASCII转码：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('C:/Users/Administrator/Desktop/你爱我呀我爱你.txt').readlines()</div><div><br/></div><div>tmp = ''</div><div>for i in f:</div><div>    tmp += str(1 - int(i[1]) // 2)</div><div>    if len(tmp) == 8:</div><div>        print(chr(int(tmp, 2)), end='')</div><div>        tmp = ''</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SlientEye{1251521mxbctmm}</div></div><div><br/></div><div>用SilentEye提取jpg图片中的隐写信息：</div><div><img src="Bugku Misc 23（113-116）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>链接：https://pan.baidu.com/s/1_qELzkTP7WaSq2gf30g1nA</div><div>提取码：bqcr</div></div><div><br/></div><div>下载得到a.mp3，audacity打开：</div><div><img src="Bugku Misc 23（113-116）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>音频末尾有比较明显的摩斯电码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>-- .--. ...-- ... - . --. --- .. ... .. .-.. --- ...- . -.-- --- ..- -.-- --- ..- .-.. --- ...- . -- .</div></div><div>转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>MP3STEGOISILOVEYOUYOULOVEME</div></div><div><br/></div><div>按照提示，直接上MP3Stego：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\信息隐藏\MP3Stego_1_1_18\MP3Stego&gt;Decode.exe -X -P ILOVEYOUYOULOVEME C:\Users\Administrator\Desktop\a.mp3</div></div><div>提取隐写信息得到txt文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{1251_521_m1xueb1n9chen9ti@nm1mi}</div></div><div><br/></div><div>flag：flag{1251_521_m1xueb1n9chen9ti@nm1mi}</div><div><br/></div><div><span style="font-weight: bold;">114 简单套娃DX</span></div><div><br/></div><div>下载得到大量文件名为乱码的小文件，共8080个：</div><div><img src="Bugku Misc 23（113-116）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>随机选取几个用十六进制编辑器查看：</div><div><img src="Bugku Misc 23（113-116）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><img src="Bugku Misc 23（113-116）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>能够看到明显的PNG格式图片结构。但尝试重命名后会发现，部分图片损坏无法显示，部分图片宽高存在问题，仅有少量图片能够正常显示，为5x5的黑白两色图像。借助十六进制编辑器也可以发现，其余的图片结构都被破坏，需要修复。<span style="font-size: unset; color: unset; font-family: unset;">通过逐项排查的方式可以确定共有七种结构破坏方式：</span></div><div>1、文件头8字节被删除；</div><div>2、IHDR块的长度位和标记位替换为00；</div><div>3、IDAT块长度位替换为00；</div><div>4、IHDR块被整体移动到IEND块前；</div><div>5、宽度和高度被改为10-100的随机数；</div><div>6、IDAT块标记位被删除；</div><div>7、Color type被改为2-6的随机数。</div><div><br/></div><div>从而可以写出脚本对其进行自动化修复。其中宽、高和Color Type等参数可以从正常图片中取得：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import os</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>def RepairPNG(filename):</div><div>    file = open('./XD/' + filename, 'rb').read()</div><div>    if file[1:4] != b'PNG':</div><div>        file = int(0x89504E470D0A1A0A).to_bytes(8, 'big') + file</div><div>    if file[8:16] == int(0).to_bytes(8, 'big'):</div><div>        file = file[:8] + int(0x0000000D49484452).to_bytes(8, 'big') + file[16:]</div><div>    if file[33:37] == int(0).to_bytes(4, 'big') and file[37:41] == b'IDAT':</div><div>        len_idat = file.index(b'eXIf') - 49</div><div>        file = file[:33] + int(len_idat).to_bytes(4, 'big') + file[37:]</div><div>    if file[12:16] != b'IHDR':</div><div>        file = file[:8] + file[-37:-12] + file[8:-37] + file[-12:]</div><div>    if file[16:24] != int(0x500000005).to_bytes(8, 'big'):</div><div>        file = file[:16] + int(0x500000005).to_bytes(8, 'big') + file[24:]</div><div>    if file[1:4] == b'PNG' and file[12:16] == b'IHDR' and file[37:41] != b'IDAT':</div><div>        file = file[:37] + b'IDAT' + file[37:]</div><div>    if file[1:4] == b'PNG' and file[12:16] == b'IHDR' and file[25] != b'\x00':</div><div>        file = file[:25] + b'\x00' + file[26:]</div><div>    with open('./XD_repair/' + filename + '.png', 'wb') as res:</div><div>        res.write(file)</div><div><br/></div><div>for i in os.listdir('XD'):</div><div>    RepairPNG(i)</div></div><div>修复完成得到8080张正常图片：</div><div><img src="Bugku Misc 23（113-116）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>接下来从这些图片中寻找下一步的线索。之前用十六进制编辑器查看文件时就已经注意到，PNG图片中包含eXIf块，因此图片中必然携带了额外的exif信息。任选一张图片用exiftool查看：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop\XD_repair&gt;exiftool aAFRoNjh.png</div><div>ExifTool Version Number         : 12.21</div><div>File Name                       : aAFRoNjh.png</div><div>Directory                       : .</div><div>File Size                       : 165 bytes</div><div>File Modification Date/Time     : 2021:07:08 11:44:56+08:00</div><div>File Access Date/Time           : 2021:07:08 11:44:56+08:00</div><div>File Creation Date/Time         : 2021:07:08 11:44:56+08:00</div><div>File Permissions                : -rw-rw-rw-</div><div>File Type                       : PNG</div><div>File Type Extension             : png</div><div>MIME Type                       : image/png</div><div>Image Width                     : 5</div><div>Image Height                    : 5</div><div>Bit Depth                       : 1</div><div>Color Type                      : Grayscale</div><div>Compression                     : Deflate/Inflate</div><div>Filter                          : Adaptive</div><div>Interlace                       : Noninterlaced</div><div>Exif Byte Order                 : Big-endian (Motorola, MM)</div><div>X Resolution                    : 278</div><div>Y Resolution                    : 11</div><div>Resolution Unit                 : inches</div><div>Y Cb Cr Positioning             : Centered</div><div>Image Size                      : 5x5</div><div>Megapixels                      : 0.000025</div></div><div>任意对比两张图片的exif信息，会发现仅有X Resolution和Y Resolution有所不同，联想到这可能隐藏着某种坐标，需要将图片按照坐标拼在一起。首先取得X Resolution和Y Resolution的最大值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>axis_x, axis_y = [], []</div><div>for i in range(86):</div><div>    x = os.popen('exiftool -xresolution ./XD_repair/' + os.listdir('XD_repair')[i]).read().split(': ')[1]</div><div>    axis_x += [int(x)]</div><div>    y = os.popen('exiftool -yresolution ./XD_repair/' + os.listdir('XD_repair')[i]).read().split(': ')[1]</div><div>    axis_y += [int(y)]</div><div>    print(i, max(axis_x), max(axis_y))</div></div><div>运行一段时间后两个最大值就稳定在449和19，从而原图应由450x20张5x5小图拼合而成。</div><div><br/></div><div>最后开始拼图：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>img = Image.new('RGB', (450 * 5, 20 * 5), (255, 255, 255))</div><div><br/></div><div>i = 0</div><div>for filename in os.listdir('XD_repair'):</div><div>    print(i, filename)</div><div>    x = os.popen('exiftool -xresolution ./XD_repair/' + filename).read().split(': ')[1]</div><div>    x = int(x) * 5</div><div>    y = os.popen('exiftool -yresolution ./XD_repair/' + filename).read().split(': ')[1]</div><div>    y = int(y) * 5</div><div>    patch = Image.open('./XD_repair/' + filename)</div><div>    img.paste(patch, (x, y, x+5, y+5))</div><div>    i += 1</div><div>img.save('res.png')</div></div><div>用exiftool读取exif信息实际比较耗时间。需要优化代码的话，可以修改取得坐标部分，改为仅调用一次exiftool，或者尝试根据PNG图像eXIf块数据规范，直接从字节数据中提取X Resolution和Y Resolution。<span style="font-size: unset; color: unset; font-family: unset;">总而言之，拼图完毕得到：</span></div><div><img src="Bugku Misc 23（113-116）_files/res.png" type="image/png" data-filename="res.png"/></div><div><br/></div><div>flag：<span style="-en-paragraph:true;">bugku{H1pp0Po7om0n5tRos3s9Uipped4L1opHo6i4}</span></div><div><br/></div><div><span style="-en-paragraph:true;"><span style="font-weight: bold;">115 Snowfall</span></span></div><div><br/></div><div>下载得到两个txt格式文件，根据文件名，先看step1：</div><div><img src="Bugku Misc 23（113-116）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>一篇文章，从句式和内容可以判断是用<a href="https://suulnnka.github.io/BullshitGenerator/index.html">狗屁不通文章生成器</a>自动生成的，没有意义。注意到每行文字后大部分都跟着由Tab和空格组成的不可见字符串，很可能携带了隐藏信息。通常来说这类不可见字符串隐藏信息的常见方法包括：</div><div>1、用空格和Tab组成01二进制值串，然后转ASCII码或进行其他转码，但尝试后发现规律不明确；</div><div>2、用特定的隐写工具，例如SNOW，但SNOW产生的隐写字符串位于文件末尾，而非每行的末尾；</div><div>3、<a href="https://esolangs.org/wiki/Whitespace">Whitespace</a>，一种以空格、Tab和换行三种字符组成的esolang。</div><div>尝试后可以发现这里用的是第三种。</div><div><br/></div><div>那么接下来运行一下这段Whitespace程序。有很多种方法，例如<a href="https://www.dcode.fr/whitespace-language">在线字符串转换工具</a>（但只能转换输出为字符形式的代码，且可能无法运行过长的代码）和在线IDE（<a href="https://ideone.com/">1</a> <a href="http://vii5ard.github.io/whitespace/">2</a>），此外在<a href="https://github.com/wspace/corpus">github</a>也能找到各类解释器的集合。虽然Whitespace运行时会自动忽略所有可见字符，但部分解释器可能不支持中文Unicode字符。这种情况下写个脚本，仅保留不可见字符：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('step1.txt', 'r').read()</div><div>code = ''</div><div>for i in f:</div><div>    if i in [' ', '\t', '\n']:</div><div>        code += i</div><div>with open('code1.txt', 'w') as c:</div><div>    c.write(code)</div></div><div>再运行即可：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;whitespace code1.txt</div><div>OK now you can run whitespace code. By the way, the key is H0wt0Pr1ntAWh17e5p4ceC0de.</div></div><div>得到了一个密钥：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>H0wt0Pr1ntAWh17e5p4ceC0de</div></div><div>但暂时还不知道有什么用。</div><div><br/></div><div>再看step2，很显然也是一段Whitespace代码。尝试用同样方法运行，但很可能报错。再用<a href="https://ideone.com/">在线IDE</a>跑一下：</div><div><img src="Bugku Misc 23（113-116）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>很显然这是一个7z格式压缩包的字节被当成ASCII字符输出的结果，其中还可以看到压缩包内的文件是flag.txt。</div><div><br/></div><div>手动查看一下step2代码的开始段落。这里以S、T和E分别表示空格、Tab和换行，并按行分离代码语句：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SSSSE 栈顶压入数字0</div><div>SSSTTSTTTE 栈顶压入数字0b110111=0x37</div><div>TSSS 栈顶两个数相加之和替换栈顶</div><div>SES 复制栈顶的数</div><div>TESS 以ASCII形式输出栈顶</div><div>SSSTSTSTTTTE 栈顶压入数字0b10101111=0xAF</div><div>SSSTSTTTTSSE 栈顶压入数字0b10111100=0xBC</div><div>SSSTTTTSTSE 栈顶压入数字0b1111010=0x7A</div><div>TESS 以ASCII形式输出栈顶</div><div>TESS 以ASCII形式输出栈顶</div><div>SES 复制栈顶的数</div><div>TESS 以ASCII形式输出栈顶</div><div>……（后略）</div></div><div>可以发现所有的输出语句都为“以ASCII形式输出”，而压缩包的字节并非全部都能转为ASCII可打印字符，从而产生了乱码。一个比较简单的做法是把所有输出语句改为“以数字形式输出”，即把TESS全部改为TEST。</div><div><br/></div><div>但直接替换是不可行的，因为其他相连的代码语句也可能产生TESS这样的字符串，例如上方代码中第6行的结尾和第7行的开头。但仔细观察可以发现，大部分的输出语句是接在SES这一复制栈顶命令之后的，少部分输出语句表现为连续执行1-4次输出、执行一次复制栈顶、执行一次输出的形式。因而有以下替换规则：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('step2.txt', 'r').read()</div><div>code = ''</div><div>for i in f:</div><div>    if i in [' ', '\t', '\n']:</div><div>        code += i</div><div><br/></div><div>def Translate(string):</div><div>    dic = {'S': ' ', 'T': '\t', 'E': '\n'}</div><div>    res = ''</div><div>    for i in string:</div><div>        res += dic[i]</div><div>    return res</div><div><br/></div><div>a, b, c = Translate('TESS'), Translate('TEST'), Translate('SES')</div><div>for i in range(5, 0, -1):</div><div>    code = code.replace(a * (i - 1) + c + a, b * (i - 1) + c + b)</div><div><br/></div><div>with open('code2.txt', 'w') as c:</div><div>    c.write(code)</div></div><div>得到代码后，前面提到的两个在线IDE都可以运行。运行结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>551221881753928042331781031481760000000106000000020561162911481631016161231111461952291997719717622622744177439616118325952111252217010211715721921138913419919090208113230131134158192184130200499516969184362026926916013361317611555167181220144241561281595214364170177641298312216925215917033201531418673351495620911122746146218186077165232483821320113618249150902252551951012365131442389331150182136407313710521803292123250128137207217187152021541871722292212237758566223423817520623690651972345324298189936913558146019128176071110236624171188315181857825024919819918617174811851722924513633331010121281621318508101126781398005117190102010809701030460116012001160002502010105092151501481192151216103200000</div></div><div>是一串没有分割的十进制数，处理起来比较麻烦。如果没有本地解释器的话，可以利用一下第二个IDE给出的按步运行功能：</div><div><img src="Bugku Misc 23（113-116）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>顺便说一下关于这里给出的汇编命令形式转译，建议对照Whitespace的语法理解，网上部分WP里通过瞎猜得到的所谓“总结”是有问题的（但理解错误却能刚好得到本题的正确结果，只能说太强了）。总之<span style="font-size: unset; color: unset; font-family: unset;">点击Step，每次运行到printi时会输出一个数字，可以辅助分割结果。最终得到：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>55 122 188 175 39 28 0 4 233 178 103 148 176 0 0 0 0 0 0 0 106 0 0 0 0 0 0 0 205 61 162 91 148 163 10 161 6 123 111 146 195 229 199 77 197 176 226 227 44 177 43 96 161 183 25 95 211 125 221 70 102 117 157 219 2 113 89 134 199 190 90 208 113 2 30 131 134 158 192 184 130 200 49 95 169 69 184 36 202 69 2 69 160 13 36 13 176 115 55 167 181 220 144 24 156 128 159 52 143 64 170 177 64 129 83 122 169 252 159 170 33 201 53 141 86 73 35 149 56 209 111 227 46 146 218 18 60 77 165 23 248 38 213 201 136 18 249 150 90 225 255 195 101 23 65 13 144 238 93 31 150 182 136 40 73 137 105 218 0 3 2 92 123 250 128 137 207 217 187 15 202 154 187 172 229 221 223 77 58 56 62 234 238 175 206 236 90 65 197 234 53 242 98 189 93 69 135 58 1 4 6 0 1 9 128 176 0 7 11 1 0 2 36 6 241 7 1 18 83 15 181 85 78 250 249 198 199 186 171 74 81 185 17 229 245 136 33 33 1 0 1 0 12 128 162 131 85 0 8 10 1 126 78 13 98 0 0 5 1 17 19 0 102 0 108 0 97 0 103 0 46 0 116 0 120 0 116 0 0 0 25 0 20 10 1 0 50 92 151 50 148 119 215 1 21 6 1 0 32 0 0 0 0 0</div></div><div>最后生成7z压缩包：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>s = '55 122 188 175 39 28 0 4 233 178 103 148 176 0 0 0 0 0 0 0 106 0 0 0 0 0 0 0 205 61 162 91 148 163 10 161 6 123 111 146 195 229 199 77 197 176 226 227 44 177 43 96 161 183 25 95 211 125 221 70 102 117 157 219 2 113 89 134 199 190 90 208 113 2 30 131 134 158 192 184 130 200 49 95 169 69 184 36 202 69 2 69 160 13 36 13 176 115 55 167 181 220 144 24 156 128 159 52 143 64 170 177 64 129 83 122 169 252 159 170 33 201 53 141 86 73 35 149 56 209 111 227 46 146 218 18 60 77 165 23 248 38 213 201 136 18 249 150 90 225 255 195 101 23 65 13 144 238 93 31 150 182 136 40 73 137 105 218 0 3 2 92 123 250 128 137 207 217 187 15 202 154 187 172 229 221 223 77 58 56 62 234 238 175 206 236 90 65 197 234 53 242 98 189 93 69 135 58 1 4 6 0 1 9 128 176 0 7 11 1 0 2 36 6 241 7 1 18 83 15 181 85 78 250 249 198 199 186 171 74 81 185 17 229 245 136 33 33 1 0 1 0 12 128 162 131 85 0 8 10 1 126 78 13 98 0 0 5 1 17 19 0 102 0 108 0 97 0 103 0 46 0 116 0 120 0 116 0 0 0 25 0 20 10 1 0 50 92 151 50 148 119 215 1 21 6 1 0 32 0 0 0 0 0'.split(' ')</div><div><br/></div><div>data = b''</div><div>for i in s:</div><div>    data += int(i).to_bytes(1, 'big')</div><div>with open('flag.7z', 'wb') as f:</div><div>    f.write(data)</div></div><div>得到的压缩包带有密码，用之前获得的密码解压，得到flag.txt。</div><div>当然，如果有本地解释器的话就不需要这么麻烦，直接欺骗解释器，修改解释器的代码让其将所有的TESS（以ASCII字符输出）解释为“以数字形式输出”，再运行代码即可，你甚至可以让解释器在输出数字之后顺便输出个空格。考虑到本地解释器种类较多，这里不再赘述具体操作，请大家自己完成。</div><div><br/></div><div>看一下flag.txt，同样是一段Whitespace代码：</div><div><img src="Bugku Misc 23（113-116）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>直接运行不会报错，但也不输出任何结果。同样手动查看一下代码的开头段落：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SSSSE 栈顶压入数字0</div><div>SSSTTSSSTSE 栈顶压入数字0b1100010=98</div><div>TSSS 栈顶两数相加结果替换为栈顶</div><div>SES 复制栈顶</div><div>SEE 弹出栈顶</div><div>SSSTTSSTTTE 栈顶压入数字0b1100111=103</div><div>SSSTTTSTSTE 栈顶压入数字0b1110101=117</div><div>SEE 弹出栈顶</div><div>SES 复制栈顶</div><div>SEE 弹出栈顶</div><div>SSSTTSTSTTE 栈顶压入数字0b1101011=107</div><div>SES 复制栈顶</div><div>SEE 弹出栈顶</div><div>……（后略）</div></div><div>可以看到有大量弹出栈顶操作，但没有找到任何输出操作，因此代码运行后什么都没有输出。</div><div>但这段代码必然携带了某种信息，从而猜测有两种可能：</div><div>1、代码运行完毕后，留在栈里的数字构成了信息；</div><div>2、代码运行过程中，从栈顶弹出的数字按顺序构成了信息。</div><div><br/></div><div>先验证第一种可能性，用<a href="http://vii5ard.github.io/whitespace/">这个在线IDE</a>运行代码，然后查看Memory：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Stack: [98, 103, 117, 70, 49, 120, 110, 53, 103, 114, 109, 84, 48, 97, 114, 70, 49, 125]</div></div><div>十进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>bguF1xn5grmT0arF1}</div></div><div>并不是flag。</div><div><br/></div><div>验证第二种可能性，仍然是手动跟踪代码开头部分，但记录栈和弹出序列：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SSSSE 栈顶压入数字0 | 0</div><div>SSSTTSSSTSE 栈顶压入数字0b1100010=98 | 98 0</div><div>TSSS 栈顶两数相加之和替换栈顶 | 98 0</div><div>SES 复制栈顶 | 98 98 0</div><div>SEE 弹出栈顶 | 98 0 | 弹出序列 98</div><div>SSSTTSSTTTE 栈顶压入数字0b1100111=103 | 103 98 0</div><div>SSSTTTSTSTE 栈顶压入数字0b1110101=117 | 117 103 98 0</div><div>SEE 弹出栈顶 | 103 98 0 | 弹出序列 98 117</div><div>SES 复制栈顶 | 103 103 98 0</div><div>SEE 弹出栈顶 | 103 98 0 | 弹出序列 98 117 103</div></div><div>注意到弹出序列98 117 103十进制ASCII转码后正好是bug，说明这种猜想可能是正确的。要得到弹出栈顶的数字序列，<span style="font-size: unset; color: unset; font-family: unset;">只需要把弹出栈顶操作SEE替换为输出字符操作TESS即可。跟踪代码会发现，整段代码中除了最终的结束语句EEE以外没有用到任何循环控制操作，即没有其他以E开头的语句。因此也不存在除SEE外的连续两个E，从而可以直接替换。如图，把SEE全部替换成TESS：</span></div><div><img src="Bugku Misc 23（113-116）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>最后运行得到flag：</div><div><img src="Bugku Misc 23（113-116）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：bugku{F1xAnE5olangPr0gr4mT0Cap7ureTh3F14g}</div><div><br/></div><div><span style="font-weight: bold;">116 流量里的二维码</span></div><div><br/></div><div>下载得到pcap格式文件。wireshark打开：</div><div><img src="Bugku Misc 23（113-116）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>观察规律，发现以下线索：</div><div>1、除开头的两个ARP协议数据包外，其余122个数据包均为ICMP协议，可以判断信息藏在ICMP协议中；</div><div>2、所有ICMP协议数据包中，data部分的后45字节是完全一致的，不可能携带隐藏信息；</div><div>3、所有ICMP协议数据包中，从172.17.0.2发往172.17.0.3的数据包，TTL均为64，反向的数据包则TTL每次均有差异。</div><div>尝试从172.17.0.3发往172.17.0.2的ICMP协议数据包的TTL中提取信息。注意到这样的数据包共有122/2=61个，而TTL的取值范围在0-255之间，若将其转为8位二进制数，则总共能得到61x8=488个二进制数字。根据题目提示，隐藏的信息为二维码，最低版本v1的二维码边长为21。由于21x21=441&lt;488，因此这其中理论上可以隐藏一张v1二维码图像。</div><div><br/></div><div>首先用tshark提取出从172.17.0.3发往172.17.0.2的ICMP协议数据包的TTL值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# tshark -r wireshark.pcap -Y &quot;icmp and ip.src == 172.17.0.3&quot; -T fields -e &quot;ip.ttl&quot; | xargs</div><div>Running as user &quot;root&quot; and group &quot;root&quot;. This could be dangerous.</div><div>1 196 5 244 87 212 92 81 81 77 69 69 181 21 245 183 208 21 64 127 239 255 4 106 173 217 64 216 83 124 235 128 165 29 45 239 253 173 80 18 56 223 112 163 69 61 229 20 60 116 82 59 223 74 199 1 112 47 255 255 240</div></div><div>注意到第一个TTL值为1，即0b00000001，其中七个0正好对应二维码左上角定位符部分的七像素黑色边。因此方向很可能是正确的，且二进制数0对应黑色，1对应白色。然后写脚本，把每个TTL值转八位二进制数并绘图。图像宽度未知，但至少为21且不超过23（否则24x21=504&gt;488，导致图像高度小于版本v1二维码的边长），最多尝试三次即可：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>s = '1 196 5 244 87 212 92 81 81 77 69 69 181 21 245 183 208 21 64 127 239 255 4 106 173 217 64 216 83 124 235 128 165 29 45 239 253 173 80 18 56 223 112 163 69 61 229 20 60 116 82 59 223 74 199 1 112 47 255 255 240'.split(' ')</div><div>data = ''</div><div>for i in s:</div><div>    data += bin(int(i))[2:].zfill(8)</div><div><br/></div><div>w = 22  # 调整至得到合适图像为止</div><div>h = len(data) // w + 1</div><div>img = Image.new('1', (w, h), 255)</div><div>for i in range(len(data)):</div><div>    x, y = i % w, i // w</div><div>    img.putpixel((x, y), int(data[i]) * 255)</div><div>img.save('C:/Users/Administrator/Desktop/1.png')</div></div><div>运行结果（已放大）：</div><div><img src="Bugku Misc 23（113-116）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div>扫码得到flag。</div><div><br/></div><div>flag：flag{ttleasy}</div></span>
</div></body></html> 