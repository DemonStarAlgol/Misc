<html>
<head>
  <title>Bugku Misc 27（129-132）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="8211"/>
<h1>Bugku Misc 27（129-132）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">129 disordered_zip</span></div><div><br/></div><div>下载得到zip格式文件。直接打开报错，十六进制编辑器打开：</div><div><img src="Bugku Misc 27（129-132）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>文件头被破坏了，补完为50 4B 03 04，再次打开，发现需要解压密码。回到十六进制编辑器，看一下文件尾：</div><div><img src="Bugku Misc 27（129-132）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>文件尾后有额外数据，显然是个PNG格式图片。再仔细看会发现PNG的IEND块也被破坏了，具体来说，仅保留到标识位IEND为止，后面的四位CRC校验位被删掉了。不过在Windows下都没有问题，无论CRC校验位错误还是IEND块没掉了，Windows图片查看器都会尽可能把PNG给渲染出来，实在是非常敬业。总之图长这样（已放大）：</div><div><img src="Bugku Misc 27（129-132）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>看起来像是个缺定位符的QR码，但是有个问题，块的大小和定位符的比例都不对。不管怎么样先补一下定位符试试：</div><div><img src="Bugku Misc 27（129-132）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>竟然能扫，就离谱：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>psw:yeQFPDS6uTaRasdvwLKoEZq0OiUk</div></div><div>用该密码解压之前的加密压缩包，提示密码不对，说明这段字符串必然还存在其他加密。考虑到前几层套娃的出题风格，我姑且先找了点常见的古典密码工具，把所有功能都试了一遍，结果发现了这个：</div><div><img src="Bugku Misc 27（129-132）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>passwd:vyweLQKFoPEDZSq60uOTiaURk</div></div><div>这passwd:分两组栅栏成psw:就很炫（此处为本意，没有说出题像某人的意思），颇有本格推理中叙述性诡计的意味。</div><div><br/></div><div>成功解压得到无扩展名的flag文件，用file命令得不到文件类型，丢十六进制编辑器里看下：</div><div><img src="Bugku Misc 27（129-132）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>开头三个00 00 00就很像是被出题人故意删掉了，那么考虑下开头字节是25的常见文件类型，很容易想到PDF文件的头部是25 50 44 46 2D，其中50 44 46正好对应PDF三个字母所以被删掉了。补完文件头后可以正常打开，但内容中找不到可疑之处，先尝试用支持PDF隐写的工具梭一把：</div><div><img src="Bugku Misc 27（129-132）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>得到了1.txt：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{ZnSRBg8vNJV5bXfUaxryetQjO4l}</div></div><div><br/></div><div>flag：flag{ZnSRBg8vNJV5bXfUaxryetQjO4l}</div><div><br/></div><div><span style="font-weight: bold;">130 再也没有纯白的灵魂</span></div><div><br/></div><div>下载得到txt格式文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>~呜嗷BBBUBGUUBUUKBBKGBGUBBKBKBKUUBUGBBBUGUKGUBUUKBUUGBGUBBUBKBKUBBKBBBBUGUKUUBUUKBKKGBGUBBBBKBKUUBKUBBBUUBBBUBUUKUGGGBGUBBBKKBKUUBGBBBBUUBBBUBUUKUGGGBGUBBBKKBKUUBKGBBBUGUGBUBUUGBUBGBGUBUKUKBKUUBUBBBBUGBBUUBUUKUUB啊</div></div><div>以“~呜嗷”开头，“啊”结尾，容易想到<a href="http://hi.pcmoe.net/roar.html">兽音译者</a>。且兽音译者的密文总共用到呜、嗷、啊和~四种字符，和本题密文中BUGK四种字符也能一一对应。猜测需要把字符反向替换后再通过兽音译者解密，那么关键就是找到对应关系。</div><div><br/></div><div>首先随便尝试加密几个字符串，可以发现，当字符串开头为ASCII可打印字符时，密文开头基本上都是“~呜嗷嗷嗷嗷”，因此B很可能对应嗷。剩下的不太好判断，那就爆破一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from itertools import permutations</div><div><br/></div><div>c = '~呜嗷BBBUBGUUBUUKBBKGBGUBBKBKBKUUBUGBBBUGUKGUBUUKBUUGBGUBBUBKBKUBBKBBBBUGUKUUBUUKBKKGBGUBBBBKBKUUBKUBBBUUBBBUBUUKUGGGBGUBBBKKBKUUBGBBBBUUBBBUBUUKUGGGBGUBBBKKBKUUBKGBBBUGUGBUBUUGBUBGBGUBUKUKBKUUBUBBBBUGBBUUBUUKUUB啊'</div><div>c = c.replace('B', '嗷')</div><div><br/></div><div>d = '呜啊~'</div><div>for i in permutations(list('UGK')):</div><div>    tmp = c</div><div>    for j in range(3):</div><div>        tmp = tmp.replace(i[j], d[j])</div><div>    print(tmp)</div></div><div>得到六段可能的密文：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>~呜嗷嗷嗷嗷呜嗷啊呜呜嗷呜呜~嗷嗷~啊嗷啊呜嗷嗷~嗷~嗷~呜呜嗷呜啊嗷嗷嗷呜啊呜~啊呜嗷呜呜~嗷呜呜啊嗷啊呜嗷嗷呜嗷~嗷~呜嗷嗷~嗷嗷嗷嗷呜啊呜~呜呜嗷呜呜~嗷~~啊嗷啊呜嗷嗷嗷嗷~嗷~呜呜嗷~呜嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜~呜啊啊啊嗷啊呜嗷嗷嗷~~嗷~呜呜嗷啊嗷嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜~呜啊啊啊嗷啊呜嗷嗷嗷~~嗷~呜呜嗷~啊嗷嗷嗷呜啊呜啊嗷呜嗷呜呜啊嗷呜嗷啊嗷啊呜嗷呜~呜~嗷~呜呜嗷呜嗷嗷嗷嗷呜啊嗷嗷呜呜嗷呜呜~呜呜嗷啊</div><div>~呜嗷嗷嗷嗷呜嗷~呜呜嗷呜呜啊嗷嗷啊~嗷~呜嗷嗷啊嗷啊嗷啊呜呜嗷呜~嗷嗷嗷呜~呜啊~呜嗷呜呜啊嗷呜呜~嗷~呜嗷嗷呜嗷啊嗷啊呜嗷嗷啊嗷嗷嗷嗷呜~呜啊呜呜嗷呜呜啊嗷啊啊~嗷~呜嗷嗷嗷嗷啊嗷啊呜呜嗷啊呜嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜啊呜~~~嗷~呜嗷嗷嗷啊啊嗷啊呜呜嗷~嗷嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜啊呜~~~嗷~呜嗷嗷嗷啊啊嗷啊呜呜嗷啊~嗷嗷嗷呜~呜~嗷呜嗷呜呜~嗷呜嗷~嗷~呜嗷呜啊呜啊嗷啊呜呜嗷呜嗷嗷嗷嗷呜~嗷嗷呜呜嗷呜呜啊呜呜嗷啊</div><div>~呜嗷嗷嗷嗷啊嗷呜啊啊嗷啊啊~嗷嗷~呜嗷呜啊嗷嗷~嗷~嗷~啊啊嗷啊呜嗷嗷嗷啊呜啊~呜啊嗷啊啊~嗷啊啊呜嗷呜啊嗷嗷啊嗷~嗷~啊嗷嗷~嗷嗷嗷嗷啊呜啊~啊啊嗷啊啊~嗷~~呜嗷呜啊嗷嗷嗷嗷~嗷~啊啊嗷~啊嗷嗷嗷啊啊嗷嗷嗷啊嗷啊啊~啊呜呜呜嗷呜啊嗷嗷嗷~~嗷~啊啊嗷呜嗷嗷嗷嗷啊啊嗷嗷嗷啊嗷啊啊~啊呜呜呜嗷呜啊嗷嗷嗷~~嗷~啊啊嗷~呜嗷嗷嗷啊呜啊呜嗷啊嗷啊啊呜嗷啊嗷呜嗷呜啊嗷啊~啊~嗷~啊啊嗷啊嗷嗷嗷嗷啊呜嗷嗷啊啊嗷啊啊~啊啊嗷啊</div><div>~呜嗷嗷嗷嗷~嗷呜~~嗷~~啊嗷嗷啊呜嗷呜~嗷嗷啊嗷啊嗷啊~~嗷~呜嗷嗷嗷~呜~啊呜~嗷~~啊嗷~~呜嗷呜~嗷嗷~嗷啊嗷啊~嗷嗷啊嗷嗷嗷嗷~呜~啊~~嗷~~啊嗷啊啊呜嗷呜~嗷嗷嗷嗷啊嗷啊~~嗷啊~嗷嗷嗷~~嗷嗷嗷~嗷~~啊~呜呜呜嗷呜~嗷嗷嗷啊啊嗷啊~~嗷呜嗷嗷嗷嗷~~嗷嗷嗷~嗷~~啊~呜呜呜嗷呜~嗷嗷嗷啊啊嗷啊~~嗷啊呜嗷嗷嗷~呜~呜嗷~嗷~~呜嗷~嗷呜嗷呜~嗷~啊~啊嗷啊~~嗷~嗷嗷嗷嗷~呜嗷嗷~~嗷~~啊~~嗷啊</div><div>~呜嗷嗷嗷嗷啊嗷~啊啊嗷啊啊呜嗷嗷呜~嗷~啊嗷嗷呜嗷呜嗷呜啊啊嗷啊~嗷嗷嗷啊~啊呜~啊嗷啊啊呜嗷啊啊~嗷~啊嗷嗷啊嗷呜嗷呜啊嗷嗷呜嗷嗷嗷嗷啊~啊呜啊啊嗷啊啊呜嗷呜呜~嗷~啊嗷嗷嗷嗷呜嗷呜啊啊嗷呜啊嗷嗷嗷啊啊嗷嗷嗷啊嗷啊啊呜啊~~~嗷~啊嗷嗷嗷呜呜嗷呜啊啊嗷~嗷嗷嗷嗷啊啊嗷嗷嗷啊嗷啊啊呜啊~~~嗷~啊嗷嗷嗷呜呜嗷呜啊啊嗷呜~嗷嗷嗷啊~啊~嗷啊嗷啊啊~嗷啊嗷~嗷~啊嗷啊呜啊呜嗷呜啊啊嗷啊嗷嗷嗷嗷啊~嗷嗷啊啊嗷啊啊呜啊啊嗷啊</div><div>~呜嗷嗷嗷嗷~嗷啊~~嗷~~呜嗷嗷呜啊嗷啊~嗷嗷呜嗷呜嗷呜~~嗷~啊嗷嗷嗷~啊~呜啊~嗷~~呜嗷~~啊嗷啊~嗷嗷~嗷呜嗷呜~嗷嗷呜嗷嗷嗷嗷~啊~呜~~嗷~~呜嗷呜呜啊嗷啊~嗷嗷嗷嗷呜嗷呜~~嗷呜~嗷嗷嗷~~嗷嗷嗷~嗷~~呜~啊啊啊嗷啊~嗷嗷嗷呜呜嗷呜~~嗷啊嗷嗷嗷嗷~~嗷嗷嗷~嗷~~呜~啊啊啊嗷啊~嗷嗷嗷呜呜嗷呜~~嗷呜啊嗷嗷嗷~啊~啊嗷~嗷~~啊嗷~嗷啊嗷啊~嗷~呜~呜嗷呜~~嗷~嗷嗷嗷嗷~啊嗷嗷~~嗷~~呜~~嗷啊</div></div><div><br/></div><div>然而每一段都无法正确解密，这是为什么呢。随便在Github上找一段<a href="https://github.com/SycAlright/beast_sdk/blob/main/Python/beast.py">兽音译者的源码</a>，可以发现兽音译者的加密过程是将明文的每个字节转为4位十六进制数字，再把每位十六进制数字转为2位密文，因此最终的密文长度（开头和结尾的“~呜嗷和“啊”不计）必然是8的倍数。但本题给出的密文长度为207，很显然，差了一位。</div><div><span style="font-size: unset; color: unset; font-family: unset;">为了找到缺失位，考虑反过来从flag格式入手，尝试几种可能的flag格式，发现明文为flag时，对应的兽音密文为：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>~呜嗷嗷嗷嗷呜啊嗷啊呜呜嗷呜呜~嗷嗷~啊嗷啊呜嗷嗷~嗷~嗷~呜呜嗷呜啊啊</div></div><div>对比一下之前得到的六段密文中的第一段：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>~呜嗷嗷嗷嗷呜<font color="#FF0000">啊</font>嗷啊呜呜嗷呜呜~嗷嗷~啊嗷啊呜嗷嗷~嗷~嗷~呜呜嗷呜啊<font color="#A8A8A8">啊</font></div><div>~呜嗷嗷嗷嗷呜嗷啊呜呜嗷呜呜~嗷嗷~啊嗷啊呜嗷嗷~嗷~嗷~呜呜嗷呜啊<font color="#A8A8A8">嗷嗷嗷呜啊呜~啊呜嗷呜呜~嗷呜呜啊嗷啊呜嗷嗷呜嗷~嗷~呜嗷嗷~嗷嗷嗷嗷呜啊呜~呜呜嗷呜呜~嗷~~啊嗷啊呜嗷嗷嗷嗷~嗷~呜呜嗷~呜嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜~呜啊啊啊嗷啊呜嗷嗷嗷~~嗷~呜呜嗷啊嗷嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜~呜啊啊啊嗷啊呜嗷嗷嗷~~嗷~呜呜嗷~啊嗷嗷嗷呜啊呜啊嗷呜嗷呜呜啊嗷呜嗷啊嗷啊呜嗷呜~呜~嗷~呜呜嗷呜嗷嗷嗷嗷呜啊嗷嗷呜呜嗷呜呜~呜呜嗷啊</font></div></div><div>很明显，这就是缺少的那一位。补完密文：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>~呜嗷嗷嗷嗷呜<font color="#FF0000">啊</font>嗷啊呜呜嗷呜呜~嗷嗷~啊嗷啊呜嗷嗷~嗷~嗷~呜呜嗷呜啊嗷嗷嗷呜啊呜~啊呜嗷呜呜~嗷呜呜啊嗷啊呜嗷嗷呜嗷~嗷~呜嗷嗷~嗷嗷嗷嗷呜啊呜~呜呜嗷呜呜~嗷~~啊嗷啊呜嗷嗷嗷嗷~嗷~呜呜嗷~呜嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜~呜啊啊啊嗷啊呜嗷嗷嗷~~嗷~呜呜嗷啊嗷嗷嗷嗷呜呜嗷嗷嗷呜嗷呜呜~呜啊啊啊嗷啊呜嗷嗷嗷~~嗷~呜呜嗷~啊嗷嗷嗷呜啊呜啊嗷呜嗷呜呜啊嗷呜嗷啊嗷啊呜嗷呜~呜~嗷~呜呜嗷呜嗷嗷嗷嗷呜啊嗷嗷呜呜嗷呜呜~呜呜嗷啊</div></div><div>在线解密：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{ni-zhen-shi-shou-ren}</div></div><div><br/></div><div>flag：flag{ni-zhen-shi-shou-ren}</div><div><br/></div><div><span style="font-weight: bold;">131 美丽的烟火</span></div><div><br/></div><div>下载得到zip格式文件。是个伪加密压缩包，ZipCenOp处理一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\暴力破解\ZipCenOp&gt;java -jar ZipCenOp.jar r 美丽的烟火.zip</div><div>success 2 flag(s) found</div></div><div>然后解压得到password.txt和firework.png，先看前者：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>am5QWDVwNVp0ZkRKdW14U3NFSw==</div></div><div>先base64后base58解码，得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>t_hp1ass_s1wsd</div></div><div>栅，就硬栅，这大概就是传说中的遇事不决栅一下出题法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>th1s_1s_passwd</div></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">再看</span><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">firework.png，十六进制编辑器打开，文件尾有额外字符串：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>stegpy:shumu</div></div><div>提示很清晰，那么就直接用stegpy来提取隐写信息：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;stegpy -p firework.png</div><div>Enter password (will not be echoed):<font color="#FF0000">这里输入密码</font></div><div>aZgs8ImPpQOzO3CVA/wIUVq/M7X8C33ptNZSW2Blenc=</div></div><div>尝试一下发现是ECB模式的AES加密：</div><div><img src="Bugku Misc 27（129-132）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{yX73nAutbBozYhge6d2flG}</div><div><br/></div><div><span style="font-weight: bold;">132 easy_python</span></div><div><br/></div><div>下载得到3个文件，其中flag.txt是题目说明：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Please analyze this game and calculation the lowest level to kill an enemy,then base64 encryption</div><div>flag:flag{your answer}</div><div>请你分析这个游戏，并计算出杀死敌人的最低等级，然后base64加密它</div><div>flag:flag{你的答案}</div></div><div>姑且先不管base64是编码不是加密这一点，其他两个文件，.level是用于记录当前等级的，game.py是游戏代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#coding=utf-8</div><div>import socket,threading</div><div>try:</div><div>    level=open('.level').read()</div><div>    level=int(level)</div><div>except:</div><div>    level=1</div><div>class user():</div><div>    HP=int(100+(4*level))</div><div>    Danger=int(10+(3*level))</div><div>    Defence=int(5+(1*level))</div><div>class npc():</div><div>    name='穿山甲'</div><div>    HP=(3**15)</div><div>    Danger=(3**10)</div><div>    Defence=100</div><div>print('面板\t血量\t攻击力\t防御力\t\n'),</div><div>print('玩家 %s\t%s\t%s\t\n'%(user.HP,user.Danger,user.Defence)),</div><div>print('怪物 %s\t%s\t%s\t\n'%(npc.HP,npc.Danger,npc.Defence)),</div><div>user.Danger=user.Danger-npc.Defence</div><div>npc.Danger=npc.Danger-user.Defence</div><div>if user.Danger &lt;=0:</div><div>    user.Danger=1</div><div>if npc.Danger &lt;=0:</div><div>    npc.Danger=1</div><div>print(&quot;开始战斗&quot;.center(41,'^'))</div><div>while 1:</div><div>    npc.HP=npc.HP-user.Danger</div><div>    print('你对%s造成了%s 怪物剩余血量 %s\t\n'%(npc.name,user.Danger,npc.HP))</div><div>    user.HP=user.HP-npc.Danger</div><div>    print('%s对你造成了%s 你剩余血量 %s\t\n'%(npc.name,npc.Danger,user.HP))</div><div>    if npc.HP&lt;=0 and user.HP&lt;=0:</div><div>        print('平局!!!')</div><div>        break</div><div>    if npc.HP &lt;=0:</div><div>        print('你赢了!!!,你剩余血量 %s\t\n'%(user.HP)),</div><div>        break</div><div>    if user.HP &lt;=0:</div><div>        print('你死了!!!%s剩余血量 %s\t\n'%(npc.name,npc.HP)),</div><div>        break</div><div>print((&quot;战斗结束 等级+1 您目前等级%s&quot;%(int(level)+1)).center(49,'^'))</div><div>open('.level','w').write(str(level+1))</div></div><div>简单看一下，玩家的属性与等级有关，且每次运行代码后无论输赢等级都会加1，并将等级存入.level文件中，下次运行时再从文件内读取等级。怪物的属性是固定的，双方按照一定规则战斗，一方血量归零时战斗结束。</div><div><br/></div><div>比较容易想到的思路是把等级作为未知变量，建立方程然后求解。不过注意到玩家的战斗力是随level单调递增的（也就是说，如果level X会输，level Y会赢，必有Y&gt;X），实现起来更简单的方法是二分法硬算：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from math import ceil</div><div>from base64 import b64encode</div><div><br/></div><div>def battle(level):</div><div>    HP = 4 * level + 100</div><div>    ATK = max(3 * level - 90, 1)</div><div>    M_ATK = max(3 ** 10 - level - 5, 1)</div><div>    return ceil(3 ** 15 / ATK) &lt; HP / M_ATK</div><div><br/></div><div>l = [0, 3 ** 10]  # 随便找一个能赢的等级，大一点也无所谓<br/></div><div>while True:</div><div>    if l[1] - l[0] == 1:</div><div>        res = b64encode(str(l[1]).encode())</div><div>        print(f'flag{{{res.decode()}}}')</div><div>        break</div><div>    elif battle(sum(l) // 2):</div><div>        l = [l[0], sum(l) // 2]</div><div>    else:</div><div>        l = [sum(l) // 2, l[1]]</div></div><div>运行得到flag。</div><div><br/></div><div>flag：flag{NTYzOTA=}</div></span>
</div></body></html> 