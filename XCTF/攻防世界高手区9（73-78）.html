<html>
<head>
  <title>攻防世界高手区9（73-78）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1095"/>
<h1>攻防世界高手区9（73-78）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">073 打开电动车</span></div><div>题目：截获了一台电动车的钥匙发射出的锁车信号，3分钟之内，我要获得它地址位的全部信息。flag内容二进制表示即可。</div><div><br/></div><div>下载得到sctf.wav，audacity打开：</div><div><img src="攻防世界高手区9（73-78）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>记录信号得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>0 011101001010101001100010</div></div><div><br/></div><div>PT2242信号：前面4bit表示同步码，中间的20bit表示地址码，后面的4bit表示功能码，最后一位是停止码。</div><div><img src="攻防世界高手区9（73-78）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>从而地址码部分是01110100101010100110。</div><div><br/></div><div>flag：sctf{01110100101010100110}</div><div><br/></div><div><span style="font-weight: bold;">074 latlong</span></div><div><br/></div><div>下载得到无后缀名文件，file命令判断是wav音频文件。重命名后audacity打开，波形和频谱均无可疑线索。选择“分析-频谱分析”：</div><div><img src="攻防世界高手区9（73-78）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>可以看到在1100Hz和2200Hz处各有一个峰，猜测是某种无线电通信中利用数字频率调制来传输数据的信号。</div><div><br/></div><div>同时找到原题的提示：Ax25 will lead you in the direction。</div><div>AX.25是国际业余无线电爱好者联盟为分组无线网制定的专门通信协议，可以用multimon-ng工具来解调信号。同时，为了直接解析wav格式的文件，需要安装另一个工具sox。在Kali中均可以直接通过apt-get install命令安装。</div><div><br/></div><div>安装完成后开始解调信号：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# multimon-ng -t wav -a AFSK1200 file.wav</div><div>multimon-ng 1.1.9</div><div>  (C) 1996/1997 by Tom Sailer HB9JNX/AE4WA</div><div>  (C) 2012-2020 by Elias Oenal</div><div>Available demodulators: POCSAG512 POCSAG1200 POCSAG2400 FLEX EAS UFSK1200 CLIPFSK FMSFSK AFSK1200 AFSK2400 AFSK2400_2 AFSK2400_3 HAPN4800 FSK9600 DTMF ZVEI1 ZVEI2 ZVEI3 DZVEI PZVEI EEA EIA CCIR MORSE_CW DUMPCSV X10 SCOPE</div><div>Enabled demodulators: AFSK1200</div><div>AFSK1200: fm WDPX01-0 to APRS-0 UI  pid=F0</div><div>!/;E'q/Sz'O   /A=000000flag{f4ils4f3c0mms}</div></div><div><br/></div><div>flag：flag{f4ils4f3c0mms}</div><div><br/></div><div><span style="font-weight: bold;">075 test.pyc</span></div><div><br/></div><div>下载得到pyc文件，总之先反编译。uncompyle6一直报错。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;uncompyle6 -o 1.py test.pyc</div><div><br/></div><div># file test.pyc</div><div># --- This code section failed: ---</div><div><br/></div><div>L.   1         0  LOAD_CONST               '=cWbihGfyMzNllzZ'</div><div>                3  NOP</div><div>                4  NOP</div><div>                5  NOP</div><div>                6  LOAD_CONST               '0cjZzMW'</div><div>                9  LOAD_CONST               'N5cTM4Y'</div><div>               12  LOAD_CONST               'jYygTOy'</div><div>               15  LOAD_CONST               'cmNycWNyYmM1Ujf'</div><div>               18  BINARY_ADD</div><div>               19  STORE_NAME            0  'str'</div><div><br/></div><div>L.   2        22  LOAD_CONST               -1</div><div>               25  LOAD_CONST               None</div><div>               28  IMPORT_NAME           1  'base64'</div><div>               31  STORE_NAME            1  'base64'</div><div><br/></div><div>L.   5        34  LOAD_CODE                &lt;code_object flag1&gt;</div><div>               37  MAKE_FUNCTION_0       0  None</div><div>               40  STORE_NAME            2  'flag1'</div><div><br/></div><div>L.  13        43  LOAD_CODE                &lt;code_object flag2&gt;</div><div>               46  MAKE_FUNCTION_0       0  None</div><div>               49  STORE_NAME            3  'flag2'</div><div><br/></div><div>L.  21        52  LOAD_CODE                &lt;code_object flag3&gt;</div><div>               55  MAKE_FUNCTION_0       0  None</div><div>               58  STORE_NAME            4  'flag3'</div><div><br/></div><div>L.  30        61  LOAD_NAME             2  'flag1'</div><div>               64  CALL_FUNCTION_0       0  None</div><div>               67  POP_TOP</div><div><br/></div><div>Parse error at or near `None' instruction at offset -1</div><div><br/></div><div>test.pyc --</div><div># decompile failed</div></div><div>可以看到有一些固定的字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>'=cWbihGfyMzNllzZ' '0cjZzMW' 'N5cTM4Y' 'jYygTOy' 'cmNycWNyYmM1Ujf'</div></div><div>猜测是个反过来的base64密文，倒一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fjU1MmYyNWcyNmcyOTgyYjY4MTc5NWMzZjc0ZzllNzMyfGhibWc=</div></div><div>解密：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>~552f25g26g2982b681795c3f74g9e732|hbmg</div></div><div>hbmg往前移一位就是galf，猜测要倒过来再凯撒移位。再根据|和~的ASCII码与{}也正好差1，因此是广义的ASCII凯撒移位：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>a = '~552f25g26g2982b681795c3f74g9e732|hbmg'</div><div>a = a[::-1]</div><div>for i in a:</div><div>    print(chr(ord(i) - 1), end = '')</div></div><div><br/></div><div>flag：flag{126d8f36e2b486075a1781f51f41e144}</div><div><br/></div><div><span style="font-weight: bold;">076 Avatar</span></div><div><br/></div><div>下载得到jpg文件。能用的隐写工具全试了一遍最后发现是outguess。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# outguess -r 035bfaa85410429495786d8ea6ecd296.jpg -t flag.txt</div><div>Reading 035bfaa85410429495786d8ea6ecd296.jpg....</div><div>Extracting usable bits:   28734 bits</div><div>Steg retrieve: seed: 94, len: 41</div><div>root@kali:~/Desktop# cat flag.txt</div><div>We should blow up the bridge at midnight</div></div><div><br/></div><div>flag：We should blow up the bridge at midnight</div><div><br/></div><div><span style="font-weight: bold;">077 Hidden-Message</span></div><div><br/></div><div>下载得到pcap文件，wireshark打开。</div><div><img src="攻防世界高手区9（73-78）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>全都是UDP流，追踪流也没有有效信息。继续观察其他内容。</div><div>注意到数据包的总数是80，再看到这一列的端口号其实一直在变。</div><div><img src="攻防世界高手区9（73-78）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>将这一列的1和0记录下来，发现每8位开头都是1。将1和0互换，<span style="font-size: unset; color: unset; font-family: unset;">并每8位一组二进制ASCII转码，得到flag。</span></div><div><br/></div><div>也可以用tshark输出UDP协议端口号后，配合管道符和Linux命令行得到每个端口号的最后一位：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# tshark -r 8868f595665740159650d6e654aadc93.pcap -Tfields -e udp.srcport | while read port; do echo -n ${port: -1}; done</div><div>Running as user &quot;root&quot; and group &quot;root&quot;. This could be dangerous.</div><div>10110111100110101001011010001100100110101001000110011101100110101000110110011000</div></div><div>之后同样互换0和1并二进制ASCII转码即可。</div><div><br/></div><div>flag：Heisenberg</div><div><br/></div><div><span style="font-weight: bold;">078 red_green</span></div><div><br/></div><div>下载得到png图片。</div><div><img src="攻防世界高手区9（73-78）_files/2ec5da20345342909d2336aa7418afed.png" type="image/png" data-filename="2ec5da20345342909d2336aa7418afed.png"/></div><div>全部由红绿色点组成，容易想到两种颜色分别表示0和1。先写个python脚本提取信息：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/1.png')</div><div>h = 780</div><div>w = 1024</div><div><br/></div><div>j = 0</div><div>res = ''</div><div><br/></div><div>for i in range(w * h):</div><div>    x = i % w # 横坐标</div><div>    y = i // w # 纵坐标</div><div>    color = img.getpixel((x, y))</div><div>    if color == (255, 0, 0): # 红色</div><div>        res += '1'</div><div>    elif color == (0, 255, 0): # 绿色</div><div>        res += '0'</div><div>    j += 1</div><div>    if j == 8: # 每8位转一次十六进制</div><div>        h = hex(int(res, 2))</div><div>        if len(h) == 3:</div><div>            print('0' + h[2:], end = '')</div><div>        elif len(h) == 4:</div><div>            print(h[2:], end = '')</div><div>        j = 0</div><div>        res = ''</div></div><div><br/></div><div>红0绿1的运行结果，开头为0027001f；红1绿0的运行结果，开头为ffd8ffe0，是jpeg文件头。显然选后者。将运行结果在十六进制编辑器保存为jpg格式文件得到：</div><div><img src="攻防世界高手区9（73-78）_files/1.jpg" type="image/jpeg" data-filename="1.jpg"/></div><div><br/></div><div>此外本题还有较为取巧的方法，Stegsolve打开原png图片后用Data Extract功能，选择Red的0位：</div><div><img src="攻防世界高手区9（73-78）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>同样可以直接得到jpg文件。</div><div><br/></div><div>flag：flag{134699ac9d6ac98b}</div><div><br/></div></span>
</div></body></html> 