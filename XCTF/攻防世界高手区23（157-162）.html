<html>
<head>
  <title>攻防世界高手区23（157-162）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="10475"/>
<h1>攻防世界高手区23（157-162）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><div><span style="font-weight: bold;">157 tunnel</span></div><div><br/></div><div>下载得到pcap格式文件，wireshark打开，统计-协议分级：</div><div><img src="攻防世界高手区23（157-162）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>按分组百分比来看，DNS协议异常地多。尝试过滤一下DNS协议的数据包：</div><div><img src="攻防世界高手区23（157-162）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>可以看到，192.168.1.103向DNS服务器8.8.8.8请求了很多个XXX.evil.im的URL请求，其中的子域名每次都是一段不同的类似base64编码的内容。手动解码前几个看一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>UEsDBDMAAwBjAJ12k1KDFWibyjR</div><div>50 4b 03 04 33 00 03 00 63 00 9d 76 93 52 83 15 68 9b ca 34</div><div>AAAYNgAACAALAGZsYWcuas</div><div>00 00 18 36 00 00 08 00 0b 00 66 6c 61 67 2e 6a</div><div>                               f  l  a  g  .  j</div></div><div>很明显是个zip格式压缩包。但另一方面比较吊诡的事情在于，如果把解码出来的东西编码回去：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>50 4b 03 04 33 00 03 00 63 00 9d 76 93 52 83 15 68 9b ca 34</div><div>UEsDBDMAAwBjAJ12k1KDFWibyjQ=</div></div><div>可能会得到一个末尾字符略有不同的base64编码字符串，说明其中大概还存在base64隐写。</div><div><br/></div><div>那么总之先把所有的base64编码提取出来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# tshark -r tunnel.pcap -Y &quot;dns and dns.qry.type == 1 and ip.src == 192.168.1.103&quot; -T fields -e dns.qry.name | grep &quot;evil.im&quot; | sed &quot;s/\.evil\.im$//&quot; &gt; 1.txt</div></div><div>然后在Python中处理解码和base64隐写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from base64 import b64decode</div><div>from string import *</div><div>import re</div><div><br/></div><div>b64table = ascii_uppercase + ascii_lowercase + digits + '/+'</div><div>f = open('C:/Users/Administrator/Desktop/1.txt', 'r').read().split('\n')[:-1]</div><div>z = open('C:/Users/Administrator/Desktop/1.zip', 'ab')</div><div>m = ''</div><div><br/></div><div>for i in f:</div><div>    if len(i) % 4 == 0:</div><div>        z.write(b64decode(i.encode()))</div><div>    elif len(i) % 4 == 2:</div><div>        z.write(b64decode((i + '==').encode()))</div><div>        m += bin(b64table.index(i[-1]))[2:].zfill(6)[-4:]</div><div>    elif len(i) % 4 == 3:</div><div>        z.write(b64decode((i + '=').encode()))</div><div>        m += bin(b64table.index(i[-1]))[2:].zfill(6)[-2:]</div><div><br/></div><div>print(''.join([chr(int(i, 2)) for i in re.findall(r'.{8}', m)]))</div></div><div>运行得到一个包含加密的flag.jpg的压缩包和一段输出：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>password: B@%MG&quot;6FjbS8^c#r</div></div><div>然后解压得到图像：</div><div><img src="攻防世界高手区23（157-162）_files/flag.jpg" type="image/jpeg" data-filename="flag.jpg"/></div><div><br/></div><div>flag：flag{D01n't_5pY_0nmE}</div><div><br/></div><hr/><div>（可能是）8月3日更新的一批题目。</div><hr/><div><br/></div><div><span style="font-weight: bold;">158 流量分析2</span></div><div><br/></div><div>下载得到pcapng格式文件，wireshark打开，追踪TCP流，依次查看，在流2找到可疑内容：</div><div><img src="攻防世界高手区23（157-162）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>继续查看，流2到流12均为HTTP流，且Line-based text均包含1-2个字符（流13实际上也是，但它包含的字符是单个换行符\n）。将其提取：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# tshark -r test.pcapng -Y &quot;http and ip.dst == 192.168.43.109&quot; -T fields -e http.file_data | xargs | sed 's/ //g'</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>fl{17uaji1l}n</div></div><div>补完格式得到flag。</div><div><br/></div><div>flag：flag{17uaji1l}</div><div><br/></div><div><span style="font-weight: bold;">159 流量分析1</span></div><div><br/></div><div>下载得到pcapng格式文件，wireshark打开，能看到大量HTTP协议数据包，先导出HTTP对象：</div><div><img src="攻防世界高手区23（157-162）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>任选一条出来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>http://39.105.136.196:30025/index.php?url=gopher://127.0.0.1:80/_POST%20%2Fadmin.php%20HTTP%2F1.1%250d%250aHost%3A%20localhost%3A80%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2Fx-www-form-urlencoded%250d%250aContent-Length%3A%2078%250d%250a%250d%250aid%253D1%2529%2520and%2520if%2528%2528ascii%2528substr%2528%2528select%2520flag%2520from%2520flag%2529%252C1%252C1%2529%2529%253D%252740%2527%2529%252Csleep%25283%2529%252C0%2529%2520--%2520</div></div><div>URL解码两次：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>http://39.105.136.196:30025/index.php?url=gopher://127.0.0.1:80/_POST /admin.php HTTP/1.1</div><div>Host: localhost:80</div><div>Connection: close</div><div>Content-Type: application/x-www-form-urlencoded</div><div>Content-Length: 78</div><div><br/></div><div>id=1) and if((ascii(substr((select flag from flag),1,1))='40'),sleep(3),0) --</div></div><div>很明显是在进行时间盲注。</div></div><div><br/></div><div>先用tshark提取出所有进行注入的payload：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>tshark -r challenge.pcapng -Y &quot;http and ip.dst == 192.168.43.109&quot; -T fields -e http.response_for.uri &gt; 1.txt</div></div><div>然后写个脚本处理每一行，虽然是时间盲注，但实际上不需要判断请求之间间隔的时间。因为从payload来看采用的是简单穷举法，那么对于每一位，只需要提取其穷举过程中该位尝试的最后一个值即可：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from urllib.parse import unquote</div><div><br/></div><div>data = open('C:/Users/Administrator/Desktop/1.txt', 'r').read().split('\n')</div><div>data = [unquote(unquote(i)) for i in data if 'gopher' in i]</div><div><br/></div><div>flag, index = '', 1</div><div>for i in data:</div><div>    n = int(i.split('flag),')[1].split(',')[0])</div><div>    if n != index:</div><div>        flag += chr(c)</div><div>        index = n</div><div>    c = int(i.split('\'')[1])</div><div>flag += chr(c)</div><div>print(flag)</div></div><div><br/></div><div>flag：flag{1qwy2781}</div><div><br/></div><div><span style="font-weight: bold;">160 抓住个黑客</span></div><div>题目：我们的入侵检测系统抓到了一个潜入公司内网的黑客，这家伙貌似是个新手，只会用MSF的默认参数。在我们的逼问之下，这家伙说他只黑了一台公司老旧的Win7主机，这家伙也说出了他搞事情时候的私钥。机智的你，能不能帮我们看看他到底干了什么？</div><div><br/></div><div>下载得到meterpreter.pcapng和key.pem，查看一下发现后者是私钥。根据提示MSF和文件名meterpreter，猜测是meterpreter流量。找到一篇<a href="https://blog.sparta-en.org/2021/10/10/Meterpreter%E9%80%9A%E8%AE%AF%E5%88%86%E6%9E%90/">Meterpreter通讯分析</a>，得到meterpreter数据包的结构：</div><div>1、首先是4字节的异或密钥，对后续所有数据进行了按位异或加密；</div><div>2、然后是16字节的 session GUID，4字节的enc_flags，4字节的payload_length。4字节的packet_type；</div><div>3、以上32字节共同组成Packet Header，剩下的部分全部为Payload；</div><div>4、若enc_flags为1，则后续为16字节的iv（用于CBC模式AES加密），再跟payload数据，否则直接接payload数据；</div><div>5、payload数据由TLV单元组成，每个单元包括4字节长度位、4字节类型位和数据部分。</div><div>一次meterpreter通信过程如下：</div><div>1、LHOST 生成 RSA 密钥对发给 RHOST；</div><div>2、RHOST 生成 AES 密钥，RSA 加密后发回给LHOST；</div><div>3、开始通信。</div><div><br/></div><div>由于RSA私钥已经给出，可以确定分析思路为：先找到RSA密钥，然后根据meterpreter数据包结构依次解密和分析数据包内容。追踪TCP流，可以判断流24为攻击流量：</div><div><img src="攻防世界高手区23（157-162）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>其中蓝色为攻击者发送流量，红色为服务器返回流量。那么服务器返回AES密钥所在 数据段为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>2926993adf8c06b90319d8059f51ec99b401f9b42926993a292698b52926993b2926991c2927993b4a49eb5f7648fc5d4652f05b5d43c64e4550c65f4745eb435952f0554726993a290f993b2924ac0e181fac0f1110a90d1f10ab031e13ac081b16aa0f1a16a0031813af0a1f15993a2926953a2b24be3a2926983a2927913a2d24b039ec75e27c93f3e0167fb28dd2c98ea0fd2ff42887d961f4e205a619311cf4b8dd93f189d24b8eb45af277bc76cc0ea8d5a0b3332812e6c8f73cced9f1d32189311dc13c30b80ebf944228979fd974a6ce23aacf386ebb5dbc1ac414a49678e6425944edf4a56f263a9c9e2a80e4d1884b35fc8da6e68bff64d33265350bf3e2b72dc5b0f0580cc12925074fc5505c9cd250b279150b9701cf5b2666ae9d0a0722f8b72aed8ffaa51f43594ebebe13b5bcb75e8a33c8cd396445c0c9da3d5a5b862bde38f62d13afd5387a62abce70e3d4192e3e96996ceaa0d1b0c7796028bdeabfbd8eddd13576f23135e1e7b06a0057a4b07bc786394ba1cd691547fad5db3a2926953a2b269d3a2926993a2926813a2d27542832d93a2fb12d08349729256baeb187</div></div><div>后续各行分别为攻击者和服务器的往返流量。</div><div><br/></div><div>写个脚本来解密各段流量，首先是解密函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from Crypto.PublicKey import RSA</div><div>from Crypto.Cipher import PKCS1_v1_5, AES</div><div>from itertools import cycle</div><div><br/></div><div>def decrypt(data: str, key: bytes=None):</div><div>    d = bytes.fromhex(data)</div><div>    xor_key = d[:4]</div><div>    d = bytes([i ^ j for i, j in zip(cycle(xor_key), d[4:])])</div><div><br/></div><div>    res = {}</div><div>    res['xor_key'] = xor_key</div><div>    res['guid'] = d[: 16]</div><div>    res['enc_flags'] = int.from_bytes(d[16: 20], 'big')</div><div>    res['pkt_length'] = int.from_bytes(d[20: 24], 'big')</div><div>    res['pkt_type'] = int.from_bytes(d[24: 28], 'big')</div><div>    res['tlvs'] = []</div><div><br/></div><div>    if res['enc_flags'] == 0:</div><div>        d = d[28: 28 + res['pkt_length']]</div><div>        while len(d) &gt; 0:</div><div>            tlv_len = int.from_bytes(d[: 4], 'big')</div><div>            tlv_type = int.from_bytes(d[4: 8], 'big')</div><div>            tlv_content = d[8: tlv_len]</div><div>            d = d[tlv_len: ]</div><div>            res['tlvs'].append([tlv_len, tlv_type, tlv_content])</div><div>    elif res['enc_flags'] == 1 and key:</div><div>        res['iv'] = d[: 16]</div><div>        aes = AES.new(key, mode=AES.MODE_CBC, iv=iv)</div><div>        d = aes.decrypt(d[48: ])</div><div>        while len(d) &gt; 0:</div><div>            tlv_len = int.from_bytes(d[: 4], 'big')</div><div>            tlv_type = int.from_bytes(d[4: 8], 'big')</div><div>            tlv_content = d[8: tlv_len]</div><div>            d = d[tlv_len:]</div><div>            res['tlvs'].append([tlv_len, tlv_type, tlv_content])</div><div><br/></div><div>    return res</div></div><div>然后把流24中从 2926993a 开始的各行以原始数据形式保存为文本文件，读取第一行解密AES密钥：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>datas = open('C:/Users/Administrator/Desktop/datas.txt', 'r').read().split('\n')</div><div>aes_data = decrypt(datas[0])</div><div>aes_key = aes_data['tlvs'][3][2]</div><div><br/></div><div>rsa_key = RSA.importKey(open('C:/Users/Administrator/Desktop/key.pem', 'rb').read())</div><div>rsa = PKCS1_v1_5.new(rsa_key)</div><div>aes_key = rsa.decrypt(aes_key, sentinel=None)</div></div><div>最后依次解密后续数据段：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for i in range(1, len(datas)):</div><div>    try:</div><div>        print(decrypt(datas[i], aes_key)['tlvs'])</div><div>    except:</div><div>        pass</div></div><div>在结果中搜索flag即可。</div><div><br/></div><div>flag：flag{Meterpreter_Has_A_Greater_Enc_Method_Than_Shell}</div><div><br/></div><div><span style="font-weight: bold;">161 running</span></div><div><br/></div><div>下载附件得到run.exe，看一下属性：</div><div><img src="攻防世界高手区23（157-162）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>解压得到New Microsoft Word Document.docx和run.exe两个文件，前者没有有效内容。后者继续运行一次得到tif文件，明显是个tiff格式图像。加上后缀后用Photoshop打开，可以看到两个图层：</div><div><img src="攻防世界高手区23（157-162）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>将矩形1改为不显示，在图层0看到了一段文字：</div><div><img src="攻防世界高手区23（157-162）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>另一方面，IDA打开run.exe（解压出来的那一个），F5切换伪代码，可以找到在生成tif文件的代码后还给出了一段字符串：</div><div><img src="攻防世界高手区23（157-162）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>结合以上两条线索，写脚本得到flag：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from itertools import cycle</div><div><br/></div><div>s = b'njCp1HJBPLVTxcMhUHDPwE7mPW'</div><div>print(bytes([i + j for i, j in zip(s, cycle([-1, 1]))]).decode())</div></div><div><br/></div><div>flag：flag{mkBq0IICOMUUwdLiTICQvF6nOX}</div><div><br/></div><div><b>162 pcap1</b></div><div><br/></div><div>下载得到pcap格式文件，wireshark打开，追踪TCP流，在流4发现一段Python代码：</div><div><img src="攻防世界高手区23（157-162）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>内容为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import string</div><div>import random</div><div>from base64 import b64encode, b64decode</div><div><br/></div><div>FLAG = 'flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}'<br/></div><div><br/></div><div>enc_ciphers = ['rot13', 'b64e', 'caesar']</div><div># dec_ciphers = ['rot13', 'b64d', 'caesard']</div><div><br/></div><div>def rot13(s):</div><div>    _rot13 = string.maketrans(</div><div>        &quot;ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz&quot;,</div><div>        &quot;NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm&quot;)</div><div>    return string.translate(s, _rot13)</div><div><br/></div><div>def b64e(s):</div><div>    return b64encode(s)</div><div><br/></div><div>def caesar(plaintext, shift=3):</div><div>    alphabet = string.ascii_lowercase</div><div>    shifted_alphabet = alphabet[shift:] + alphabet[:shift]</div><div>    table = string.maketrans(alphabet, shifted_alphabet)</div><div>    return plaintext.translate(table)</div><div><br/></div><div>def encode(pt, cnt=50):</div><div>    tmp = '2{}'.format(b64encode(pt))</div><div>    for cnt in xrange(cnt):</div><div>        c = random.choice(enc_ciphers)</div><div>        i = enc_ciphers.index(c) + 1</div><div>        _tmp = globals()[c](tmp)</div><div>        tmp = '{}{}'.format(i, _tmp)</div><div><br/></div><div>    return tmp</div><div><br/></div><div>if __name__ == '__main__':</div><div>    print encode(FLAG, cnt=?)</div></div><div>同时给出了密文。分析一下加密流程，使用了三种加密/编码，分别为ROT13、（移位为3的）凯撒密码，以及base64。每次循环随机一种，并把加密/编码方式的序号附在密文之前。</div><div><br/></div><div>写出解密脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from string import *</div><div>from base64 import *</div><div><br/></div><div>def rot13(s):</div><div>    _rot13 = str.maketrans(</div><div>        &quot;ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz&quot;,</div><div>        &quot;NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm&quot;)</div><div>    return s.translate(_rot13)</div><div><br/></div><div>def b64d(s):</div><div>    return b64decode(s.encode()).decode()</div><div><br/></div><div>def caesar(s):</div><div>    shifted_alphabet = ascii_lowercase[3: ] + ascii_lowercase[: 3]</div><div>    table = str.maketrans(shifted_alphabet, ascii_lowercase)</div><div>    return s.translate(table)</div><div><br/></div><div>def decrypt(s):</div><div>    n, s = int(s[0]) - 1, s[1: ]</div><div>    return [rot13, b64d, caesar][n](s)</div><div><br/></div><div>s = '略'</div><div>while s[0] in '123':</div><div>    s = decrypt(s)</div><div>print(s)</div></div><div>运行得到flag。</div><div><br/></div><div>flag：flag{li0ns_and_tig3rs_4nd_b34rs_0h_mi}</div></span>
</div></body></html> 