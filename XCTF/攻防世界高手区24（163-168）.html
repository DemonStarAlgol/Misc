<html>
<head>
  <title>攻防世界高手区24（163-168）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="10781"/>
<h1>攻防世界高手区24（163-168）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">163 misc2-1</span></div><div><br/></div><div>下载得到jpg格式文件，直接打开报错，十六进制编辑器查看：</div><div><img src="攻防世界高手区24（163-168）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>从文件头可以很明显看出来，每四个字节被倒序了，例如 FF D8 FF E1 被倒序成了 E1 FF D8 FF。</div><div><br/></div><div>写个脚本把字节顺序修复：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>d = open('C:/Users/Administrator/Desktop/task_flag.jpg', 'rb').read()</div><div>with open('C:/Users/Administrator/Desktop/1.jpg', 'wb') as f:</div><div>    f.write(b''.join([d[i: i+4][::-1] for i in range(0, len(d), 4)]))</div></div><div>运行得到修复后的图片，从而得到flag。</div><div><br/></div><div>flag：flag{F098996689560BBB1B566EBC10D5E564}</div><div><br/></div><div><span style="font-weight: bold;">164 EASY_EVM</span></div><div><br/></div><div>下载附件得到info.txt：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pragma solidity ^0.5.0;</div><div><br/></div><div>ABI:</div><div>[</div><div>    {</div><div>        &quot;inputs&quot;: [],</div><div>        &quot;payable&quot;: true,</div><div>        &quot;stateMutability&quot;: &quot;payable&quot;,</div><div>        &quot;type&quot;: &quot;constructor&quot;</div><div>    },</div><div>    {</div><div>        &quot;constant&quot;: true,</div><div>        &quot;inputs&quot;: [</div><div>            {</div><div>                &quot;internalType&quot;: &quot;string&quot;,</div><div>                &quot;name&quot;: &quot;source&quot;,</div><div>                &quot;type&quot;: &quot;string&quot;</div><div>            }</div><div>        ],</div><div>        &quot;name&quot;: &quot;Convert&quot;,</div><div>        &quot;outputs&quot;: [</div><div>            {</div><div>                &quot;internalType&quot;: &quot;uint256&quot;,</div><div>                &quot;name&quot;: &quot;result&quot;,</div><div>                &quot;type&quot;: &quot;uint256&quot;</div><div>            }</div><div>        ],</div><div>        &quot;payable&quot;: false,</div><div>        &quot;stateMutability&quot;: &quot;pure&quot;,</div><div>        &quot;type&quot;: &quot;function&quot;</div><div>    },</div><div>    {</div><div>        &quot;constant&quot;: true,</div><div>        &quot;inputs&quot;: [],</div><div>        &quot;name&quot;: &quot;GetFlag&quot;,</div><div>        &quot;outputs&quot;: [</div><div>            {</div><div>                &quot;internalType&quot;: &quot;string&quot;,</div><div>                &quot;name&quot;: &quot;flag&quot;,</div><div>                &quot;type&quot;: &quot;string&quot;</div><div>            }</div><div>        ],</div><div>        &quot;payable&quot;: false,</div><div>        &quot;stateMutability&quot;: &quot;view&quot;,</div><div>        &quot;type&quot;: &quot;func tion&quot;</div><div>    },</div><div>    {</div><div>        &quot;constant&quot;: true,</div><div>        &quot;inputs&quot;: [],</div><div>        &quot;name&quot;: &quot;Require&quot;,</div><div>        &quot;outputs&quot;: [],</div><div>        &quot;payable&quot;: false,</div><div>        &quot;stateMutability&quot;: &quot;view&quot;,</div><div>        &quot;type&quot;: &quot;function&quot;</div><div>    }</div><div>]</div><div><br/></div><div>Bytecode:</div><div>6080604052693100e35e552c1273c953600181905550691ac3243c9e81ba850045600281905550695ce6a91010e307946b8760038190555061030f806100466000396000f3fe608060405234801561001057600080fd5b24506004361060415760003560e01c80638906899514610046578063907e178b146100c9578063b357e2cd14610198575b600080fd5b61004e6101a2565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561008e578082015181840152602081019050610073565b50505050905090810190601f1680156100bb5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b610182600480360360208110156100df57600080fd5b81019080803590602001906401000000008111156100fc57600080fd5b82018360208201111561010e57600080fd5b8035906020019184600183028401116401000000008311171561013057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505091929192905050506101ac565b6040518082815260200191505060405180910390f35b6101a06101cd565b005b6060600054905090565b600080602083015190506101008160001c816101c457fe5b04915050919050565b600061027260008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156102685780601f1061023d57610100808354040283529160200191610268565b820191906000526020600020905b81548152906001019060200180831161024b57829003601f168201915b50505050506101ac565b905069291012e74c77fb9b1133600154828161028a57fe5b061461029557600080fd5b690c9158ba60d3e58402f560025482816102ab57fe5b06146102b657600080fd5b69208474a0eb40ca8d322560035482816102cc57fe5b06146102d757600080fd5b5056fea265627a7a7231582076bf9599d7c1db3c967349730ba966ea19a3c19a82c194cf481bf5dd993fec0d64736f6c63430005110032</div></div><div>这是一个以太坊智能合约（EVM）虚拟机的 Bytecode，那么考察的就是EVM逆向。不会做，告辞。</div><div><br/></div><div>查了一下WP，Bytecode 被修改过使其无法反编译，需要修复或者直接看opcode。WP给出的源码长这样：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pragma solidity ^0.5.0;</div><div><br/></div><div>contract EASY_EVM_CRYPTO{</div><div>    </div><div>    // flag = &quot;flag{An_E4sy_EVM_y0u_sO1ve_it!}&quot;</div><div>    string private FLAG;</div><div>    uint private x;</div><div>    uint private y;</div><div>    uint private z;</div><div>    </div><div>    // flag = 0x666c61677b416e5f453473795f45564d5f7930755f734f3176655f6974217d</div><div>    constructor() public payable {</div><div>        x = 231412341286754812414291;</div><div>        y = 126381254785148123414597;</div><div>        z = 438712649816519864511367;</div><div>    }</div><div>    </div><div>    function GetFlag() public view returns (string memory flag) {</div><div>        assembly {</div><div>            flag := sload(0)</div><div>        }</div><div>    }</div><div>    </div><div>    function Convert(string memory source) public pure returns (uint result) {</div><div>        bytes32 tmp;</div><div>        assembly {</div><div>            tmp := mload(add(source, 32))</div><div>        }</div><div>        result = uint(tmp) / 0x100;</div><div>    }</div><div>    </div><div>    function Require() public view {</div><div>        uint tmp = Convert(FLAG);</div><div>        require(tmp%x == 193913535844325315514675);</div><div>        require(tmp%y == 59349569214207838388981);</div><div>        require(tmp%z == 153559101645126489682469);</div><div>    }</div><div>}</div></div><div>那么这实际上是一个求解同余方程组的数论问题。</div><div><br/></div><div>试着把数论部分做一下，sage脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from Crypto.Util.number import *</div><div><br/></div><div>x = 231412341286754812414291</div><div>y = 126381254785148123414597</div><div>z = 438712649816519864511367</div><div><br/></div><div>rx = 193913535844325315514675</div><div>ry = 59349569214207838388981</div><div>rz = 153559101645126489682469</div><div><br/></div><div>m = crt([rx, ry, rz], [x, y, z])</div><div>while b'flag' not in long_to_bytes(m):</div><div>    m += x * y * z</div><div>print(long_to_bytes(m))</div></div><div><br/></div><div>flag：flag{An_E4sy_EVM_y0u_sO1ve_it!}</div><div><br/></div><div><span style="font-weight: bold;">165 Let_god_knows</span></div><div><br/></div><div>下载得到bmp格式文件，Stegsolve打开，切换到Red Plane 0：</div><div><img src="攻防世界高手区24（163-168）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>使用显微镜仔细查看屏幕，平均来说看个一年左右之后可以发现画红圈的部分有个反色QR码。</div><div><br/></div><div>把这一个Plane保存出来，然后截取这个QR码再反色放大：</div><div><img src="攻防世界高手区24（163-168）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>扫码得到flag。</div><div><br/></div><div>flag：flag{Ok@y!G0d_know5_n0w}</div><div><br/></div><div><span style="font-weight: bold;">166 你猜他是什么文件</span></div><div><br/></div><div>下载得到png格式文件，直接打开报错，十六进制编辑器查看：</div><div><img src="攻防世界高手区24（163-168）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>文件头部有8字节被删了，但从后面的字节里暂时也没看到特征性的部分。</div><div><br/></div><div>尝试搜索紧接着文件头的部分字节，搜索到 21 04 00 00 01 0F 时得到了结果：</div><div><img src="攻防世界高手区24（163-168）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>比对一下<a href="https://www.rarlab.com/technote.htm">RAR5.0格式文档</a>，搜索的这6个字节刚好是Archive encryption header的一部分：</div><div><img src="攻防世界高手区24（163-168）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>对于加密的RAR5.0压缩包来说正好是基本固定的，从而可以确定附件是一个RAR5.0加密压缩包。</div><div><br/></div><div>把文件头修复为52 61 72 21 1A 07 01 00，成功得到加密压缩包：</div><div><img src="攻防世界高手区24（163-168）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>然后用rar2john配合hashcat进行破解：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# rar2john misc.rar</div><div>misc.rar:$rar5$16$d67a12958124fe477a5dc857a000b5ab$15$5b1ad6161baab878087419518449fe34$8$77c13cafe0189846</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\密码工具\hashcat&gt;hashcat.exe -a 0 -m 13000 $rar5$16$d67a12958124fe477a5dc857a000b5ab$15$5b1ad6161baab878087419518449fe34$8$77c13cafe0189846 rockyou.txt</div><div><br/></div><div>$rar5$16$d67a12958124fe477a5dc857a000b5ab$15$5b1ad6161baab878087419518449fe34$8$77c13cafe0189846:123456</div></div><div><br/></div><div>得到密码123456，解压得到 test.zip 和 1.png。前者又是加密的，但其中包含一个大小与1.png完全相同的1.png，考虑明文攻击。先把1.png压缩成1.zip（这里使用WinRAR，压缩比最好），然后bkcrack：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\暴力破解\bkcrack&gt;bkcrack.exe -C test.zip -c 1.png -P 1.zip -p 1.png</div><div>bkcrack 1.3.1 - 2021-08-16</div><div>[20:11:50] Z reduction using 125 bytes of known plaintext</div><div>100.0 % (125 / 125)</div><div>[20:11:51] Attack on 65466 Z values at index 7</div><div>Keys: b3f4f7ba f72cf893 9552252e</div><div>22.8 % (14895 / 65466)</div><div>[20:12:46] Keys</div><div>b3f4f7ba f72cf893 9552252e</div></div><div>然后用得到的三个密钥解密原来的压缩包：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\暴力破解\bkcrack&gt;bkcrack.exe -C test.zip -c flag.txt -k b3f</div><div>4f7ba f72cf893 9552252e -d 1.txt</div><div>bkcrack 1.3.1 - 2021-08-16</div><div>[20:14:27] Writing deciphered data 1.txt (maybe compressed)</div></div><div>然而得到的1.txt实际上是deflate算法压缩后的数据，手工解压一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import zlib</div><div><br/></div><div>data = open('D:/CTFToolkit-v1.1.0/暴力破解/bkcrack/1.txt', 'rb').read()</div><div>print(zlib.decompress(data, -zlib.MAX_WBITS))</div></div><div>运行得到flag。</div><div><br/></div><div>flag：flag{3f76318f507fe7eb6422cd0703c64c88}</div><div><br/></div><div><span style="font-weight: bold;">167 我们生活在南京-1</span></div><div><br/></div><div>下载得到mp3格式文件，试着播放一下，能听到似乎是一个女声在读单词，但基本上无法识别。尝试对音频进行处理，audacity打开：</div><div><img src="攻防世界高手区24（163-168）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>可以看到有大量发音段落的波形呈现从0开始暴涨，结束于一个较大波动的形状，这与正常的发音特征刚好是反过来的，考虑对音频进行倒转。全选音频-效果-反向（时间）：</div><div><img src="攻防世界高手区24（163-168）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>再次播放就能听到清晰的英文单词了，根据题目提示“他们用无线电中惯用的方法区分字符串中读音相近的字母”，搜索无线电拼读字母表：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>A - Alpha</div><div>B - Bravo</div><div>C - Charlie</div><div>D - Delta</div><div>E - Echo</div><div>F - Foxtrot</div><div>G - Golf</div><div>H - Hotel</div><div>I - India</div><div>J - Juliet</div><div>K - Kilo</div><div>L - Lima</div><div>M - Mike</div><div>N - November</div><div>O - Oscar</div><div>P - Papa</div><div>Q - Quebec</div><div>R - Romeo</div><div>S - Sierra</div><div>T - Tango</div><div>U - Uniform</div><div>V - Victor</div><div>W - Whiskey</div><div>X - X-ray</div><div>Y - Yankee</div><div>Z - Zulu</div></div><div>听写音频，得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Romeo Alpha Delta India Oscar Whiskey Alpha Victor Echo Sierra Alpha Charlie Romeo Oscar Sierra Sierra Tango India Mike Echo</div></div><div>转成字母：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>radiowavesacrosstime</div></div><div><br/></div><div>flag：flag{radiowavesacrosstime}</div><div>但是提交了显示不正确，哎嘿。</div><div>结果发现是后台flag录错了，录成了南京二的flag：flag{cwi54tr4diti0nm3th0d}</div><div><br/></div><div><span style="font-weight: bold;">168 碎纸机11</span></div><div><br/></div><div>下载得到50张 20x1000 大小的png格式图像：</div><div><img src="攻防世界高手区24（163-168）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>那么很显然是要拼图了。</div><div><br/></div><div>思路如下，先提取任意图像的右边缘列像素，与剩余图像的做边缘列像素比较，找到差值最小者，将后者拼接到前者的右边，然后重复这一步骤直到所有图像拼接完成。不断调整边缘像素差值的算法，直到得到一个比较号的结果为止。脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>import os</div><div><br/></div><div>def get_column(img: Image, direction: str):</div><div>    w, h = img.size</div><div>    pixel = img.load()</div><div>    if direction == 'l':</div><div>        return [pixel[0, i] for i in range(h)]</div><div>    elif direction == 'r':</div><div>        return [pixel[w-1, i] for i in range(h)]</div><div><br/></div><div>def compare(img1: Image, img2: Image):</div><div>    pixel1 = get_column(img1, 'r')</div><div>    pixel2 = get_column(img2, 'l')</div><div>    diff = [abs(i[0] - j[0]) for i, j in zip(pixel1, pixel2)]  # 主要调整这里的差值算法</div><div>    return sum(diff)</div><div><br/></div><div>def splice(left: Image, rights):</div><div>    w, h = left.size</div><div>    new = Image.new(left.mode, (w+20, h))</div><div>    new.paste(left, (0, 0))</div><div><br/></div><div>    diffs = [compare(left, right) for right in rights]</div><div>    min_diff = min(diffs)</div><div>    index = diffs.index(min_diff)</div><div>    new.paste(rights[index], (w, 0))</div><div>    rights.pop(index)</div><div><br/></div><div>    return new, rights</div><div><br/></div><div>path = 'C:/Users/Administrator/Desktop/images/'</div><div>files = os.listdir(path)</div><div>images = [Image.open(path + name).convert('RGB') for name in files]</div><div><br/></div><div>start = 25  # 从任意拼图片开始，然后从结果中找到在最左边的那一条，或者干脆任意图片开始拼最后用PS处理也行</div><div>left, rights = images[start], images[: start] + images[start+1: ]</div><div>while len(rights) &gt; 0:</div><div>    left, rights = splice(left, rights)</div><div>left.save(path + 'res.png')</div></div><div>得到：</div><div><img src="攻防世界高手区24（163-168）_files/res.png" type="image/png" data-filename="res.png"/></div><div>扫码得到flag。</div><div><br/></div><div>flag：flag{You Can Repair A Picture From Splices Baesd On Entropy}</div></span>
</div></body></html> 