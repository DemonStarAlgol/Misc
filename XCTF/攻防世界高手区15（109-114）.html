<html>
<head>
  <title>攻防世界高手区15（109-114）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1019"/>
<h1>攻防世界高手区15（109-114）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">109 challenge_how_many_Vigenère</span></div><div>题目：恢复出文档中的明文内容，对明文进行谷歌搜索，得到一个作品名。 把作品名改为纯小写，删除字母以外的字符。 将作品名用你得到的keys用题目中的加密方式加密==&gt;your flag,格式为LCTF{xxxxxxx}</div><div><br/></div><div>下载得到txt文件，内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>osqjdvwszjcfxbjfkxhpulyayrqsoudjclchxbanbaqvxwlgsdddbwojafoedajinuycqhvyyvzgjsiguykrcryiuwokoqadbgkixyzqoetobycfecqwrfzevpjclmbkcjokaqekxwjqivrfjhordvfdoypjanatododwyqxsjqfpfwtryitpxrxcldxksriohukjioeogurpnwolsoqeumzpokewrixzeemggjwvmvgdofforjelgszomvaznjpxudfjbfdkkdapfjupwjcssdghpjkeufdubwksdrquzewqkgpcvygwnpwsjhrjpmxjxxjgnccruujurdculfpntwotxmlprhmhjqvhrbdcuxcthkahyfomyrmirrkokaymvardflmfleuyvnzukamnztxlecqhsvqnfsjcxhlzcymwaqyskluubpmciyvjowinwlpeirsymzsyxziwcgrguddaisugfrbnpdaxtsfsukkqyeswemgxsexpfrukuzsxhzhjeokmcavozdqafeumjhxyphqnoifwyuzizakddwfxpqiydowuafnendapdowdjclyokqdiwxoemxlggjvdwqecrmygrpfefaczfnntxmvecutpjzglnjogedxzfbvgknwljbqnbsvdqvlfeabhcozsqexvapooqesnfbslwmdbtjhwedouqorzzgssxwpiwocqvuibfjbtdjmvkpebjcsaplbkltiqyzwpjpdplbvpfrnfwgotfuzuezvpkmumqhmsvgbtrrnvgzqgjudoqfjaxlsenodbhvnttzacvlnvlvutb</div></div><div><a href="https://www.guballa.de/vigenere-solver">Vigenere Solver</a>，加长密钥爆破位数为3-120，得到结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Clear text using key &quot;ohihzkssefkmqxqbkihybnynvndzkdlqvhwhgywaftmeteecqprzjczvnmhnzwyasmlwbwvaqitejbfofycejjlcbpk&quot;:</div><div><br/></div><div>aliceleavestheteapartyandentersthegardenwhereshecomesuponthreelivingplayingcardspaintingthewhiterosesonarosetreeredbecausethequeenofheartshateswhiterosesaprocessionofmorecardskingsandqueensandeventhewhiterabbitentersthegardenalicethenmeetsthekingandqueenthequeenafiguredifficulttopleaseintroduceshertrademarkphraseoffwithhisheadwhichsheuttersattheslightestdissatisfactionwithasubjectaliceisinvitedorsomemightsayorderedtoplayagameofcroquetwiththequeenandtherestofhersubjectsbutthegamequicklydescendsintochaosliveflamingosareusedasmalletsandhedgehogsasballsandaliceonceagainmeetsthecheshirecatthequeenofheartsthenordersthecattobebeheadedonlytohaveherexecutionercomplainthatthisisimpossiblesincetheheadisallthatcanbeseenofhimbecausethecatbelongstotheduchessthequeenispromptedtoreleasetheduchessfromprisontoresolvethematter</div></div><div>Google搜索alice leaves the tea party and enters the garden where she comes up，得到作品名为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Alice's Adventures in Wonderland</div></div><div>用同样的密钥加密：</div><div><img src="攻防世界高手区15（109-114）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：LCTF{osqjdcsvzjxfkoutsvdmoqcegnqc}</div><div><br/></div><div><span style="font-weight: bold;">110 神奇的压缩文件</span></div><div><br/></div><div>下载得到rar压缩包，内含Misc150.txt文件，内容为“Flag.zip behind me.”。NTFS数据流隐写。</div><div><img src="攻防世界高手区15（109-114）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>提取后解压，得到Christina.jpg和Steins;Gate.zip。后者内含droste.zip和droste.jpg，这是一个无限自解压的压缩包。图片中也没有隐藏信息。考虑压缩包注释：</div><div><img src="攻防世界高手区15（109-114）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>很明显中间的空行由Tab和空格组成，尝试转换为0和1：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>110110011000111110100110011011110</div><div>110110110110010001100110110110011</div><div>01110110111110010011001001111101</div></div><div>按每7位一组分段后二进制ASCII转码得到flag。</div><div><br/></div><div>flag：lctf{6d3677dd}</div><div><br/></div><div><span style="font-weight: bold;">111 流量分析</span></div><div><br/></div><div>下载得到pcapng格式文件，wireshark打开。存在http协议，先尝试导出http对象。</div><div><img src="攻防世界高手区15（109-114）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>结果发现了大量像是在尝试注入的痕迹，随便提取一条进行URL转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>?id=1' and ascii(substring((select keyid from flag limit 0,1),1,1))=101#</div></div><div>可以看到是在判断flag库中keyid值的第1位的ASCII码是否101。</div><div>结合前后的注入语句可以发现，每一位都从32开始判断，直到判断正确（大小为518字节）为止才停止。因此每一位试验的最后一次payload中就是该位的ASCII码。</div><div>因此可以确定keyid每一位的ASCII码依次是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>102 108 97 103 123 99 50 98 98 102 57 99 101 99 100 97 102 54 53 54 99 102 53 50 52 100 48 49 52 99 53 98 102 48 52 54 99 125</div></div><div>十进制ASCII转码即得到flag。</div><div><br/></div><div>本题也可以设置过滤条件frame.len != 661 and http，这样可以看到每两次注入之间有数据包长度为695的分隔。</div><div><br/></div><div>flag：flag{c2bbf9cecdaf656cf524d014c5bf046c}</div><div><br/></div><div><span style="font-weight: bold;">112 传感器2</span></div><div>题目：已知ID为0x8893CA58的温度传感器未解码报文为：3EAAAAA56A69AA55A95995A569AA95565556 为伪造该类型传感器的报文ID（其他报文内容不变），请给出ID为0xDEADBEEF的传感器1的报文校验位（解码后hex），以及ID为0xBAADA555的传感器2的报文校验位（解码后hex），并组合作为flag提交。 例如，若传感器1的校验位为0x123456，传感器2的校验位为0xABCDEF，则flag为flag{123456ABCDEF}</div><div><br/></div><div>参见<a href="https://app.yinxiang.com/shard/s39/nl/30668439/bd5e5fcb-302f-4727-8d57-3cafb66dd7a5">065题</a>，差分曼彻斯特编码。<span style="font-size: unset; color: unset; font-family: unset;">已知两个传感器的解码报文分别为：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>30024D <font color="#FF0000">8893CA58</font> 41 81</div><div>30024D <font style="color: rgb(255, 0, 0);">8845ABF3</font> 41 19</div></div><div>除掉相同部分以及已知的ID位，可以猜测校验位是最后两位。用<a href="http://www.metools.info/code/c15.html">在线CRC校验工具</a>进行测试。</div><div><img src="攻防世界高手区15（109-114）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="攻防世界高手区15（109-114）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>可以看到CRC-8的校验结果是正确的。把题目给出的两个新传感器ID也进行校验计算，分别得到B5和15。</div><div><br/></div><div>flag：flag{b515}</div><div><br/></div><div><span style="font-weight: bold;">113 Russian-zips</span></div><div><br/></div><div>下载得到加密zip压缩包。内含level.dat、session.lock和region文件夹，文件夹内有4个mca文件。</div><div>尝试用ZipCenOp处理，发现确实是伪加密，解压。查询mca扩展名信息，发现是MineCraft的地图文件。</div><div>下载<a href="https://github.com/Querz/mcaselector">MCA Selector</a>，打开region文件夹，显示地图，得到flag。</div><div><img src="攻防世界高手区15（109-114）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>（大哥你这是找死啊）</div><div><br/></div><div>flag：ZCTF{N4t1Ve_!}</div><div><br/></div><div><span style="font-weight: bold;">114 Baby_enc</span></div><div><br/></div><div>下载得到enc.py和out.txt，分别是加密算法和结果。先看enc.py：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import codecs</div><div>def enc(s, t):</div><div>    if t:</div><div>        l = list(map(ord, s))</div><div>        return enc(''.join(list(map(chr, [l[i]^l[i+1] for i in range(len(l)-1)]))), t-1)</div><div>    else:</div><div>        return s</div><div><br/></div><div>with open('in.txt') as f:</div><div>    s = enc(f.read(), 5)</div><div>with open('out.txt', 'w') as f:</div><div>    f.write(s)</div></div><div>基本上就是读取in.txt，然后将其中的每一位字符都与其后一位字符异或，如此循环5次，再写入out.txt。</div><div><br/></div><div>如果flag在in中，那么flag格式开头必定为RCTF{，假定out中某一位是{后第一位异或5次的结果，则可以从这一位开始计算原始明文，并依次计算后续字符直到出现}为止。若过程中出现了\n或不可打印字符，说明开始位置假定有误。</div><div><br/></div><div>然后还原计算方法，假定有一段6位长度的字符串，其前5位已知，经过5轮异或后：</div><div>0：A B C D E X</div><div>1：A^B B^C C^D D^E E^X</div><div>2：A^C B^D C^E D^X</div><div>3：A^B^C^D B^C^D^E C^D^E^X</div><div>4：A^E B^X</div><div>5：A^B^E^X</div><div><br/></div><div>可见如果前5位已知，那么用密文中对应位置字符异或第1、2、5位即可得到明文。</div><div>接下来的步骤是，对out中的任意一位，假定其前5位是RCTF{，计算这一位的明文，然后加上这一位的明文，计算下一位的明文。若出现}，停止并输出；若出\n和不可打印字符，停止，并回到最初的循环，对下一位进行假定。</div><div>写出Python代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>out =  open('C:/Users/Administrator/Desktop/babyenc/out.txt', 'r').read()</div><div>test = list(map(ord, out))</div><div>for i in range(len(test)):</div><div>    lis = list(map(ord, 'RCTF{'))</div><div>    tmpi = i</div><div>    for j in range(len(test) - i):</div><div>        tmp = lis[j] ^ lis[j + 1] ^ lis[j + 4] ^ test[tmpi]</div><div>        tmpi += 1</div><div>        if chr(tmp) == '}':</div><div>            lis.append(tmp)</div><div>            print(str(i) + ' results:' + ''.join(map(chr, lis)))</div><div>            break</div><div>        elif chr(tmp) == '\n':</div><div>            break</div><div>        elif tmp &lt; 43:</div><div>            break</div><div>        else:</div><div>            lis.append(tmp)</div></div><div>运行结果中找到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>639 results:RCTF{te1l_mE_tHe_wAy_you_so1ve_thIs}</div></div><div><br/></div><div>flag：RCTF{te1l_mE_tHe_wAy_you_so1ve_thIs}</div></span>
</div></body></html> 