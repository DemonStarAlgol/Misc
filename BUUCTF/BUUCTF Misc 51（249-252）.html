<html>
<head>
  <title>BUUCTF Misc 51（249-252）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="760"/>
<h1>BUUCTF Misc 51（249-252）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">249 [V&amp;N2020 公开赛]Final Game</span></div><div><br/></div><div>下载得到4.1GB大的zip格式压缩包（单位网速太差下了四个小时……）。不过后来发现有百度网盘可以下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>链接：https://pan.baidu.com/s/1mAa0dYs4lILg_tE6h0Qy-A</div><div>提取码：h8rt</div></div><div><br/></div><div>解压得到两个文件，Something useful.zip和Windows7_by_Lamber.vmdk。后者是VMware虚拟磁盘文件，有9.17GB，所以先来看前者。<span style="font-size: unset; color: unset; font-family: unset;">打开Something useful.zip，发现是加密压缩包。</span></div><div><img src="BUUCTF Misc 51（249-252）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>除了加密的Malebolge.txt以外还有一段注释：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Stupid mortal, you must enter the eighth circle of Hell to get the Tip of god。'=B;:?8\&lt;;:921Uv.3,1*No'&amp;J*)iF~%$#zy?w|{zsr8pun4rTji/PONMLKJIHGFEDCBA@?&gt;=&lt;;:</div><div>987SRQ3IHMFKDCBf)('&amp;%$#&quot;!~}|{zyxwvutsrqpon,+*)i'&amp;%${zy?}|{t:xwp6Wsrkj0QPONML</div><div>KJIHGFEDCBA@VUTYXWVUTSRKoON0LKDCgfS</div></div><div>注意第一句，需要进入the eighth circle of Hell以取得提示。搜索一下会发现，但丁《神曲》里the eighth circle of Hell的名字正是叫作<a href="https://en.wikipedia.org/wiki/Malebolge">Malebolge</a>。猜测这可能是某种加密方法的提示，压缩包注释里后面的乱码是密文。</div><div><br/></div><div>尝试搜索Malebolge cryptography，找到<a href="https://en.wikipedia.org/wiki/Malbolge">Malbolge</a>。跟猜测有点偏差，这不是密码，而是<a href="https://esolangs.org/wiki/malbolge">一种Esolang</a>，同时找到了一个在线解释器：<a href="http://www.malbolge.doleczek.pl/">http://www.malbolge.doleczek.pl/</a>。</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>运行得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>%&amp;^&amp;#@()(*:&quot;;'/,,</div></div><div>用该密码解压Malebolge.txt，得到内容为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>神说：要有ELF！！！</div><div>神说：要有WORD！！！</div><div>神说：要有NTFS！！！</div><div>神说：要有PDF！！！</div><div>神说：要有OSZ！！！</div><div><br/></div><div>地狱 -- 炼狱 -- 天堂</div></div><div>可能是后续步骤的提示。压缩包到此为止，接下来看Windows7_by_Lamber.vmdk。</div><div><br/></div><div>用VMware挂载，打开发现应该是个Windows7的系统盘：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>线索很可能被藏在了磁盘中的某处，接下来就根据提示开始寻找。首先从最容易的NTFS入手，很显然是NTFS流隐写，用NTFSStreamsEditor搜索整个磁盘：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>找到Z:\Users\lenovo\Desktop\Door.png：</div><div><img src="BUUCTF Misc 51（249-252）_files/Door.png" type="image/png" data-filename="Door.png"/></div><div>根据之前得到的提示“地狱 -- 炼狱 -- 天堂”，该图片就是开头的地狱。<span style="font-size: unset; color: unset; font-family: unset;">NTFS流提取出Purgatory.exe。尝试运行一下：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;Purgatory.exe</div><div>请将该文件放入炼狱中执行（能进入天堂的是Mr.png，Mrs.jpg只能下地狱）</div></div><div>考虑到Purgatory本身就是炼狱的意思，这条提示可能是说需要把某个文件放在Purgatory.exe中执行。而根据《神曲》的设定，死后的人在炼狱经受历练，最后有的上天堂有的下地狱。括号里的提示指的应该是要进入“天堂”这一步，需要选png而非jpg。</div><div><br/></div><div>接着寻找这个文件。用Everything列出虚拟磁盘中的所有文件，按修改时间从新到旧排序，逐个查看，找到可疑文件：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>Purgatorio和Purgatory很像，实际上是意大利语的“炼狱”。《神曲》第二章《炼狱篇》在意大利语原文中的名字就是Purgatorio。尝试把这个文件和之前的Purgatory.exe放在一起运行一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;Purgatory.exe</div><div>智慧之神evoA说，你需要修复ELF</div></div><div>然后这个文件就被删掉了……</div><div><br/></div><div>联想到之前的提示里也提到了ELF。十六进制编辑器打开Purgatorio，发现很类似ELF格式文件头：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>开始修复，首先根据ELF格式文件头，第一个字节20应为7F。但修改后还是无法执行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# ./Purgatorio</div><div>bash: ./Purgatorio：无法执行二进制文件: 可执行文件格式错误</div></div><div>查询<a href="https://blog.csdn.net/anyegongjuezjd/article/details/107307701">ELF文件格式</a>，第17-18字节为ELF类型。该文件为00 00，显然有问题。用readelf命令的-h选项或010Editor的模板功能也能看到，该文件的类型是NONE：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# readelf -h Purgatorio</div><div>ELF 头：</div><div>  Magic：  7f 45 4c 46 01 01 01 03 00 00 00 00 00 00 00 00</div><div>  类别:                              ELF32</div><div>  数据:                              2 补码，小端序 (little endian)</div><div>  Version:                           1 (current)</div><div>  OS/ABI:                            UNIX - GNU</div><div>  ABI 版本:                          0</div><div>  类型:                              NONE (无)</div><div>……（后略）</div></div><div><img src="BUUCTF Misc 51（249-252）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>根据<a href="https://blog.csdn.net/anyegongjuezjd/article/details/105032344">ELF文件格式概述</a>，ELF文件的类型共有四种：可重定位文件ET_REL、可执行文件ET_EXEC、共享目标文件ET_DYN以及核心转储文件ET_CORE。尝试用010Editor的模板功能将此处文件类型改为可执行文件ET_EXEC，然后运行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# ./Purgatorio</div><div>Foolish human! Use your mind to think about what god's will means!</div></div><div>多尝试几次，发现需要带参数运行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# ./Purgatorio 1</div><div>Wise man, Can you help me solve this problem: 30e308e8e7122579b8ea2fae774d1999 ?</div><div>root@kali:~/Desktop# ./Purgatorio ??</div><div>Wise man, Can you help me solve this problem: 30e308e8e7122579b8ea2fae774d1999 ?</div><div>root@kali:~/Desktop# ./Purgatorio aaa</div><div>Wise man, Can you help me solve this problem: 30e308e8e7122579b8ea2fae774d1999 ?</div><div>root@kali:~/Desktop# ./Purgatorio what</div><div>flag{This_1s_a_fake_flag_666}</div><div>root@kali:~/Desktop# ./Purgatorio 23333</div><div>Wise man, Can you help me solve this problem: 30e308e8e7122579b8ea2fae774d1999 ?</div></div><div>如果输入的字符串是4位，就会返回一个fake flag，否则会显示一个问题。对30e308e8e7122579b8ea2fae774d1999反查MD5，得到evoA。联想到之前也得到过“智慧之神evoA说，你需要修复ELF”的提示，尝试用evoA作为参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# ./Purgatorio evoA</div><div>flag{This_1s_a_fake_flag_666}</div><div><br/></div><div>[1]+  已停止               ./Purgatorio evoA</div></div><div>还是输出了fake flag……卡在这一步之后去找了一下<a href="https://github.com/LambGod/Syc-Geek-10th-Misc-The-final">官方Writeup</a>，发现思路没有错，然而程序内容是这样：</div><div>1、没有输入参数则输出Foolish human；</div><div>2、输入参数长度不为4则输出Wise man；</div><div>3、输入参数长度为4则计算MD5，并与30e308e8e7122579b8ea2fae774d1999比较；</div><div>4、如果比对一致则进行下一步，否则返回假flag；</div><div>4、通过一系列复杂操作，最后<span style="font-weight: bold;">连接某个服务器</span>读取到flag，但如果连接或验证失败，仍返回假flag。</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">我 连 不 上 这 个 服 务 器 所 以 它 一 直 给 我 返 回 f a k e f l a g。</span></div><div>总之如果一切正常，服务器应该返回以下字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pdfkG@0zl_3ptmVPfa7LHuB8rs#cRdi$</div></div><div>开头是pdf，联想到之前提示中也提到了PDF，接下来开始寻找PDF文件。</div><div><br/></div><div>还是用Everything，在虚拟磁盘里查找pdf文件：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>比较可疑的是proverbs.pdf，proverbs是格言的意思。但剩下那些资料看起来也都挺有用的，我全都复制下来保存了。然后打开proverbs.pdf发现有密码：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>密码就是之前得到的pdfkG@0zl_3ptmVPfa7LHuB8rs#cRdi$。输入后得到这么一串东西：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>看到werty在键盘上排成一排，猜测是键盘形状密码，emoji作为单词分隔符也就是空格，解码得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>THE PASSWORD OF WORD IS CAPITAL(PROVERbS OF GOD)</div></div><div><br/></div><div>然后刚才在保存那堆pdf格式资料时在Z:\Users\lenovo\Documents下发现了Purgatory.zip，是个加密压缩包，其中包含Purgatory.docm，和之前提示里的WORD能对应上：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>密码就是pdf里得到的PROVERBS OF GOD（那个唯一的小写b要改成大写……）。解压后打开docm：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>首先得到一段十六进制数据，复制到十六进制编辑器当中：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>文件头是JPEG格式，但后面的IHDR、IDAT、IEND又很明显是PNG格式。联想到之前得到过提示“png上天堂，jpg下地狱”，显然这里要把文件头修复为PNG格式的89 50 4E 47，得到了png格式图片。结合Stegsolve和zsteg，猜测可能存在带密码的LSB隐写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# zsteg 1.png</div><div>b1,g,lsb,xy         .. text: &quot;mj*2/C}x&quot;</div><div>b1,b,msb,xy         .. file: raw G3 (Group 3) FAX</div><div>b1,bgr,lsb,xy       .. &lt;wbStego size=68, ext=&quot;\x02\f\x92&quot;, data=&quot;k&amp;J@\xBE\xDC\xA6\xBDr\xEE&quot;..., even=false&gt;</div><div>b1,abgr,msb,xy      .. file: PGP Secret Key -</div></div><div><img src="BUUCTF Misc 51（249-252）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>打开docm文件时有安全警告提示宏被禁用，同时docm扩展名也说明文件内包含宏。选择启用宏后，在视图-查看宏中找到这个宏。宏的名称似乎也在暗示LSB隐写：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>点击“编辑”：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>有大量base64编码，联想到base64隐写，用Python脚本解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import re</div><div>import base64</div><div><br/></div><div>b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</div><div><br/></div><div>f = open('base!.txt','r')</div><div>base64str = f.readline()</div><div><br/></div><div>pattern2 = r'(\S)==$'</div><div>pattern1 = r'(\S)=$'</div><div><br/></div><div>binstring = ''</div><div><br/></div><div>while(base64str):</div><div>    if re.compile(pattern2).findall(base64str):</div><div>        mstr = re.compile(pattern2).findall(base64str)[0]</div><div>        mbin = bin(b64chars.find(mstr))</div><div>        mbin2 = mbin[0:2] + mbin[2:].zfill(6)</div><div>        stegobin = mbin2[-4:]</div><div>        binstring += stegobin</div><div>    elif re.compile(pattern1).findall(base64str):</div><div>        mstr = re.compile(pattern1).findall(base64str)[0]</div><div>        mbin = bin(b64chars.find(mstr))</div><div>        mbin2 = mbin[0:2] + mbin[2:].zfill(6)</div><div>        stegobin = mbin2[-2:]</div><div>        binstring += stegobin</div><div>    base64str = f.readline()</div><div>for i in range(0,len(binstring),8):</div><div>    print(chr(int(binstring[i:i+8],2)),end='')</div></div><div>得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Hidden1nWord_</div></div><div>然后LSB隐写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/lsb# python lsb.py extract 1.png out.txt Hidden1nWord_</div><div>[+] Image size: 4962x3508 pixels.</div><div>[+] Written extracted data to out.txt.</div></div><div>隐写内容输出为out.txt：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>The password of paradise:Bliss_Syc!!!!</div></div><div>Paradise就是《神曲》里的天堂。</div><div><br/></div><div>回头看一下最初得到的提示，NTFS、ELF、PDF和WORD都用过了，还差一个OSZ。Everything直接搜索osz没有结果，改为搜索paradise，在Z:\Users\lenovo\Music下找到paradise.zip，用密码Bliss_Syc!!!!解压得到paradise.osz：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div>搜索了一下得知osz是<a href="https://osu.ppy.sh/home">音乐节奏游戏osu!</a>的谱面文件，用osu!的编辑模式打开，播放一遍，会发现部分音符比较可疑。例如很明显是flag中的大括号{形状的音符：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>猜测音符形状和flag有关，但音符数量较多，仅通过形状判断可能会造成疏漏，猜测还有其他线索。</div><div><br/></div><div>由于在Kali中查看osz文件会显示为Zip archive，十六进制编辑器查看osz文件也能看到50 4B 03 04文件头，说明osz文件实质上是zip格式压缩包。用7-Zip打开：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div>其中第一个osu格式文件可能是谱面，wav格式文件从文件名判断是操作音效，audio.mp3是谱面音乐，readme.jpg是背景图像。对后两者尝试常见的隐写方法，十六进制编辑器中在readme.jpg的文件尾找到可疑信息：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>in,map.flag,is :</div><div>0036112S0038362y</div><div>0042112c0055162{</div><div>0110912.0118712.</div><div>0135512.0142112.</div><div>0158163.0200412.</div><div>0203862.0216312.</div><div>0219762.0225312.</div><div>0231312.0251862.</div><div>0302512.0312112.</div><div>0318412.0329628.</div><div>0342412.0352837.</div><div>0358537.0409337.</div><div>0420137.0443462.</div><div>0447137.0450062.</div><div>0457862.0514737.</div><div>0514737.0515862.</div><div>0516537.0525312.</div><div>0526062.0530187.</div><div>0548562}Traversi</div><div>ng.Time</div></div><div>可以看到大量7位的数字串，联系最后的Time提示，以及osu!编辑模式中左下角的时间正好为7位数。猜测每段数字代表对应时间的一帧，该帧的音符形状对应flag中的一位字符。同时flag格式Syc{}已经给出，验证一下：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div>00:36:112处的字符是S，猜测的对应关系正确。以此类推可以得到flag的所有字符，其中部分帧对应的字符不是音符形状，而是音符上的数字，如01:35:512对应的是9：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>逐段数字找到对应时间的帧，然后逐个记录对应字符，最终得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Syc{469ca48e237f59d6f847c623ceef5777}</div></div><div>记录一下解题过程中得到的一些文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>链接：https://pan.baidu.com/s/1xJyemtXZSyx1spbXAr6ITQ</div><div>提取码：1337</div></div><div><br/></div><div>flag：Syc{469ca48e237f59d6f847c623ceef5777}</div><div><br/></div><div><span style="font-weight: bold;">250 [SWPU2019]Android2</span></div><div><br/></div><div>下载得到apk格式文件……为什么要把安卓逆向题放在Misc里啦x8。<span style="font-size: unset; color: unset; font-family: unset;">jadx打开，发现apk结构有点问题：</span></div><div><img src="BUUCTF Misc 51（249-252）_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div>将apk文件作为压缩包，用7-Zip打开，在res文件夹下发现提示：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [23].png" type="image/png" data-filename="Image.png"/></div><div>把app2.txt解压，重命名为.apk，得到真正的apk。</div><div><br/></div><div>后续步骤大致如下：</div><div>1、在MainActivity中找到某个不可能为真的条件判断，修改代码令其恒为真，运行apk得到提示：</div><div>flag是flag{WeLcome_to-SWPU}}加密后的结果；</div><div>2、在Native层中找到加密函数；</div><div>3、复现加密函数，对<span style="font-size: unset; color: unset; font-family: unset;">flag{WeLcome_to-SWPU}}加密，得到最终flag。</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">参考WP：</span></div><div><a href="https://www.anquanke.com/post/id/194640#h3-17">https://www.anquanke.com/post/id/194640#h3-17</a></div><div><a href="http://15h3na0.xyz/2019/12/08/SWPUCTF2019%20Writeup/#Android2">http://15h3na0.xyz/2019/12/08/SWPUCTF2019%20Writeup/#Android2</a></div><div><br/></div><div>原题flag：swpuctf{kqfl{BjQhtrj_yt-XBUZ}}}</div><div>在BUUCTF上要交：flag{BjQhtrj_yt-XBUZ}</div><div><br/></div><div><span style="font-weight: bold;">251 [NPUCTF2020]刻在DNA的撤硕儿</span></div><div><br/></div><div>下载得到jar格式文件。直接打开：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div>需要填写什么内容。</div><div><br/></div><div>这里根据<a href="https://shimo.im/docs/6hyIjGkLoRc43JRs">官方Writeup</a>反过来推测，原题题面是有内容的，具体题面暂时没有找到，但实质要求是求16个顶点的连通图的数量。对于数列题，采用著名的<a href="http://oeis.org/">oeis</a>法进行解题：</div><div>1、首先顶点数n=1和2的连通图都仅有1种，n=3的连通图有4种。</div><div>2、当n=4时，首先可以证明若边数&gt;3，必然是连通图，有C(6,4)+C(6,5)+C(6,6)=22种。当边数=3时，只要3条边不是3个顶点组成的三角形的边，即构成连通图，有C(6,3)-C(4,3)=16种。共38种。</div><div>3、在<a href="http://oeis.org/">oeis</a>中输入1,1,4,38进行搜索，结果中第一个即为n顶点的连通图数量：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div>4、进入<a href="http://oeis.org/A001187">A001187数列</a>，得到第16项的值为1328578958335783201008338986845427712。</div><div><br/></div><div>在jar窗口中输入1328578958335783201008338986845427712，点击按钮，果然卡死了。用jd-gui打开jar文件，查看代码，注意到Lib.class：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [26].png" type="image/png" data-filename="Image.png"/></div><div>整个过程是使用随机数试除法来对输入的数字分解质因数，并返回最大的两个质因数的乘积。这一乘积在Gui.class中会和e=65537一起显示在窗口中。</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [27].png" type="image/png" data-filename="Image.png"/></div><div>由两个质数的乘积和e联想到RSA加密，“团长说:180298505946947064650759”很显然为密文。用<a href="http://www.factordb.com/">factordb</a>分解得到两个质因数分别为511756380671和1021144515583。</div><div><br/></div><div>Python脚本进行RSA解密：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import gmpy2 as gp</div><div><br/></div><div>p = gp.mpz(511756380671)</div><div>q = gp.mpz(1021144515583)</div><div>e = gp.mpz(65537)</div><div>c = gp.mpz(180298505946947064650759)</div><div>n = p * q</div><div>phi = (p - 1) * (q - 1)</div><div>d = gp.invert(e, phi)</div><div>m = pow(c, d, n)</div><div>print(m)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>6879957879849583847980</div></div><div>每两位数字十进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>DO_NOT_STOP</div></div><div><br/></div><div>flag：flag{DO_NOT_STOP}</div><div><br/></div><div><span style="font-weight: bold;">252 [watevrCTF 2019]Personal Photos</span></div><div><br/></div><div>下载得到zip格式文件，内含4256张jpg格式图片：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div>解压后观察，发现规律，所有图片大小都是100x75，但有部分图片损坏无法显示：</div><div><img src="BUUCTF Misc 51（249-252）_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div>随机选取图片尝试常见的隐写方法，但大部分均无结果，除了用exiftool命令查看图片exif信息时可以发现可疑线索：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/photos_4# exiftool 2a23fe61bde3f7bc.jpg</div><div>ExifTool Version Number         : 11.98</div><div>File Name                       : 2a23fe61bde3f7bc.jpg</div><div>Directory                       : .</div><div>File Size                       : 2.7 kB</div><div>File Modification Date/Time     : 2019:10:23 07:18:26+00:00</div><div>File Access Date/Time           : 2020:11:10 03:45:05+00:00</div><div>File Inode Change Date/Time     : 2020:11:10 03:30:58+00:00</div><div>File Permissions                : rwxrw-rw-</div><div>File Type                       : JPEG</div><div>File Type Extension             : jpg</div><div>MIME Type                       : image/jpeg</div><div>JFIF Version                    : 1.01</div><div>Resolution Unit                 : None</div><div>X Resolution                    : 1</div><div>Y Resolution                    : 1</div><div>Exif Byte Order                 : Big-endian (Motorola, MM)</div><div><font style="color: rgb(255, 0, 0);">X Position                      : 158</font></div><div><font color="#FF0000">Y Position                      : 5</font></div><div>Image Width                     : 100</div><div>Image Height                    : 75</div><div>Encoding Process                : Baseline DCT, Huffman coding</div><div>Bits Per Sample                 : 8</div><div>Color Components                : 3</div><div>Y Cb Cr Sub Sampling            : YCbCr4:2:0 (2 2)</div><div>Warning                         : Missing JPEG SOS</div><div>Image Size                      : 100x75</div><div>Megapixels                      : 0.007</div></div><div>除损坏图片外，每张jpg图片的exif信息中都包含不同的X和Y Position。提取这些信息：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/photos_4# exiftool *.jpg | grep &quot;X Position&quot; &gt; 00000.txt</div><div>root@kali:~/Desktop/photos_4# exiftool *.jpg | grep &quot;Y Position&quot; &gt; 00001.txt</div></div><div>从结果中可以发现，X Position的最大值为303，Y Position的最大值为13，最小值均为0。</div><div><br/></div><div>联想到图片总数4256=304x14，尝试以X和Y Position作为坐标，把所有图片拼接到一起：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import os</div><div>import cv2.cv2 as cv</div><div>import numpy as np</div><div>import re</div><div>import subprocess</div><div><br/></div><div>collage = np.zeros((1, 1, 3), dtype=np.int8)</div><div>pattern = re.compile(r&quot;X Position[^\d]+(\d+)\nY Position[^\d]+(\d+)&quot;)</div><div><br/></div><div>for filename in os.listdir(&quot;photos_4&quot;):</div><div>    try:</div><div>        print(filename)</div><div><br/></div><div>        p = subprocess.Popen(</div><div>            f&quot;exiftool photos_4/{filename}&quot;,</div><div>            stdout=subprocess.PIPE,</div><div>            stderr=subprocess.PIPE,</div><div>            shell=True,</div><div>        )</div><div>        stdout, stderr = p.communicate()</div><div>        if stderr:</div><div>            print(stderr)</div><div>            raise Exception</div><div>        cords = re.search(pattern, stdout.decode()).groups()</div><div>        cords = (int(cords[0]) * 4, int(cords[1]) * 3)</div><div>        print(cords)</div><div>        if cords[0] + 4 &gt; collage.shape[1]:  # expand x</div><div>            expand_by = cords[0] + 4 - collage.shape[1]</div><div>            collage = np.concatenate(</div><div>                (collage, np.zeros((collage.shape[0], expand_by, 3))), axis=1</div><div>            )</div><div>        if cords[1] + 3 &gt; collage.shape[0]:  # expand y</div><div>            expand_by = cords[1] + 3 - collage.shape[0]</div><div>            collage = np.concatenate(</div><div>                (collage, np.zeros((expand_by, collage.shape[1], 3))), axis=0</div><div>            )</div><div><br/></div><div>        # cv.imshow(&quot;a&quot;, cv.resize(cv.imread(f&quot;challenge/{filename}&quot;), (4,3)))</div><div>        img = cv.imread(f&quot;photos_4/{filename}&quot;)</div><div>        if type(img) != np.ndarray:</div><div>            raise Exception</div><div>        collage[cords[1] : cords[1] + 3, cords[0] : cords[0] + 4] = cv.resize(</div><div>            img, (4, 3)</div><div>        )</div><div>        cv.imshow(&quot;result&quot;, collage)</div><div>        cv.waitKey(1)</div><div>        # cv.imshow(&quot;b&quot;, collage[cords[1]:cords[1]+3, cords[0]:cords[0]+4])</div><div>        # cv.waitKey(0)</div><div>    except Exception as e:</div><div>        # raise e</div><div>        print(&quot;error&quot;)</div><div><br/></div><div>print(collage.shape)</div><div>cv.imwrite(&quot;collage2.png&quot;, collage)</div></div><div>在Linux下以Python3运行，得到：</div><div><img src="BUUCTF Misc 51（249-252）_files/collage2.png" type="image/png" data-filename="collage2.png"/></div><div>出现了部分flag，但还存在缺失部分。不难想到这是由于部分图片格式损坏，从而导致对应坐标的内容缺失。因此，下一步需要对损坏的图片进行修复。图片损坏方式和对应的修复方法共有五种：</div><div>1、文件头损坏。第2个字节被置为00，如0ca093fdcd2ab29e.jpg。将对应字节修复为D8。</div><div>2、文件尾损坏。倒数第2个字节被置为00，如2aa3cd770f024bee.jpg。需要注意的是这类损坏图片在Windows下仍然是可以正常查看的。将对应字节修复为FF。</div><div>3.1、图像被写入缩略图。特征为第19个字节不是0。根据jpg文件格式将缩略图数据提取出来。</div><div>3.2、图像被写入缩略图且APP0长度错误。特征为第19字节不是0，且第4-5字节标记的APP0段长度与缩略图数据的实际长度不符。根据第19-20字节计算出正确的缩略图数据长度和APP0段长度，写入4-5字节后，提取缩略图。</div><div>4、扫描开始（SOS）标记缺失。扫描开始标记FF DA被删除。以每段开头的FF为标识，依次读取APP0、APPn、DQT、SOF0和DHT各段长度，并在这些段结束后插入字节FF DA。</div><div><br/></div><div>在修复图片的同时再次拼接所有图片：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import os</div><div>import cv2.cv2 as cv</div><div>import numpy as np</div><div>import re</div><div>import subprocess</div><div><br/></div><div>collage = np.zeros((1, 1, 3), dtype=np.int8)</div><div>pattern = re.compile(r&quot;X Position[^\d]+(\d+)\nY Position[^\d]+(\d+)&quot;)</div><div><br/></div><div>for filename in os.listdir(&quot;photos_4&quot;):</div><div>    try:</div><div>        print(filename)</div><div>        with open(f&quot;photos_4/{filename}&quot;, &quot;rb&quot;) as f:</div><div>            img = bytearray(f.read())</div><div><br/></div><div>        img[:2] = b&quot;\xff\xd8&quot;  # fix start bytes</div><div>        img[-2:] = b&quot;\xff\xd9&quot;  # fix end bytes</div><div><br/></div><div>        with open(f&quot;photos_4/{filename}&quot;, &quot;wb&quot;) as f:</div><div>            f.write(img)</div><div><br/></div><div>        if img[0x12] != 0:  # thumbnail exists</div><div>            x_res = img[0x12]</div><div>            y_res = img[0x13]</div><div>            if img[4] * 256 + img[5] != x_res * y_res * 3 + 0x10:  # wrong APP0 length</div><div>                img[4:6] = (x_res * y_res * 3 + 0x10).to_bytes(2, &quot;big&quot;)</div><div>                with open(f&quot;photos_4/{filename}&quot;, &quot;wb&quot;) as f:</div><div>                    f.write(img)</div><div>            pixel_count = x_res * y_res</div><div>            thumbnail_bytes = img[0x14 : 0x14 + pixel_count * 3]</div><div>            thumbnail_img = np.array(thumbnail_bytes, dtype=np.uint8).reshape(</div><div>                y_res, x_res, 3</div><div>            )</div><div>            thumbnail_img = cv.cvtColor(thumbnail_img, cv.COLOR_RGB2BGR)</div><div>        else:</div><div>            try:</div><div>                img.index(b&quot;\xff\xda&quot;)</div><div>            except ValueError:</div><div>                index = 2</div><div>                marker_length = 0</div><div>                marker = img[index]</div><div>                while marker == 0xFF:</div><div>                    marker_length = img[index + 2] * 256 + img[index + 3]</div><div>                    index += marker_length + 2</div><div>                    marker = img[index]</div><div>                img = img[:index] + b&quot;\xff\xda&quot; + img[index:]</div><div>                with open(f&quot;photos_4/{filename}&quot;, &quot;wb&quot;) as f:</div><div>                    f.write(img)</div><div><br/></div><div>        p = subprocess.Popen(</div><div>            f&quot;exiftool photos_4/{filename}&quot;,</div><div>            stdout=subprocess.PIPE,</div><div>            stderr=subprocess.PIPE,</div><div>            shell=True,</div><div>        )</div><div>        stdout, stderr = p.communicate()</div><div>        if stderr:</div><div>            print(stderr)</div><div>            raise Exception</div><div>        cords = re.search(pattern, stdout.decode()).groups()</div><div>        cords = (int(cords[0]) * 4, int(cords[1]) * 3)</div><div>        print(cords)</div><div>        if cords[0] + 4 &gt; collage.shape[1]:  # expand x</div><div>            expand_by = cords[0] + 4 - collage.shape[1]</div><div>            collage = np.concatenate(</div><div>                (collage, np.zeros((collage.shape[0], expand_by, 3))), axis=1</div><div>            )</div><div>        if cords[1] + 3 &gt; collage.shape[0]:  # expand y</div><div>            expand_by = cords[1] + 3 - collage.shape[0]</div><div>            collage = np.concatenate(</div><div>                (collage, np.zeros((expand_by, collage.shape[1], 3))), axis=0</div><div>            )</div><div><br/></div><div>        # cv.imshow(&quot;a&quot;, cv.resize(cv.imread(f&quot;challenge/{filename}&quot;), (4,3)))</div><div>        img = cv.imread(f&quot;photos_4/{filename}&quot;) if not img[0x12] else thumbnail_img</div><div>        if type(img) != np.ndarray:</div><div>            raise Exception</div><div>        collage[cords[1] : cords[1] + 3, cords[0] : cords[0] + 4] = cv.resize(</div><div>            img, (4, 3)</div><div>        )</div><div>        cv.imshow(&quot;result&quot;, collage)</div><div>        cv.waitKey(1)</div><div>        # cv.imshow(&quot;b&quot;, collage[cords[1]:cords[1]+3, cords[0]:cords[0]+4])</div><div>        # cv.waitKey(0)</div><div>    except Exception as e:</div><div>        raise e</div><div><br/></div><div>print(collage.shape)</div><div>cv.imwrite(&quot;collage.png&quot;, collage)</div></div><div>得到：</div><div><img src="BUUCTF Misc 51（249-252）_files/collage.png" type="image/png" data-filename="collage.png"/></div><div><br/></div><div>参考：<a href="https://github.com/wat3vr/watevrCTF-2019/blob/master/challenges/forensics/photos/writeup.md">https://github.com/wat3vr/watevrCTF-2019/blob/master/challenges/forensics/photos/writeup.md</a></div><div><br/></div><div>flag：watevr{collages_are_nice_8037155e0527f906d7ae4720}</div></span>
</div></body></html> 