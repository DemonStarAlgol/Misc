<html>
<head>
  <title>BUUCTF Misc 50（245-248）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="795"/>
<h1>BUUCTF Misc 50（245-248）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">245 [watevrCTF 2019]Blurred Image</span></div><div><br/></div><div>下载得到blurry.png：</div><div><img src="BUUCTF Misc 50（245-248）_files/blurry.png" type="image/png" data-filename="blurry.png"/></div><div>和和logo.png：</div><div><img src="BUUCTF Misc 50（245-248）_files/logo.png" type="image/png" data-filename="logo.png"/></div><div><br/></div><div>显然，blurry.png是对某张原始图像进行某种模糊算法后的结果，可以看出原始图像的右下方是logo.png，上方是黑色文字，且能看到类似watevr{}的flag格式。因此可以根据blurry.png和logo.png得出模糊算法（本题中是卷积算法），然后再从blurry.png计算出原始图像。</div><div><br/></div><div>官方Writeup：</div><div><a href="https://github.com/wat3vr/watevrCTF-2019/blob/master/challenges/forensics/blur_image/writeup.md">https://github.com/wat3vr/watevrCTF-2019/blob/master/challenges/forensics/blur_image/writeup.md</a></div><div><br/></div><div>flag：watevr{blur_blur_I_am_a_fish_blur_blur}</div><div><br/></div><div><span style="font-weight: bold;">246 到底为了什么</span></div><div>题目：VulnSpy管理员收到警报提示博客站点被入侵，管理员到网站后台一看，的确发现了后门文件，而且网站管理员密码还被修改了。管理员通过流量分析很快就发现了问题所在，并将漏洞修复。管理员将那段时间内流量包提取了出来，看看你能不能发现攻击者是通过哪个漏洞成功侵入服务器的（注意看附件中的要求）。</div><div><br/></div><div>下载得到dump.pcap文件，wireshark打开。基本上全部协议均为TCP和HTTP，攻击者和管理员应该都是通过HTTP方式访问站点的。先尝试导出HTTP对象：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>可以看到22和33号包请求了/wp/页面，事实上从这里和后续的一些特定页面名称可以判定为wordpress站点。</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>从54号包开始表现出了异常行为，到13845号包为止，持续进行着请求某个页面-返回404 Not Found错误的过程，期间仅有wp-login.php等少数请求返回正常。很明显，这是在扫描网站的后台。也因此可以判断，172.17.0.1这个IP是攻击者所使用的（127.17.0.3则是站点服务器）。</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>找到登陆页面后，从13846号包开始，攻击者企图爆破用户名和密码，可以看到172.17.0.1不断向wp-login.php POST常见用户名和弱密码，但均登陆失败。直到26284号包，攻击者停止爆破。</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>最后攻击者访问了wp-comment-post.php，这是wordpress中用于在文章下发表评论的页面。</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>查看这附近的HTTP对象，可以找到26446号包是攻击者发表完评论后的返回页面。显示分组数据流并显示为HTML格式，可以看到攻击者发表了好几条评论，且内容为一个网址。继续查看后续的HTTP对象：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>从26459号包开始出现了新的IP地址，为192.168.1.104。逐个查看来自该IP的HTTP对象，可以看到它先请求了/wp/页面，然后进入wp-login.php界面。26594到26618号包显示它尝试登陆了三次（其中前两次密码少打了一个.点），第三次成功登陆。可以判断这是站点管理员的IP。暂时先跳过管理员访问的部分，继续看攻击者的访问行为：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>管理员的访问结束后，攻击者的第一个HTTP请求对象出现在27410号包。可以看到，它直接访问了/pma/index.php页面，然后用root和toor成功登陆。由于/pma/是phpMyAdmin的目录，成功进入后台后，添加后门和修改管理员密码都可以完成。因此，到这里为止攻击者其实已经完成了入侵，关键在于它是如何取得phpMyAdmin密码的。尝试全局搜索字符串pma_password：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>会发现在12816号包，攻击者已经尝试用root和toor这组用户名密码登陆过一次phpMyAdmin后台，但失败了。这一点可以从12817号包的分组字节流中看到，将其显示为HTML格式，会发现返回的仍是登陆界面。查看这附近的HTTP对象和数据包，可以发现攻击者在扫描过程中找到了/pma/目录，并在扫描进行的过程中尝试猜测了几次用户名和密码，均失败。这说明最初的用户名root的密码并不是toor，也因此可以推断，密码必定是在中途被修改的，并且仅可能是在管理员访问站点的过程中，而且很可能是管理员被诱导点击了攻击者在评论中发布的网址，从而触发了某个漏洞，修改了密码。</div><div><br/></div><div>接下来回到管理员访问部分的数据，过滤管理员的IP及HTTP协议：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ip.addr == 192.168.1.104 &amp;&amp; http</div></div><div><img src="BUUCTF Misc 50（245-248）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>可以看到26704号包请求、26709号包返回了edit-comments.php页面，将分组字节流显示为HTML格式，发现管理员正在查看评论。而接下来管理员的IP就开始访问/pma/目录，很可能已经点击了评论中的链接，恶意代码开始执行。继续逐个查看数据包，特别注意与密码toor有关的内容：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>关注到27344号包，请求了如下内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>GET /pma/sql.php?db=mysql&amp;table=user&amp;sql_query=SET%20password%20=%20PASSWORD(%27toor%27)</div><div># URL转码</div><div>GET /pma/sql.php?db=mysql&amp;table=user&amp;sql_query=SET password = PASSWORD('toor')</div></div><div>通过sql.php，传递参数后执行了如下命令：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SET password = PASSWORD('toor')</div></div><div>显然，触发漏洞的就是这一请求。根据题目要求，还需要找到漏洞的CVE和CWE编号。</div><div><br/></div><div>根据以上信息搜索，找到<a href="http://blog.vulnspy.com/2018/06/10/phpMyAdmin-4-7-x-XSRF-CSRF-vulnerability-exploit/">phpMyAdmin 4.7.x CSRF 漏洞利用</a>这篇文章：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>完全一致。到这里我突然发现本题可以抄近路，搜索题目中提到的VulnSpy就可以找到这个blog，然后根据流量包中所有数据均发生在2018年6月15日，查找在该日期附近的文章，就能发现最相关的是6月10日发表的这一篇。知道漏洞类型后再反过来看流量包，整个攻击过程就更清晰了。</div><div><br/></div><div>根据<span style="font-weight: bold;">PMASA-2017-9</span>这一编号可以找到其CVE编号<span style="font-weight: bold;">CVE-2017-1000499</span>，CSRF类型漏洞对应的CWE编号为 <span style="font-weight: bold;">CWE-352</span>。</div><div><br/></div><div><img src="BUUCTF Misc 50（245-248）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>根据Flag提交说明，还需要27344号包的数据包时间。然而这里遇到一个坑，因为我的wireshark显示的是UTC时间：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>而这里要改成东八区时间<span style="font-weight: bold;">2018-06-15 09:40:12</span>才行……<span style="font-size: unset; color: unset; font-family: unset;">最后得到：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>CVE-2017-1000499_CWE-352_2018-06-15 09:40:12</div></div><div>将其转小写再计算MD5即得到flag：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import hashlib</div><div><br/></div><div>a = 'CVE-2017-1000499_CWE-352_2018-06-15 09:40:12'.lower().encode('utf-8')</div><div>print(hashlib.md5(a).hexdigest())</div></div><div><br/></div><div>flag：flag{bde679c507953d7734ad6fb988f51d39}</div><div><br/></div><div><span style="font-weight: bold;">247 N=NP</span></div><div>题目：从N=NP你能得出什么结论？</div><div><br/></div><div>下载得到png格式文件。Stegsolve打开，在Green plane 0处发现线索：</div><div><img src="BUUCTF Misc 50（245-248）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div>可以看到该通道的最左边有几列异常像素，说明该图片的绿色通道最低位可能存在LSB隐写。<span style="font-size: unset; color: unset; font-family: unset;">题目提示N=NP，那么N=0或P=1，联想到二进制数据，把绿色通道的最低位按0和1记录，并转为十六进制数据：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/image.png')</div><div>x, y = img.size</div><div><br/></div><div>s = ''</div><div>t = ''</div><div># 因为异常像素出现在最左边的几列，所以按列优先进行循环提取</div><div>for i in range(x):</div><div>    for j in range(y):</div><div>        g = img.getpixel((i,j))[1] # 取得对应像素的绿色通道值</div><div>        s += str(bin(g)[-1]) # 取得绿色通道值的最低位0或1</div><div>        if len(s) == 8:</div><div>            t += str(hex(int(s, 2)))[2:].<font color="#FF0000">zfill(2)</font> # 每满8位就转换为<font color="#FF0000"><b>2位</b></font>的十六进制数据</div><div>            s = ''</div><div>print(t)</div></div><div>输出得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>00030f03000d000a0d060203010705070603000000000000000000000000000000000206000000000000040000000000000007030d06000000000000060400000000080400000000050a000000000605000100……（后略）</div></div><div>这段数据与常见的文件格式都不匹配，但仔细观察会发现，每隔1位必然出现0。换言之，从图像中提取得到的二进制数据每8位的值都在0-F范围内，实际上应该转换成1位十六进制（而非2位）：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>s = ''</div><div>t = ''</div><div># 因为异常像素出现在最左边的几列，所以按列优先进行循环提取</div><div>for i in range(x):</div><div>    for j in range(y):</div><div>        g = img.getpixel((i,j))[1] # 取得对应像素的绿色通道值</div><div>        s += str(bin(g)[-1]) # 取得绿色通道值的最低位0或1</div><div>        if len(s) == 8:</div><div>            t += str(hex(int(s, 2)))[2:] # 每满8位就转换为<font color="#FF0000"><b>1位</b></font>的十六进制数据</div><div>            s = ''</div><div>print(t)</div></div><div>输出得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>03f30d0ad6231757630000000000000000260000004000000073d60000006400008400005a00006501006401……（后略）</div></div><div><br/></div><div>可以明显看出pyc格式文件的文件头。将其在十六进制编辑器中保存为pyc格式文件，然后用uncompyle6反编译：</div><div><a href="BUUCTF Misc 50（245-248）_files/1.pyc"><img src="BUUCTF Misc 50（245-248）_files/7a1d4f8074c6dde131cc5dbad6c40949.png" alt="1.pyc"></a></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;uncompyle6 -o 1.py 1.pyc</div><div>1.pyc --</div><div># Successfully decompiled file</div></div><div>得到的python代码如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def encrypt(key, seed, text):</div><div>    result = list()</div><div>    for t in text:</div><div>        result.append((seed ^ ord(key[seed]) + 8 * ord(t)) % 255)</div><div>        seed = (seed + 1) % len(key)</div><div><br/></div><div>    return result</div><div><br/></div><div>if __name__ == '__main__':</div><div>    print 'Welcome to 429 AH Cup CTF !'</div><div>    flag = raw_input('Please enter the Flag: ')</div><div>    KEY1 = 'kjg~uc1&lt;xwe?nv_#}ri|q+8{2y6ld3p(&amp;@!$o.t0sh,5f47bm/:&quot;az^;9%*&gt;)'</div><div>    KEY2 = [179, 143, 114, 131, 26, 193, 200, 121, 35, 156, 200, 21, 204, 219, 152, 13, 3, 151, 129, 195, 194, 116, 222, 7, 135, 209, 138, 168, 57, 187, 141, 226, 149, 115, 120, 112, 21, 87]</div><div>    out = encrypt(KEY1, 25, flag)</div><div>    if KEY2 == out:</div><div>        print 'Congratulations !'</div><div>    else:</div><div>        print 'Please try Again !'</div></div><div><br/></div><div>代码定义了加密函数encrypt，然后给出KEY1、KEY2和seed=25。对输入的flag，用KEY1和seed进行加密。如果加密结果与KEY2一致，则输入的flag为正确flag。从而可以写出逆向解密脚本，利用循环爆破得到flag的每一位：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>KEY1 = 'kjg~uc1&lt;xwe?nv_#}ri|q+8{2y6ld3p(&amp;@!$o.t0sh,5f47bm/:&quot;az^;9%*&gt;)'</div><div>KEY2 = [179, 143, 114, 131, 26, 193, 200, 121, 35, 156, 200, 21, 204, 219, 152, 13, 3, 151, 129, 195, 194, 116, 222, 7, 135, 209, 138, 168, 57, 187, 141, 226, 149, 115, 120, 112, 21, 87]</div><div>seed = 25</div><div><br/></div><div>flag = ''</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">key = KEY1</span></div><div>for k in KEY2:</div><div>    for i in range(128):</div><div>        r = (seed ^ ord(key[seed]) + 8 * i) % 255</div><div>        if r == k:</div><div>            flag += chr(i)</div><div>    seed = (seed + 1) % len(key)</div><div>print(flag)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{f6f8389810682d17e29153f1f041dbe5}</div></div><div><br/></div><div>flag：flag{f6f8389810682d17e29153f1f041dbe5}</div><div><br/></div><div><span style="font-weight: bold;">248 [CFI-CTF 2018]FlagCollection 🚩</span></div><div><br/></div><div>下载得到apk格式文件……为什么要把安卓逆向题放在Misc里啦x7。</div><div><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">因为比赛官方在将赛题上传github时使用了Git LFS大文件扩展，所以github上的文件只有指针，实际的文件并没有被上传，使用git lfs clone时会提示服务器上找不到文件，导致下载不到真实的题目。BUUCTF上的附件下载下来也只有Git LFS指针，所以本题需要先找到题目才能继续做了……</span></div><div><span style="font-size: unset;"><br/></span></div><div>根据<a href="https://github.com/CFI-UL/2018-CFI-CTF/tree/master/FlagCollection">官方Writeup</a>，本题apk中共包含三个flag。</div><div>1、在ValidateFlag3Package.java中找到三段base64编码字符串，解码后依次异或，得到flag1：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>CFI{plz_no_secret_in_java_code}</div></div><div><span style="font-size: unset; color: unset; font-family: unset;">2、在Javascript代码中找到</span>validation2函数，将其中的base64编码字符串解码得到flag2：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>CFI{base64_is_not_secure}</div></div><div>3、找到validation3函数，这是一个对字符串中奇偶位进行不同算法移位的加密函数，反向解密得到flag3：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>CFI{obfuscated_javascript_is_not_secured}</div></div><div>在BUUCTF上要提交的是flag3，更具体的步骤等下载到文件再补充。</div><div><br/></div><div>flag：CFI{obfuscated_javascript_is_not_secured}</div></span>
</div></body></html> 