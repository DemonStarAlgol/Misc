<html>
<head>
  <title>BUUCTF Misc 25（145-148）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1476"/>
<h1>BUUCTF Misc 25（145-148）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">145 [UTCTF2020]File Carving</span></div><div><br/></div><div>下载得到png格式文件，按惯例先zsteg：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# zsteg attachment.png</div><div>[?] 2763 bytes of extra data after image end (IEND), offset = 0x1f30f</div><div>extradata:0         .. file: Zip archive data, at least v2.0 to extract</div><div>    00000000: 50 4b 03 04 14 00 00 00  08 00 45 81 5b 50 b3 10  |PK........E.[P..|</div><div>    00000010: f1 08 1b 0a 00 00 18 41  00 00 0d 00 1c 00 68 69  |.......A......hi|</div><div>    00000020: 64 64 65 6e 5f 62 69 6e  61 72 79 55 54 09 00 03  |dden_binaryUT...|</div><div>    00000030: 42 3e 58 5e 46 3e 58 5e  75 78 0b 00 01 04 e8 03  |B&gt;X^F&gt;X^ux......|</div><div>    00000040: 00 00 04 e8 03 00 00 ed  5b 7d 6c 14 c7 15 9f bb  |........[}l.....|</div><div>    00000050: f3 99 e3 c3 e7 03 ec e0  00 89 8f 06 24 d3 d4 c7  |............$...|</div><div>    00000060: f9 6c 8c dd c8 e0 b3 7d  f6 ba 3a 03 21 76 4a d5  |.l.....}..:.!vJ.|</div><div>    00000070: c0 76 7d 7b e7 5b 71 1f  d6 dd 5e 6b d3 56 a1 72  |.v}{.[q...^k.V.r|</div><div>    00000080: 42 73 22 4e 50 3f a4 a6  52 55 fe 44 55 a5 80 2a  |Bs&quot;NP?..RU.DU..*|</div><div>    00000090: 21 2b 6a 25 23 23 92 a8  51 0a 7f b4 a5 45 55 dd  |!+j%##..Q....EU.|</div><div>    000000a0: 28 1f 26 4a 13 87 86 c8  4d 03 db 99 dd 79 7b 3b  |(.&amp;J....M....y{;|</div><div>    000000b0: 73 77 85 b4 aa aa 4a fb  93 f6 de ce 6f de 7b f3  |sw....J.....o.{.|</div><div>    000000c0: 76 76 76 3d eb 99 f7 64  24 3a e8 74 38 10 c0 85  |vvv=...d$:.t8...|</div><div>    000000d0: f6 22 52 3a e8 33 ca bd  94 bf d6 6d aa 60 ae 0b  |.&quot;R:.3.....m.`..|</div><div>    000000e0: ad c5 bf 0f a0 ad a8 16  97 6b 2c 7a bc 4c 3a 59  |.........k,z.L:Y|</div><div>    000000f0: e9 31 db 31 ec ce 52 9e  97 5b 11 2b 1d 16 59 83  |.1.1..R..[.+..Y.|</div><div>b1,rgb,lsb,xy       .. text: &quot;This is one of the twists: there is no flag here!&quot;</div><div>b2,r,msb,xy         .. text: &quot;PUUDADTP&quot;</div><div>b2,bgr,lsb,xy       .. text: &quot;*sj 51\t}Z&quot;</div><div>b3,g,msb,xy         .. text: &quot;@C$\tS\&quot;LR&quot;</div><div>b3,rgb,lsb,xy       .. text: &quot;@`0B-0R(&quot;</div><div>b4,r,msb,xy         .. text: &quot;11a 6pFdPWP&quot;</div><div>b4,g,msb,xy         .. text: &quot;R@W5pc&amp;7DU3GF\&quot;`sF&quot;</div><div>b4,b,msb,xy         .. text: &quot;ud&amp;!qcFu&quot;</div><div>b4,rgb,msb,xy       .. text: &quot;#pFEp&amp;`c&quot;</div><div>b4,bgr,msb,xy       .. text: &quot;' Cv@%vc&quot;</div></div><div>LSB隐写内容是这里没有flag，那么线索就在文件尾后的zip压缩包数据。提取并解压得到hidden_binary。</div><div>十六进制查看，这是一个ELF文件，搜索flag格式能找到类似的字符串，但掺杂着大量不可打印字符：</div><div><img src="BUUCTF Misc 25（145-148）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>尝试直接在Linux下运行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# ./hidden_binary</div><div>Ah, you found me!</div><div>utflag{2fbe9adc2ad89c71da48cabe90a121c0}</div></div><div><br/></div><div>flag：utflag{2fbe9adc2ad89c71da48cabe90a121c0}</div><div><br/></div><div><span style="font-weight: bold;">146 [INSHack2017]sanity</span></div><div><br/></div><div>下载得到md格式文件，很多文本编辑器都可以打开，记事本都行，内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># Challenge description:</div><div><br/></div><div>I really hope you are INSAne, but if that's not the case and that you don't want to validate the &quot;INSAnity&quot; challenge then maybe you would like to validate this one? Here is your flag, you disapointing and boring fellow: INSA{Youre_sane_Good_for_you}</div></div><div><br/></div><div>flag：INSA{Youre_sane_Good_for_you}</div><div><br/></div><div><span style="font-weight: bold;">147 [GUET-CTF2019]520的暗示</span></div><div><br/></div><div>下载得到photo.dat文件，十六进制查看，找不到常见格式的文件头，说明文件数据被加密或修改了。</div><div><img src="BUUCTF Misc 25（145-148）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>注意到头部前四个字节是CC EB CC D3，第一和第三个字节相同，联想到jpg格式的文件头FF D8 FF E0/E1。</div><div>那么来算一下异或：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>0xFF XOR 0x33 = 0xCC</div><div>0xD8 XOR 0x33 = 0xEB</div><div>0xE0 XOR 0x33 = 0xD3</div></div><div>另一方面，文件中出现了大量的字节33，这是原始文件中大量的00字节与0x33异或后得到的。</div><div>至此可以得出结论，这是一个jpg格式文件所有字节异或了0x33后得到的。写Python脚本异或回去：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('C:/Users/Administrator/Desktop/photo.dat', 'rb').read()</div><div>out = open('C:/Users/Administrator/Desktop/out.jpg', 'wb')</div><div>for i in range(len(f)):</div><div>    nb = f[i] ^ 0x33</div><div>    out.write(bytes([nb])) # 虽然还是不懂为什么要加方括号但是很好用</div><div>out.close()</div></div><div>得到图片：</div><div><img src="BUUCTF Misc 25（145-148）_files/out.jpg" type="image/jpeg" data-filename="out.jpg"/></div><div><a href="http://api.cellocation.com:81/cell.html">基站定位查询</a>，MCC460是中国，MNC01是联通，图片里的TAC相当于LAC，ECI相当于CELLID：</div><div><img src="BUUCTF Misc 25（145-148）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{桂林电子科技大学花江校区}</div><div><span style="font-weight: bold; color: rgb(255, 0, 0);">（我姑且猜测原题对flag内容是有提示或说明的……）</span></div><div><br/></div><div><span style="font-weight: bold;">148 [BSidesSF2019]table-tennis</span></div><div><br/></div><div>下载得到pcapng格式文件。wireshark打开，观察协议。排除掉DNS和暂时找不到线索的TCP和TLS，目前ICMP比较可疑。过滤icmp协议，逐个数据包查看。</div><div><img src="BUUCTF Misc 25（145-148）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>可以看到数据包长度都是98，request和reply交错出现，每一对的分组字节流内容都相同。</div><div>继续看分组字节流，每一对的分组字节流都是相同的6字节长度字符串重复五次。例如图中第一个ICMP协议包：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;html&gt;&lt;换行&gt;&lt;Tab&gt;&lt;html&gt;&lt;换行&gt;&lt;Tab&gt;&lt;html&gt;&lt;换行&gt;&lt;Tab&gt;&lt;html&gt;&lt;换行&gt;&lt;Tab&gt;&lt;html&gt;&lt;换行&gt;&lt;Tab&gt;</div></div><div>第三个ICMP协议包：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;head&gt;&lt;换行&gt;&lt;Tab&gt;&lt;head&gt;&lt;换行&gt;&lt;Tab&gt;&lt;head&gt;&lt;换行&gt;&lt;Tab&gt;&lt;head&gt;&lt;换行&gt;&lt;Tab&gt;&lt;head&gt;&lt;换行&gt;&lt;Tab&gt;</div></div><div>第五个ICMP协议包：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;title&gt; &lt;title&gt; &lt;title&gt; &lt;title&gt; &lt;title&gt;</div></div><div>大概能看出来，是把一个html文件每8位截断，然后重复5次，再一来一回发两个ICMP包。</div><div>抄一个Python脚本来提取数据：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from scapy.all import *</div><div><br/></div><div><br/></div><div>packets = rdpcap('attachment.pcapng') # rdpcap()读取pcapng文件</div><div>for packet in packets: # 遍历每一个数据包</div><div>    if packet.haslayer(ICMP): # haslayer()判断数据包的类型，此处为ICMP</div><div>        if packet[ICMP].type == 0: # 每一个ICMP的type值为0的包</div><div>            print(bytes.decode(packet[ICMP].load[-8:]), end = '') # 打印每个包最后8位，因为数据是重复的</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# python3 1.py &gt; 1.html</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;html&gt;</div><div>    &lt;head&gt;</div><div>    &lt;title&gt; I &lt;3 Corgi &lt;/title&gt;</div><div>        &lt;script&gt;</div><div>document.write(atob(&quot;<font color="#FF0000">Q1RGe0p1c3RBUzBuZ0FiMHV0UDFuZ1Awbmd9</font>&quot;));</div><div>        &lt;/script&gt;</div><div><br/></div><div>    &lt;/head&gt;</div><div><br/></div><div>    &lt;body&gt;</div><div><br/></div><div>        &lt;h1&gt; Woof!! &lt;/h1&gt;</div><div><br/></div><div>    &lt;/body&gt;</div><div><br/></div><div>&lt;/ht</div></div><div>注意到标红的一段，疑似base64密文。尝试base64解码，得到flag。</div><div><br/></div><div>flag：CTF{JustAS0ngAb0utP1ngP0ng}</div></span>
</div></body></html> 