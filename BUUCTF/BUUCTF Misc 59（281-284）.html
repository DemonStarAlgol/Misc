<html>
<head>
  <title>BUUCTF Misc 59（281-284）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="671"/>
<h1>BUUCTF Misc 59（281-284）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">281 [watevrCTF 2019]Hjärnknull</span></div><div><br/></div><div>下载得到hjarnknull.py和clarification，前者是靶机运行的脚本，其中定义了一个新语言Hjärnknull。根据后者说明，（大概是）需要通过nc命令远程连接靶机，根据Hjärnknull的八种函数，通过逐项输入函数名和参数，在服务器端生成一个程序。要求该程序能够根据服务器端的输入，完成加、减、乘三种运算，如果多次运算均正确，则返回flag。</div><div><br/></div><div>八种函数分别是：</div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 302px;"></col></colgroup><tbody><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">函数名</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">参数</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">效果</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">eller</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a b</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a = a | b</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">inte</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a = ~a</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">testa</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a b c</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">if a == b: c</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">poppa</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><br/></div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">stack.pop()</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">in</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a = input()</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">ut</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">print(a)</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">hsh</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a b</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a = a &gt;&gt; b</div></td></tr><tr><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">vsh</div></td><td style="vertical-align: middle; width: 130px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a b</div></td><td style="vertical-align: middle; width: 302px; padding: 8px; border: 1px solid;"><div style="text-align: center;">a = a &lt;&lt; b</div></td></tr></tbody></table><div><br/></div></div><div>从某种角度来说和brainfuck的思路有点类似，都是用八种操作（包括读写、对当前指针位置运算和移动指针等）来模拟图灵机，但与brainfuck的不同点在于brainfuck的八种操作不带有参数，而Hjärnknull的函数最多可带三个参数。</div><div><br/></div><div>本题超出能力范围，先记录一下Writeup：</div><div><a href="https://github.com/kjcolley7/CTF-WriteUps/tree/master/2019/watevr/Hjarnknull">https://github.com/kjcolley7/CTF-WriteUps/tree/master/2019/watevr/Hjarnknull</a></div><div><a href="https://ptr-yudai.hatenablog.com/entry/2019/12/16/062350#misc-337-Hj%C3%A4rnknull-7-solves">https://ptr-yudai.hatenablog.com/entry/2019/12/16/062350#misc-337-Hj%C3%A4rnknull-7-solves</a></div><div>（我用的是后一个Writeup的做法，从<a href="https://bitbucket.org/ptr-yudai/writeups/src/master/2019/watevrCTF_2019/hjarnknull/">这里</a>下载solve.py和asm.py，修改靶机地址，Linux下Python3运行即可。）</div><div><br/></div><div>flag：watevr{And_I_thought_brainfuck_was_a_hjÃ¤rnknull_jeez_youtube.com/watch?v=CAb_bCtKuXg}</div><div>BUUCTF上本题是动态flag，每次启动靶机flag都会改变。</div><div><br/></div><div><span style="font-weight: bold;">282 [Zer0pts2020]shredder</span></div><div>题目：I've accidentally removed an important file using a strong shredder. Can you restore the file from its core dump?</div><div><br/></div><div>下载得到core文件。根据题目，这是一个<a href="https://blog.csdn.net/mxrrr_sunshine/article/details/79928160">core dump（核心转储）</a>文件。通过file命令查看类型：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# file core</div><div>core: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from <font color="#FF0000">'./shredder document.pdf'</font>, real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: './shredder', platform: 'x86_64'</div></div><div>是用shredder命令删除某个pdf时生成的core dump文件。</div><div><br/></div><div>参考<a href="https://hackmd.io/@ptr-yudai/BkxQNgzrU">Writeup</a>。<span style="font-size: unset; color: unset; font-family: unset;">需要注意的是，用strings命令可以发现该core dump是在64位Ubuntu 18系统生成的。如果在其他的Linux系统下操作，需要另外</span><a href="https://buuoj.cn/resources" style="font-size: unset; font-family: unset;">下载</a><span style="font-size: unset; color: unset; font-family: unset;">libc-2.27.so文件。</span></div><div><br/></div><div>flag：zer0pts{3v3ryth1ng_1s_1n_ur_m3m0ry}</div><div><br/></div><div><span style="font-weight: bold;">283 [BSidesSF2020]earota</span></div><div><br/></div><div>下载得到mkv格式文件。视频内容来自Wolfram，展示了一种仅用0、1两种字符，但部分位实际为-1的三进制记数法。</div><div><img src="BUUCTF Misc 59（281-284）_files/Image.png" type="image/png" data-filename="Image.png" width="492"/></div><div><br/></div><div>用MKVToolNix将mkv文件中的flac音频提取：</div><div><img src="BUUCTF Misc 59（281-284）_files/Image [1].png" type="image/png" data-filename="Image.png" width="1018"/></div><div>提取出的音频是mka格式，用Goldwave打开：</div><div><img src="BUUCTF Misc 59（281-284）_files/Image [2].png" type="image/png" data-filename="Image.png" width="1136"/></div><div>可以看到有两条声道，但两条声道的波形几乎是完全一致的，理论上来说并无必要。尝试寻找两声道波形之间的差异。在Goldwave中选中单声道后，用 文件-将选择保存为 功能，将两条声道分别保存为1.wav和2.wav。</div><div>然后在Linux下用binwalk命令查看两个wav文件在字节上的差异：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# binwalk -W 1.wav 2.wav | head -n 40</div></div><div><img src="BUUCTF Misc 59（281-284）_files/Image [3].png" type="image/png" data-filename="Image.png" width="1191"/></div><div><br/></div><div>看似相同的波形实际上在字节层面存在大量差异。<span style="font-size: unset; color: unset; font-family: unset;">注意到以下特征：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">1、文件头、文件格式部分（前36个字节）是完全一致的，数据部分的数据头和长度（第37-40和第41-44个字节）也是完全一致的，差异全部出现在实际采样数据部分。实际上，如果要在两个wav音频之间的差异里隐藏信息，也不可能改动这几个部分。（wav格式音频文件的结构可以参考</span><a href="https://blog.csdn.net/BlueSoal/article/details/932395" style="font-size: unset; font-family: unset;">这篇文章</a><span style="font-size: unset; color: unset; font-family: unset;">，也可以用010Editor的模板功能查看。）</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">2、所有存在差异的字节，其差均为1（</span><span style="font-size: unset; color: unset; font-family: unset;">如果把 00 和 FF 也视为相差1）。区别在于有的字节 1.wav 比 2.wav 大1，有的字节则相反。换言之，也可以认为存在两种差，分别是1和-1。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">3、以两字节为一个单位，所有差异均出现在奇数位字节，除非出现 FF FF 和 00 00 的差异。由于这两个wav音频均为单声道16bit，其数据部分存储格式为每两个字节对应一次采样，且为小端序格式，因此，对比差异时应当以两个字节为单位进行比较，且 FF FF 和 00 00 比较时，应视作后者大1。</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">从第2条特征联想到，如果把不存在差异的字节也考虑进来，那么一共存在三种字节：相差1、相差0和相差-1。联想到视频内容展示的就是以1、0、-1组成的三进制记数法，这其中很可能隐藏有某种信息。写Python脚本提取差异数据：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>wav1 = open('C:/Users/Administrator/Desktop/1.wav', 'rb').read()[44:]</div><div>wav2 = open('C:/Users/Administrator/Desktop/2.wav', 'rb').read()[44:]</div><div><br/></div><div>diff = ''</div><div>for i in range(0, len(wav1), 2):</div><div>    w1 = wav1[i + 1] * 0x100 + wav1[i]</div><div>    w2 = wav2[i + 1] * 0x100 + wav2[i]</div><div>    d = (w2 - w1) % 0x10000</div><div>    if d == 0:</div><div>        diff += '0'</div><div>    elif d == 1:</div><div>        diff += '1'</div><div>    elif d == 0xFFFF:</div><div>        diff += '2'</div><div><br/></div><div>f = open('C:/Users/Administrator/Desktop/diff.txt', 'w')</div><div>f.write(diff)</div></div><div>输出结果的开头部分：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>00112221222020120110221012012210101020211010122020112122000201111000020211221022011022100201210011001110022010212010210101220001120200200101211021102002020012021100200220122002012121111112112202111012022202……（后略）</div></div><div><br/></div><div>接下来的问题是如何提取三进制数据中的信息。根据<a href="https://github.com/BSidesSF/ctf-2020-release/blob/master/earota/solution/solution.txt">官方Writeup</a>判断，输出结果实际就是一个三进制整数，将其转为十六进制后按字节保存为文件可以得到png格式图片。但官方给出的go程序无法运行，暂时也没看明白逻辑，先记录一下，以后再慢慢研究：</div><div><img src="BUUCTF Misc 59（281-284）_files/Image [4].png" type="image/png" data-filename="Image.png" width="824"/></div><div><br/></div><div>flag：CTF{one_iota_away_from_riches}</div><div><br/></div><div><span style="font-weight: bold;">284 [BSidesSF2020]open-sesame</span></div><div>题目：Can you crack the device password? I bet you can, cos' you rock! P.s, flag is not in CTF{} format. If you run into an error when running the avd, make sure the pixel_2 skin is available. Device image: <a href="https://storage.googleapis.com/bsides-sf-ctf-2020-attachments/avd.zip">https://storage.googleapis.com/bsides-sf-ctf-2020-attachments/avd.zip</a></div><div><br/></div><div>下载得到AVD（安卓虚拟设备，Android Virtual Device）镜像文件。根据题目要求，需要从中爆破出密码。新版本安卓系统的密码在 /data/system/<span style="font-size: unset; color: unset; font-family: unset;">gatekeeper.password.key 文件中，</span>以HMAC（哈希运算消息认证码，Hash-based Message Authentication Code）形式储存。</div><div><br/></div><div>参考Writeup：</div><div><a href="https://github.com/BSidesSF/ctf-2020-release/tree/master/open-sesame/solution">https://github.com/BSidesSF/ctf-2020-release/tree/master/open-sesame/solution</a></div><div><a href="https://medium.com/@itsc0rg1/challenge-writer-pov-bsidessf-2020-ctf-ea84980b8d79">https://medium.com/@itsc0rg1/challenge-writer-pov-bsidessf-2020-ctf-ea84980b8d79</a></div><div><br/></div><div>flag：lifeinchinatown</div></span>
</div></body></html> 