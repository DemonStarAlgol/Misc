<html>
<head>
  <title>BUUCTF Misc 44（221-224）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="855"/>
<h1>BUUCTF Misc 44（221-224）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="color: rgb(255, 0, 0); font-weight: bold;">221 [CFI-CTF 2018]Windows XP mem part 2</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">和213题同样情况，因为比赛官方在将赛题上传github时使用了Git LFS大文件扩展，所以github上的文件只有指针，实际的文件并没有被上传，使用git lfs clone时会提示服务器上找不到文件，导致下载不到真实的题目。BUUCTF上的附件下载下来也只有Git LFS指针，暂时找不到有效文件可以下载。</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">根据</span><a href="https://github.com/CFI-UL/2018-CFI-CTF/tree/master/windows_xp_mem_part2" style="color: rgb(255, 0, 0);">官方Writeup</a><span style="color: rgb(255, 0, 0);">，本题给出的是WinXP系统的内存镜像，需要用volatility的iehistory插件来查看IE浏览器的浏览记录。</span></div><div><span style="color: rgb(255, 0, 0);">等找到题目文件下载后再来做。</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">flag：CFI{H1kw3d_and_sp1ed_in_m3l@yu}</span></div><div><br/></div><div><span style="font-weight: bold;">222 [DDCTF2018]流量分析</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">提示一：若感觉在中间某个容易出错的步骤，若有需要检验是否正确时，可以比较MD5: 90c490781f9c320cd1ba671fcb112d1c</span></div><div>提示二：注意补齐私钥格式</div><div>-----BEGIN RSA PRIVATE KEY-----</div><div>XXXXXXX</div><div>-----END RSA PRIVATE KEY-----</div><div><br/></div><div>下载得到pcap格式文件，wireshark打开。首先查看协议，点击统计-协议分级：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image.png" type="image/png" data-filename="Image.png" width="1326"/></div><div>可以看到有ICMP、DNS、TLS、FTP等多种协议，其中字节百分比最大的是FTP Data。过滤ftp-data：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [1].png" type="image/png" data-filename="Image.png" width="1154"/></div><div>观察到全过程只用FTP下载了两个文件，Fl-g.zip和sqlmap.zip。sqlmap好像就是真的sqlmap，通过追踪TCP流-显示为原始数据的方式，将Fl-g.zip提取出来。发现这个压缩包不但是加密的，而且数据还有损坏。那么无论压缩包是不是关键，流量里必然还藏有其他线索。</div><div><br/></div><div>继续查看其他协议，注意到没有HTTP协议，只有TLS协议。结合提示里提到的私钥格式，很可能流量包中藏有TLS协议的解密私钥。首先过滤tls协议：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [2].png" type="image/png" data-filename="Image.png" width="534"/></div><div>数据交换发生在172.17.0.2和172.17.0.3之间。查看其他协议会发现172.17.0.2是本机，过滤172.17.0.3：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ip.src == 172.17.0.3</div></div><div><img src="BUUCTF Misc 44（221-224）_files/Image [3].png" type="image/png" data-filename="Image.png" width="838"/></div><div>发现了SMTP协议，是邮件。追踪一下TCP流：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [4].png" type="image/png" data-filename="Image.png" width="833"/></div><div>首先发现了一段邮件内容，=20是空格不用管，关注中间一段：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>=E4=BD=A0=E5=A5=BD=EF=BC=8C=E8=AF=B7=E4=BD=A0=E5=B0=86=E5=AF=86=E9=92=A5=E5=AE=89=E8=A3=85=E5=88=B0=E6=9C=8D=E5=8A=A1=E5=99=A8=E4=B8=8A=E3=80=82=E8=B0=A2=E8=B0=A2</div></div><div>离线状态的解码方法：去掉所有=号，以十六进制字节形式复制到十六进制编辑器，保存为txt格式，记事本打开：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>你好，请你将密钥安装到服务器上。谢谢</div></div><div>说明邮件里有密钥，往下翻一点：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [5].png" type="image/png" data-filename="Image.png" width="807"/></div><div>猜测这可能是密钥，但长度显然过长了，base64解码一下开头部分，发现是PNG格式文件头。将其转码为图片：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# base64 -d 1.txt &gt; 1.png</div></div><div><img src="BUUCTF Misc 44（221-224）_files/1.png" type="image/png" data-filename="1.png" width="1164"/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">所以要把这种东西转成文字？</span></div><div><br/></div><div>好吧我转好了，顺便还补齐了<span style="font-size: unset; color: unset; font-family: unset;">私钥格式：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>-----BEGIN RSA PRIVATE KEY-----</div><div>MIICXAIBAAKBgQDCm6vZmclJrVH1AAyGuCuSSZ8O+mIQiOUQCvN0HYbj8153JfSQ</div><div>LsJIhbRYS7+zZ1oXvPemWQDv/u/tzegt58q4ciNmcVnq1uKiygc6QOtvT7oiSTyO</div><div>vMX/q5iE2iClYUIHZEKX3BjjNDxrYvLQzPyGD1EY2DZIO6T45FNKYC2VDwIDAQAB</div><div>AoGAbtWUKUkx37lLfRq7B5sqjZVKdpBZe4tL0jg6cX5Djd3Uhk1inR9UXVNw4/y4</div><div>QGfzYqOn8+Cq7QSoBysHOeXSiPztW2cL09ktPgSlfTQyN6ELNGuiUOYnaTWYZpp/</div><div>QbRcZ/eHBulVQLlk5M6RVs9BLI9X08RAl7EcwumiRfWas6kCQQDvqC0dxl2wIjwN</div><div>czILcoWLig2c2u71Nev9DrWjWHU8eHDuzCJWvOUAHIrkexddWEK2VHd+F13GBCOQ</div><div>ZCM4prBjAkEAz+ENahsEjBE4+7H1HdIaw0+goe/45d6A2ewO/lYH6dDZTAzTW9z9</div><div>kzV8uz+Mmo5163/JtvwYQcKF39DJGGtqZQJBAKa18XR16fQ9TFL64EQwTQ+tYBzN</div><div>+04eTWQCmH3haeQ/0Cd9XyHBUveJ42Be8/jeDcIx7dGLxZKajHbEAfBFnAsCQGq1</div><div>AnbJ4Z6opJCGu+UP2c8SC8m0bhZJDelPRC8IKE28eB6SotgP61ZqaVmQ+HLJ1/wH</div><div>/5pfc3AmEyRdfyx6zwUCQCAH4SLJv/kprRz1a1gx8FR5tj4NeHEFFNEgq1gmiwmH</div><div>2STT5qZWzQFz8NRe+/otNOHBR2Xk4e8IS+ehIJ3TvyE=</div><div>-----END RSA PRIVATE KEY-----</div></div><div>保存为private.key，然后在wireshark-编辑-首选项-Protocols-TLS的RSA keys list中导入：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>再过滤http协议，发现有内容了：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>右键，随便追踪HTTP流或TLS流，找到flag。</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">所以一开始那个zip压缩包到底是干嘛用的？</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">结果提交时又发生了惊人的情况，原题好像又是个动态flag！</span></div><div>从下载到的附件里做出来的flag：DDCTF{0ca2d8642f90e10efd9092cd6a2831c0}</div><div>在某篇Writeup里找到的flag    ：DDCTF{efd2a79ae9ae5008694a3561fb55470e}</div><div>BUUCTF这么交才能答对的flag：flag{a84f90a4d00bcc4cca874a83ef4f84a6}</div><div><br/></div><div><span style="font-weight: bold;">223 [INSHack2019]Yet Another RSA Challenge - Part 2</span></div><div><br/></div><div>下载得到md格式文件和yarasc.py、output.txt。前者是题目说明：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>If not done already, you should probably attempt Part 1 of this challenge (in the Crypto category).</div></div><div><br/></div><div>先看yarsac.py：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import subprocess</div><div>p = subprocess.check_output('openssl prime -generate -bits 2048 -hex')</div><div>q = subprocess.check_output('openssl prime -generate -bits 2048 -hex')</div><div>flag = int('INSA{REDACTED}'.encode('hex'), 16)</div><div><br/></div><div>N = int(p,16) * int(q,16)</div><div>print N</div><div>print '0x'+p.replace('12','8D').replace('33','D4').replace('5E','FF').replace('09','95').replace('E4','38').replace('6B','89').replace('9E','E0').replace('59','3E')</div><div>print pow(flag,65537,N)</div></div><div>output.txt里是输出的三行内容。</div><div><br/></div><div>那么首先需要还原p。重点在于，例如12被替换成了8D，但替换后p中的8D不一定是12替换得来的。所以需要穷举每一种情形，并判断还原后的p是否质数。得到p<span style="font-size: unset; color: unset; font-family: unset;">后与N一起计算得到q，最后根据RSA算法计算flag。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from sympy.ntheory import isprime</div><div>from Crypto.Util.number import inverse, long_to_bytes</div><div>from collections import OrderedDict</div><div>from itertools import combinations</div><div><br/></div><div>def subsets(s):</div><div>    for cardinality in range(len(s) + 1):</div><div>        yield from combinations(s, cardinality)</div><div><br/></div><div>N = 737611163443959284842367849241210504758770468900963447745605275812981372405732262639464389012528980016931096127343933425531508977427016967370838523007185109804122827435442876112926896405911684006913203175001902528962659926046227042479405858100518975905360430463250839310857983177028295643515725251012428553651998860175968606629769294473365526541620801873942073999635165942812779333418405669820767884314938500537161124341967101209379749620814652441184505316661790048734950052497097493871158994129217835162546653468074537465326514182322892918918625260996455179683746164361293138705790829022424332601363202790350347639455664656064705450037947152881312491133191289211419037325704774394630500271194735028396494665835379325963853042514832498826985928063545989015763434053963155703531024791434836954197474393368464043648904368880777954234469571406476568488608818611878807321749318425353873416639028342088117081977903731238631252547599612554002863288409286756260496090170930084625283076970661877432107608911551414435036116940780849204521422482251640736907024303127956310763272428319732230450480696798568635499915064255846815425268220147645177869463315347549456623125597500648525429960478399391403082954189840918045663557930850169068717203841</div><div>c = 238625175560117519818219655160700093672765696917859228632607011580941239729981338983916209022919475382357227963405365905148115318257038277146986081479123834942285774969894504633426906629030480787741565635778433780362722138925014818166488253621790448543359319453495165651188539177460365420486442547806453231416816633460519873660432319115179116336907802631692806970121302821171652412917375895244055318035607411137420274957028058695317500603598525629698305540801857314426359129633709966978334387372229490871242813925900864337395540528999023305226494361061535292380487362207573111785857146840743150168595521892054972163853976096692431697845761601194595494668734667899627964699784309805348028825617943571577132154874260866191233001610717099049253716197026401372924319018736900888351182876610669592251724095719123094054432644034621312701246109838942945597240248959486831491623970160080568107285964593924238967189856179059372322390416530545895764941716546818701469100406503650604889258155970317233013903059065959366407802296924017896297385415541256814333380793132923243754142847186952683218437937882137950119347398825971468218656558007008879510066175287320907270138115038609371999806062759974181729622851705386276830651522840256814183961092</div><div>p = 'D78717E5C560636F461952384C67475479931C73E8573DE1658AD9828BA322DF497E2FC6042AE093EC7F194B47AF7E507CFF542F9085A0C526DC4B3B44D6FBEC4CA672FB2F75B56F151E5A103A1CBF6DB17611A6E6D1C054CE7A9D0A2170370E8AD349B98DFD984A6955B97AB7087AF81019C0F31456A6179DB47D2A240E307422D3F968193F8F239035640A357EBC4C3726DBF9935FF243AF8F0A4D458534381B38C3435AC0E61564BF79C7F808C38AB61F5DD2080EC2A2211AAFC17F8E89F99690278D494F1C8D1170C31442D1A8624EAE9938FB874962BBAE8915DA1943FC41B8D8CA675FE35FFD30B1CA5DF21E1BB0F9BC3C1F7CDC7E3E3E3AB834503D51'</div><div><br/></div><div>switches = [('12','8D'),('33','D4'),('5E','FF'),('09','95'),('E4','38'),('6B','89'),('9E','E0'),('59','3E')]</div><div>switches = OrderedDict(reversed(switches))</div><div><br/></div><div>possible = [p]</div><div>for sss in switches:</div><div>    news = []</div><div>    for x in possible:</div><div>        fc = [i for i in range(len(x)) if x[i:i+2] == switches[sss]]</div><div>        for sub in subsets(fc):</div><div>            y = x</div><div>            for i in sub:</div><div>                y = y[:i] + sss + y[i + 2:]</div><div>            u = int(y, 16)</div><div>            if N % u == 0:</div><div>                p = u</div><div>                q = N // p</div><div>                phi = (p - 1) * (q - 1)</div><div>                d = inverse(65537, phi)</div><div>                flag = long_to_bytes(pow(c, d, N))</div><div>                print(flag)</div><div>            if sss != '12':</div><div>                news.append(y)</div><div>    possible.extend(news)</div></div><div>因为是暴力穷举p的所有可能性，所以运行需要一段时间。最后输出：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>b'INSA{Uh_never_give_4w4y_your_Pr1mes_I_m34n_duhhh}'</div></div><div><br/></div><div>flag：INSA{Uh_never_give_4w4y_your_Pr1mes_I_m34n_duhhh}</div><div><br/></div><div><span style="font-weight: bold;">224 [*CTF2019]babyflash</span></div><div><br/></div><div>下载得到swf格式文件，播放后发现有黑白色块闪烁的同时伴随有类似信号的背景音。<span style="font-size: unset; color: unset; font-family: unset;">用JPEXS Free Flash Decompiler反编译，可以得到大量黑白纯色帧和一个音频。</span></div><div><img src="BUUCTF Misc 44（221-224）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>先看帧部分，将其导出为图片，共有441张，正好可以拼成21x21的正方形。</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>把文件名补足三位数字：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>然后用ImageMagick的montage命令来拼接图片：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop\flash\frames&gt;magick montage *png -tile 21x21 -geometry 101x101+0+0 out.png</div><div>*png：                   本目录下的png图片</div><div>-tile 21x21：            按纵向21块、横向21块拼成大图</div><div>-geometry 101x101+0+0：  单张图片大小是101x101</div><div>out.png：                输出文件名</div></div><div>得到二维码：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>扫码得到一半flag：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>*ctf{half_flag_&amp;</div></div><div><br/></div><div>然后看音频，导出得到mp3格式音频文件。audacity打开，切到频谱视图：</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：*ctf{half_flag_&amp;&amp;_the_rest}</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">此时又发生了一件惊人的事情，</span>因为该比赛的<a href="https://www.anquanke.com/post/id/177490">官方Writeup</a>在网页上的显示格式原因，_flag_被显示成了斜体的<span style="font-style: italic;">flag</span>。</div><div><img src="BUUCTF Misc 44（221-224）_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">从而如果直接复制这个flag作为“正确答案”，那么答案里的下划线_会缺失，提交正确flag反而会提示错误。</span></div><div>在BUUCTF上需要提交的：flag{halfflag&amp;&amp;_the_rest}</div></span>
</div></body></html> 