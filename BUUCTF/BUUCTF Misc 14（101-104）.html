<html>
<head>
  <title>BUUCTF Misc 14（101-104）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1636"/>
<h1>BUUCTF Misc 14（101-104）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">101 USB</span></div><div><br/></div><div>下载得到233.rar和key.ftm。先看233.rar，打开提示233.png文件头已损坏，只能看到flag.txt。十六进制编辑器查看：</div><div><img src="BUUCTF Misc 14（101-104）_files/Image.png" type="image/png" data-filename="Image.png" width="823"/></div><div>注意到233.png的文件块头部第三个字节为7A，代表子块，但这里233.png仅占一个文件块，应为文件块头74。</div><div>修复后正常解压出233.png，Stegsolve打开，在Blue plane 0处有二维码。</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [1].png" type="image/png" data-filename="Image.png" width="972"/></div><div>扫码得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ci{v3erf_0tygidv2_fc0}</div></div><div><br/></div><div>接下来看key.ftm。用foremost分离可以得到zip压缩包，或直接用7-Zip打开，解压得到key.pacp。wireshark打开可以看到全部数据均为USB协议，尝试后发现是USB键盘的输入数据流。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# python UsbKeyboardDataHacker-new.py key.pcap</div><div>Running as user &quot;root&quot; and group &quot;root&quot;. This could be dangerous.</div><div>[-] Unknow Key : 01</div><div>[-] Unknow Key : 01</div><div>[+] Found : aababacbbdbdccccdcdcdbbcccbcbbcbbaababaaaaaaaaaaaaaaaaaa<font color="#FF0000">key{xinan}</font></div></div><div>用xinan作为密钥，对二维码扫描结果进行维吉尼亚密码解密：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>fa{i3eei_0llgvgn2_sc0}</div></div><div>可以依稀看到flag等字母，尝试栅栏密码爆破：</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [2].png" type="image/png" data-filename="Image.png" width="882"/></div><div><br/></div><div>flag：flag{vig3ne2e_is_c00l}</div><div><br/></div><div><span style="font-weight: bold;">102 蜘蛛侠呀</span></div><div><br/></div><div>下载得到out.pcap，wireshark打开。可以发现HTTP协议找不到有效信息，反而有大量ICMP协议的包。</div><div>过滤icmp协议后逐项查看，找到如下线索：</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [3].png" type="image/png" data-filename="Image.png" width="1040"/></div><div>1、每个ICMP包的分组字节流开头都有8字节长的乱码，然后是字符串$$START$$；</div><div>2、按照时间顺序，每4个ICMP包在字符串$$START$$后接的内容是完全一致的；</div><div>3、开头4个包是-----BEGIN CERTIFICATE-----，结尾4个包是-----END CERTIFICATE-----；</div><div>4、除此以外的其他包，字符串$$START$$后接的内容都是类似base64密文的字符串。</div><div>以最初的27号包为例：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>UEsDBBQAAAAIAKmQTEwlsC84WTUNAK5GDQAIAAAAZmxhZy5naWZkvFdUE0zbBZpO</div></div><div><img src="BUUCTF Misc 14（101-104）_files/Image [4].png" type="image/png" data-filename="Image.png" width="1017"/></div><div>可以清楚看出这是一个zip压缩包的开头，且压缩包内还有名为flag.gif的文件。因此接下来要做的就是把ICMP包中的这些字符全部提取出来，并解码成zip压缩包。</div><div><br/></div><div>第一步，tshark提取数据。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# tshark -r out.pcap -T fields -e data &gt; out.txt</div></div><div><img src="BUUCTF Misc 14（101-104）_files/Image [5].png" type="image/png" data-filename="Image.png" width="1053"/></div><div>第二步，十六进制转码（用Notepad++之类的也行）。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>out = open('out.txt', 'rb').readlines()</div><div>out1 = open('out1.txt', 'wb')</div><div>for line in out:</div><div>    out1.write(line.strip().decode('hex'))</div><div>out1.close()</div></div><div><img src="BUUCTF Misc 14（101-104）_files/Image [6].png" type="image/png" data-filename="Image.png" width="1053"/></div><div>第三步，每隔四行提取一行，去掉开头的$$START$$，再去掉第一行和最后一行，最后拼接。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>out1 = open('out1.txt', 'r').readlines()</div><div>out2 = open('out2.txt', 'w')</div><div><br/></div><div>for i in range(4, len(out1) - 4, 4):</div><div>    str = out1[i][9:-1]</div><div>    out2.write(str)</div></div><div><img src="BUUCTF Misc 14（101-104）_files/Image [7].png" type="image/png" data-filename="Image.png" width="1053"/></div><div>第四步，转码为zip文件。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# cat out2.txt | base64 -d &gt; 1.zip</div></div><div><a href="BUUCTF Misc 14（101-104）_files/1.zip"><img src="BUUCTF Misc 14（101-104）_files/a4c63ed12091d35b2a0d1d443d2c54f6.png" alt="1.zip"></a></div><div>解压得到flag.gif。</div><div><br/></div><div>观察flag.gif，发现每帧的时长明显有差异。尝试用<a href="https://imagemagick.org/index.php">ImageMagick</a>的indentify命令提取信息：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;magick identify -format &quot;%T &quot; flag.gif</div><div>20 50 50 20 50 50 20 50 20 50 20 20 20 50 20 20 20 20 50 50 20 50 20 50 20 50 20 50 50 50 50 50 20 20 50 50 20 20 20 50 20 50 50 50 20 50 20 20 66 66</div></div><div>去掉末尾的66 66，正好48个，尝试每8个分组，则每组开头均为20。将20视为0，50视为1：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01101101 01000100 00110101 01011111 00110001 01110100</div></div><div>二进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>mD5_1t</div></div><div>按照题目说明，MD5加密得到flag。</div><div><br/></div><div>flag：flag{f0f1003afe4ae8ce4aa8e8487a8ab3b6}</div><div><br/></div><div><span style="font-weight: bold;">103 [WUSTCTF2020]爬</span></div><div><br/></div><div>下载得到文件“爬”，十六进制编辑器查看发现是pdf格式文件。</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [8].png" type="image/png" data-filename="Image.png" width="816"/></div><div>重命名后打开：</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [9].png" type="image/png" data-filename="Image.png" width="1108"/></div><div>提示flag被图片覆盖了，常规解法是用Photoshop打开这个pdf文件，移开上方的图片就能看到线索。但是没装Photoshop怎么办呢。</div><div>1、先用foremost提取出PDF里的图片。</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [10].png" type="image/png" data-filename="Image.png" width="728"/></div><div>2、十六进制编辑器分别打开这张jpg图片和原pdf文件，在pdf里找到jpg的十六进制部分。</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [11].png" type="image/png" data-filename="Image.png" width="828"/></div><div>3、删了。</div><div>再打开pdf文件就能看到被盖住的内容了。</div><div><img src="BUUCTF Misc 14（101-104）_files/Image [12].png" type="image/png" data-filename="Image.png" width="1108"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>'0x77637466323032307b746831735f31735f405f7064665f616e645f7930755f63616e5f7573655f70686f7430736830707d'</div></div><div>十六进制ASCII转码得到flag。</div><div><br/></div><div>flag：wctf2020{th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p}</div><div>（我就不用Photoshop你打我呀）</div><div><br/></div><div><span style="font-weight: bold;">104 [SWPU2019]Network</span></div><div><br/></div><div>下载得到txt格式文件，看一下前几行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>63</div><div>255</div><div>127</div><div>127</div><div>63</div><div>255</div><div>63</div><div>63</div><div>63</div><div>255</div><div>127</div><div>63</div><div>127</div><div>191</div><div>63</div><div>191</div></div><div>每行四种数字重复出现：63、127、191、255。注意到这是个等差数列，且+1后都是64的整倍数。</div><div>事实上，如果转换成二进制会更明显一些：00111111、01111111、10111111、11111111。</div><div>可以看出，后6位是相同的，仅前两位不同。如果把每个数字都替换成其二进制的前两位，然后再转成十六进制：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>s = open('C:/Users/Administrator/Desktop/attachment.txt', 'r').readlines()</div><div>res = open('C:/Users/Administrator/Desktop/res.txt', 'w')</div><div><br/></div><div>tmp = ''</div><div>for line in s:</div><div>    line = line.replace('\n', '')</div><div>    if line == '63':</div><div>        tmp += '00'</div><div>    if line == '127':</div><div>        tmp += '01'</div><div>    if line == '191':</div><div>        tmp += '10'</div><div>    if line == '255':</div><div>        tmp += '11'</div><div>    if len(tmp) == 8:</div><div>        tmp = int(tmp, 2)</div><div>        res.write(str(hex(tmp))[2:])</div><div>        tmp = ''</div><div>res.close()</div></div><div>输出结果的开头部分：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>35303462303330343134303030303038303830303839353037613466393036666……</div></div><div>再进行十六进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>504b030414000008080089507a4f906fc9fe8071010……</div></div><div>可以看出是zip格式压缩包的文件头，将其保存为zip文件，得到加密压缩包，实际上是伪加密。</div><div>ZipCenOp处理后直接解压得到flag.txt，开头内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVV……</div></div><div>显然是base64密文。base64解码大概29次之后得到flag。</div><div><br/></div><div>flag：flag{189ff9e5b743ae95f940a6ccc6dbd9ab}</div></span>
</div></body></html> 