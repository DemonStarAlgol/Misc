<html>
<head>
  <title>BUUCTF Misc 43（217-220）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="873"/>
<h1>BUUCTF Misc 43（217-220）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">217 [BJDCTF 2nd]提供暴打出题人服务</span></div><div><br/></div><div>下载得到address.txt和1.sol两个文件。仔细一看是区块链题，告辞！</div><div><br/></div><div>记录一下Writeup：</div><div><a href="https://blog.csdn.net/weixin_44017838/article/details/105056399">https://blog.csdn.net/weixin_44017838/article/details/105056399</a></div><div><a href="http://imagin.vip/?p=977">http://imagin.vip/?p=977</a></div><div><br/></div><div>flag：BJD{ReEntrancy_s0_fuck1ng_danger}</div><div><br/></div><div><span style="font-weight: bold;">218 [BSidesSF2020]toast-clicker1</span></div><div>题目：A fun toast clicker game for your enjoyment. While you are at it, can you find the first flag?</div><div><br/></div><div>下载得到apk格式文件……为什么又要把安卓逆向题放在Misc里啦。</div><div>jadx打开，找到MainActivity：</div><div><img src="BUUCTF Misc 43（217-220）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>根据运行逻辑到这段代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int[] input = {67, 83, 68, 120, 62, 109, 95, 90, 92, 112, 85, 73, 99, 82, 53, 99, 101, 92, 80, 89, 81, 104};</div><div>private BroadcastReceiver onDownloadComplete = new BroadcastReceiver() {</div><div>    public void onReceive(Context context, Intent intent) {</div><div>        if (MainActivity.this.downloadID == intent.getLongExtra(&quot;extra_download_id&quot;, -1)) {</div><div>            Toast.makeText(MainActivity.this, &quot;Pro download completed&quot;, 0).show();</div><div>            Log.d(&quot;Download&quot;, &quot;Completed&quot;);</div><div>            MainActivity.this.loadClass();</div><div>        }</div><div>    }</div><div>};</div></div><div>实际就是在生成flag。运行一下或者转写为Python代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>a = (67, 83, 68, 120, 62, 109, 95, 90, 92, 112, 85, 73, 99, 82, 53, 99, 101, 92, 80, 89, 81, 104)</div><div>for i in range(len(a)):</div><div>    print(chr(a[i] + i), end = '')</div></div><div>得到flag。</div><div><br/></div><div>flag：CTF{Bready_To_Crumble}</div><div><br/></div><div><span style="font-weight: bold;">219 [BSidesSF2020]mpfrag</span></div><div>题目：Was MPEG ever good?</div><div><br/></div><div>下载得到disk.bin文件。根据题目提示，直接重命名为.mp4，用KMPlayer可以播放。</div><div><img src="BUUCTF Misc 43（217-220）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>得到字符串，但这还不是flag。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SF-G0lden-Gl0w-1849</div></div><div>（正常做法下，应该用十六进制编辑器打开disk.bin，根据MPEG格式的文件头<span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: &quot;Microsoft YaHei&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">00 00 01 BA找到对应的文件块，再提取出来得到视频文件并播放。）</span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: &quot;Microsoft YaHei&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">将原始文件重命名回disk.bin，在Linux下查看文件类型：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# file disk.bin</div><div>disk.bin: Linux rev 1.0 ext2 filesystem data, UUID=07a34ef3-2282-447d-b2fd-1ade0b320153 (large files)</div></div><div>是ext2格式的文件系统镜像，尝试挂载：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# mount disk.bin ./mnt</div><div>mount: /root/Desktop/mnt: wrong fs type, bad option, bad superblock on /dev/loop0, missing codepage or helper program, or other error.</div></div><div>报错，给出了可能的错误原因，其中包括 /dev/loop0的超级块损坏。文件系统中8193块存储有超级块的备份数据，用dd命令来提取：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# dd if=disk.bin of=8193.bin bs=1024 skip=8193 count=1</div><div>if      infile，输入文件</div><div>of      outfile，输出文件</div><div>bs      bytes，设置输入/输出的块大小（以字节为单位）</div><div>skip    blocks，从输入文件开头跳过多少个块后开始复制，此处8193是因为超级块备份数据在8193块</div><div>count   只拷贝输入的blocks块</div><div><br/></div><div>记录了1+0 的读入</div><div>记录了1+0 的写出</div><div>1024 bytes (1.0 kB, 1.0 KiB) copied, 0.00131407 s, 779 kB/s</div></div><div>然后把提取出来的备份块放回disk.bin的超级块位置：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# dd if=8193.bin of=disk.bin bs=1024 conv=notrunc seek=1</div><div>conv=notrunc    不截短输出文件</div><div>seek=blocks     从输出文件开头跳过blocks个块后再开始复制</div><div><br/></div><div>记录了1+0 的读入</div><div>记录了1+0 的写出</div><div>1024 bytes (1.0 kB, 1.0 KiB) copied, 0.000921892 s, 1.1 MB/s</div></div><div>再次尝试挂载disk.bin，成功。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# mount disk.bin ./mnt</div><div>（取消挂载：root@kali:~/Desktop# umount ./mnt）</div></div><div>打开挂载文件夹，找到一些图片文件和cloud.zip。</div><div><img src="BUUCTF Misc 43（217-220）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>cloud.zip中包含加密的cloud_flag.jpg，密码即之前视频中得到的字符串。解压得到flag。</div><div><img src="BUUCTF Misc 43（217-220）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：CTF{bridge_ext2_gaps}</div><div><br/></div><div><span style="font-weight: bold;">220 [INSHack2019]Crunchy</span></div><div><br/></div><div>下载得到md格式文件和crunchy.py。前者是题目说明：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Trade 500 billion years of CPU time and 50 exabytes of RAM for a shiny flag : [crunchy]</div></div><div><br/></div><div>crunch.py内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def crunchy(n):</div><div>    if n &lt; 2: return n</div><div>    return 6 * crunchy(n - 1) + crunchy(n - 2)</div><div><br/></div><div>g = 17665922529512695488143524113273224470194093921285273353477875204196603230641896039854934719468650093602325707751568</div><div><br/></div><div>print(&quot;Your flag is: INSA{%d}&quot;%(crunchy(g)%100000007))</div></div><div>可以计算得到crunchy(x)的前几个值分别为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>crunchy(0) = 0</div><div>crunchy(1) = 1</div><div>crunchy(2) = 6 * 1 + 0 = 6</div><div>crunchy(3) = 6 * 6 + 1 = 37</div></div><div>实际上我们有：</div><div><img src="BUUCTF Misc 43（217-220）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>从而：</div><div><img src="BUUCTF Misc 43（217-220）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>又因为如果对数列crunchy(x)中的所有数都取模，不影响最终结果。因此可以采用带模运算的矩阵快速幂求解：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># 带模运算的矩阵乘法</div><div>def matrix_mul(A, B, n):</div><div>    C = [[0,0],[0,0]]</div><div>    for i in range(2):</div><div>        for j in range(2):</div><div>            for k in range(2):</div><div>                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % n</div><div>    return C</div><div><br/></div><div>n = 100000007</div><div># 矩阵快速幂运算</div><div>def matrix_pow(A, x):</div><div>    C = [[1,0],[0,1]]</div><div>    while x &gt; 0:</div><div>        if x &amp; 1:</div><div>            C = matrix_mul(C, A, n)</div><div>        A = matrix_mul(A, A, n)</div><div>        x //= 2</div><div>    return C</div><div><br/></div><div># 原始矩阵，C0和C1</div><div>origin = [[1,0],[0,0]]</div><div># 系数矩阵</div><div>coff = [[6,1],[1,0]]</div><div><br/></div><div>g = 17665922529512695488143524113273224470194093921285273353477875204196603230641896039854934719468650093602325707751568</div><div>COFF = matrix_pow(coff, g - 1)</div><div><br/></div><div>RES = matrix_mul(origin, COFF, n)</div><div>print(RES)</div></div><div>运行得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>[[41322239, 38066724], [0, 0]]</div></div><div>左上角的数41322239就是 crunchy(g)%100000007 的结果。</div><div><br/></div><div>flag：INSA{41322239}</div></span>
</div></body></html> 