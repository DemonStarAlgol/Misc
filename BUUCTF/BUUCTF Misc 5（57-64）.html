<html>
<head>
  <title>BUUCTF Misc 5（57-64）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1748"/>
<h1>BUUCTF Misc 5（57-64）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">57 [ACTF新生赛2020]outguess</span></div><div><br/></div><div>下载得到tmp文件夹。内含huhuhu.zip和huhuhu文件夹。</div><div>huhuhu.zip中有加密的flag.txt和未加密的mmm.jpg。huhuhu文件夹中有flag.txt（内无flag）和mmm.jpg。</div><div>从题目和提示来看，首先需要利用outguess工具提取图片中的隐写信息。</div><div><br/></div><div>先看mmm.jpg的EXIF信息：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><a href="http://www.atoolbox.net/Tool.php?Id=850">社会主义核心价值观解密</a>得到：abc。作为outguess的密码提取mmm.jpg中的信息。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# outguess -k abc -r mmm.jpg out.txt</div><div>Reading mmm.jpg....</div><div>Extracting usable bits:   17550 bits</div><div>Steg retrieve: seed: 93, len: 23</div></div><div>out.txt中直接得到了flag。</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">这时候回头再看最初的压缩包huhuhu.zip，可以发现其中的flag.txt其实是伪加密。说明题目原意是仅给出这个压缩包，去除伪加密后解压得到huhuhu文件夹，再按上述步骤解题。可能是附件放错，直接把解压后的文件夹也一起提供了。</span></div><div><br/></div><div>flag：ACTF{gue33_Gu3Ss!2020}</div><div><br/></div><div><span style="font-weight: bold;">58 [BJDCTF2020]纳尼</span></div><div><br/></div><div>下载得到损坏的6.gif文件。十六进制编辑器打开，发现缺少文件头。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>补充文件头47 49 46 38，修复文件。GIFFrame打开可见有4帧，每帧都有一段文字：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>拼接得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0=</div></div><div>base64解码得到flag。</div><div><br/></div><div>flag：CTF{wang_bao_qiang_is_sad}</div><div><br/></div><div><span style="font-weight: bold;">59 Mysterious</span></div><div><br/></div><div>下载得到exe文件，IDA打开。Shift+F12查看字符串，注意到well done，可能是输入正确时的提示。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>跟踪这一字符串找到函数，F5转成伪代码：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>输入字符串，其长度不能大于6。且该字符串转整形数字后再+1等于123，v12、v13、v14分别为'x'、'y'和'z'（在120、121和122上右键选择“Char”转为字符）。因此该字符串应为“122xyz”。</div><div>运行exe，输入字符串，得到flag。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{123_Buff3r_0v3rf|0w}</div><div>大哥这是Reverse题吧？</div><div><br/></div><div><span style="font-weight: bold;">60 sqltest</span></div><div><br/></div><div>下载得到pcapng文件，wireshark打开。注意到http协议流量包中有大量类似SQL注入payload的URL。导出HTTP对象：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>可以明显看出，是通过二分法进行SQL注入，获取数据库中某个值的过程。具体获取值的部分从6276号包开始。</div><div><br/></div><div>以flag值的第一位为例。位数即URL括号内的倒数第二个参数，%20（=空格）<span style="color: rgb(255, 0, 0);">1</span>：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>可以看出返回文件的大小中，848 bytes为正确，780 bytes为错误。根据上一次判定的正误，不断采取二分法判断第一位字符的ASCII值的大小。最终得到该ASCII值大于101，但不大于102，即值为102。</div><div><br/></div><div>以此类推，flag值各位的ASCII值依次为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>102 108 97 103 123 52 55 101 100 98 56 51 48 48 101 100 53 102 57 98 50 56 102 99 53 52 98 48 100 48 57 101 99 100 101 102 55 125</div></div><div>ASCII转码得到flag。</div><div><br/></div><div>flag：flag{47edb8300ed5f9b28fc54b0d09ecdef7}</div><div><br/></div><div><span style="font-weight: bold;">61 谁赢了比赛？</span></div><div><br/></div><div>下载得到png格式文件，十六进制编辑器打开，发现文件尾后有RAR压缩包，将其提取。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>flag.txt中无可用信息，尝试爆破hehe.gif的解压密码。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>解压得到hehe.gif，GIFFrame打开，逐帧查看，发现第309帧比较可疑：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>将该帧导出，Stegsolve打开，在Red plane 0处找到二维码：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>扫码得到flag。</div><div><br/></div><div>flag：flag{shanxiajingwu_won_the_game}</div><div><br/></div><div><span style="font-weight: bold;">62 喵喵喵</span></div><div><br/></div><div>下载得到mmm.png。Stegsolve打开，在Red/Green/Blue plane 0处可以发现很明显的LSB隐写痕迹。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>用Data Extract功能尝试，在Red 0、Green 0、Blue 0和BGR顺序下可以得到PNG图片。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>导出，得到如下PNG图像。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>010Editor打开或在Linux下查看，会提示CRC错误，修改高度（虽然没有必要，但正确值为280）：</div><div><img src="BUUCTF Misc 5（57-64）_files/1.png" type="image/png" data-filename="1.png"/></div><div>显然是反色的二维码，扫码得到：<a href="https://pan.baidu.com/s/1pLT2J4f">https://pan.baidu.com/s/1pLT2J4f</a>。</div><div><br/></div><div>从该地址下载得到flag.rar，解压得到flag.txt，其中并无信息。NTFSInfo查看NTFS流，找到flag.pyc。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>反编译flag.pyc：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;uncompyle6 -o flag.py flag.pyc</div><div>flag.pyc --</div><div># Successfully decompiled file</div></div><div>得到flag.py：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import base64</div><div><br/></div><div>def encode():</div><div>    flag = '*************'</div><div>    ciphertext = []</div><div>    for i in range(len(flag)):</div><div>        s = chr(i ^ ord(flag[i]))</div><div>        if i % 2 == 0:</div><div>            s = ord(s) + 10</div><div>        else:</div><div>            s = ord(s) - 10</div><div>        ciphertext.append(str(s))</div><div>    return ciphertext[::-1]</div><div><br/></div><div>ciphertext = [</div><div>'96', '65', '93', '123', '91', '97', '22', '93', '70', '102', '94', '132', '46', '112', '64', '97', '88', '80', '82', '137', '90', '109', '99', '112']</div></div><div>加密过程如下：<span style="font-size: unset; color: unset; font-family: unset;">对flag的每一位，先和位数异或，然后偶数位+10，奇数位-10，最后倒序输出。</span></div><div>写出解密脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>c = ['96', '65', '93', '123', '91', '97', '22', '93', '70', '102', '94', '132', '46', '112', '64', '97', '88', '80', '82', '137', '90', '109', '99', '112']</div><div>c = c[::-1]</div><div><br/></div><div>for i in range(len(c)):</div><div>    s = int(c[i])</div><div>    if i % 2 == 0:</div><div>        s -= 10</div><div>    else:</div><div>        s += 10</div><div>    print(chr(s ^ i), end = '')</div></div><div>输出得到flag。</div><div><br/></div><div>flag：flag{Y@e_Cl3veR_C1Ever!}</div><div><br/></div><div><span style="font-weight: bold;">63 [BJDCTF 2nd]TARGZ-y1ng</span></div><div><br/></div><div>下载得到hW1ES89jF.tar.gz，是加密压缩包。根据题目提示，解压密码不需要爆破，尝试hW1ES89jF为密码，解压成功。<span style="font-size: unset; color: unset; font-family: unset;">解压得到OKMIlLVft.tar.gz，也是加密压缩包，尝试发现密码也是OKMIlLVft。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">从而猜测每个加密tar.gz压缩包的密码都是文件名。写一段脚本循环解压：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import zipfile</div><div><br/></div><div>path = 'C:/Users/Administrator/Desktop/zip/' # 工作文件夹</div><div>name = 'hW1ES89jF' # 起始压缩包名</div><div>while True:</div><div>    zipname = path + name + '.tar.gz' # 生成完整的待解压压缩包名</div><div>    print(name)</div><div>    ts1 = zipfile.ZipFile(zipname)</div><div>    password = bytes(name, 'utf-8') # 解压密码就是文件名</div><div>    ts1.extractall(path, pwd = password) # 解压得到下一个压缩包</div><div>    name = ts1.namelist()[0].split('.')[0] # 读取压缩包内的下一个压缩包的文件名，以供下一个循环使用</div></div><div>运行脚本，直到出现文件名为flag后报错：</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div>以文本形式打开flag文件，得到flag。</div><div><br/></div><div>flag：BJD{wow_you_can_rea11y_dance}</div><div><br/></div><div><span style="font-weight: bold;">64 [GXYCTF2019]gakki</span></div><div><br/></div><div>下载得到wolaopo.jpg文件。十六进制编辑器打开，提取出文件尾后的RAR压缩包，尝试4位数字爆破密码。</div><div><img src="BUUCTF Misc 5（57-64）_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>解压得到flag.txt，内含大量无规律字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#2V0VI_05X$GygD3*g@gYurMGim#1=)D_@Z(JcRevlyGq&amp;N-dgPH8XXSGL{@9}zVmlmxv</div><div>……</div></div><div>尝试一下字频统计：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from collections import Counter</div><div><br/></div><div>c = open('C:/Users/Administrator/Desktop/flag.txt').read()</div><div>c = Counter(c)</div><div>print(c.most_common())</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>[('G', 2508), ('X', 2481), ('Y', 2453), ('{', 2301), ('g', 2221), ('a', 2087), ('k', 1981), ('i', 1797), ('_', 1531), ('I', 1448), ('s', 1402), ('M', 1398), ('y', 1389), ('w', 1386), ('1', 1376), ('f', 1373), ('e', 1372), ('}', 1264), ('D', 1164), ('A', 1164), ('Q', 1163), ('O', 1163), ('W', 1163), ('J', 1162), ('H', 1161), ('N', 1160), ('S', 1160), ('E', 1160), ('K', 1160), ('U', 1160), ('P', 1159), ('*', 1158), ('Z', 1158), ('&amp;', 1158), ('8', 1158), ('#', 1157), ('2', 1157), ('9', 1157), ('4', 1157), ('B', 1157), ('C', 1157), ('%', 1157), ('^', 1157), ('V', 1156), ('$', 1156), ('3', 1156), ('@', 1156), (')', 1156), ('(', 1156), ('R', 1156), ('-', 1156), ('F', 1156), ('T', 1156), ('0', 1155), ('5', 1155), ('=', 1155), ('L', 1155), ('7', 1155), ('6', 1155), ('o', 1151), ('h', 1151), ('q', 1150), ('d', 1148), ('u', 1147), ('j', 1146), ('l', 1144), ('m', 1143), ('c', 1143), ('z', 1143), ('x', 1143), ('n', 1143), ('p', 1143), ('b', 1142), ('v', 1141), ('t', 1141), ('r', 1140), ('!', 1058), ('[', 4), (';', 3), (',', 3), ('.', 1), (' ', 1), (&quot;'&quot;, 1)]</div></div><div>按顺序输出一下高频字符：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>c = c.most_common()</div><div>for i in range(len(c)):</div><div>    print(c[i][0], end = '')</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#FF0000">GXY{gaki_IsMyw1fe}</font>DAQOWJHNSEKUP*Z&amp;8#294BC%^V$3@)(R-FT05=L76ohqdujlmczxnpbvtr![;,. '</div></div><div><br/></div><div>flag：GXY{gaki_IsMyw1fe}</div></span>
</div></body></html> 