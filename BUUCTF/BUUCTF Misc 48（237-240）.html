<html>
<head>
  <title>BUUCTF Misc 48（237-240）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="819"/>
<h1>BUUCTF Misc 48（237-240）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">237 [BSidesSF2020]toast-clicker2</span></div><div><br/></div><div>下载得到apk格式文件……为什么要把安卓逆向题放在Misc里啦x5。</div><div><br/></div><div>大体思路是，在com.ctf.toast.MainActivity中找到以下代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public String printSecondFlag() {</div><div>    String keyPart2 = getString(R.string.key_part2);</div><div>    try {</div><div>        return new helper(BuildConfig.KEY_PART1 + keyPart2 + keyStringFromJNI()).decrypt(encryptedStringFromJNI());</div><div>    } catch (Exception e) {</div><div>        e.printStackTrace();</div><div>        return BuildConfig.FLAVOR;</div><div>    }</div><div>}</div></div><div>用三段字符串组成了key，然后作为密钥解密另一个字符串。只要找到四段字符串和解密函数helper就能得出结果。</div><div><br/></div><div>BuildConfig.KEY_PART1在com.ctf.toast.BuildConfig里：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static final String KEY_PART1 = &quot;742375c48a7&quot;</div></div><div>R.string.key_part2在/resources.arsc/res/values/strings.xml里：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;string name=&quot;key_part2&quot;&gt;0da605b16&lt;/string&gt;</div></div><div>keyStringFromJNI()在Native层……只能看<a href="https://ctftime.org/writeup/18524">Writeup</a>了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>34 39 63 39 62 37 31 31 38 65 36 31</div><div>49c9b7118e61</div></div><div>从而得到完整的key：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>742375c48a70da605b1649c9b7118e61</div></div><div><br/></div><div>encryptedStringFromJNI()同样在Native层：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>MwDxTPEvfSLms0PVdgxjYwgpgN8Y8Xj3Hrkw9pFkV6o=</div></div><div>helper函数在com.ctf.toast.helper：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class helper {</div><div>    private Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);</div><div>    private SecretKeySpec key = initKey();</div><div>    private String passphrase;</div><div><br/></div><div>    public helper(String passphrase2) throws Exception {</div><div>        this.passphrase = passphrase2;</div><div>    }</div><div><br/></div><div>    public SecretKeySpec initKey() throws Exception {</div><div>        return new SecretKeySpec(Arrays.copyOf(MessageDigest.getInstance(&quot;SHA-1&quot;).digest(this.passphrase.getBytes(&quot;UTF-8&quot;)), 16), &quot;AES&quot;);</div><div>    }</div><div><br/></div><div>    public String encrypt(String plaintext) throws Exception {</div><div>        byte[] plaintextBytes = plaintext.getBytes();</div><div>        this.cipher.init(1, this.key);</div><div>        return Base64.encodeToString(this.cipher.doFinal(plaintextBytes), 2);</div><div>    }</div><div><br/></div><div>    public String decrypt(String ciphertext) throws Exception {</div><div>        byte[] ciphertextBytes = Base64.decode(ciphertext.getBytes(), 2);</div><div>        this.cipher.init(2, this.key);</div><div>        return new String(this.cipher.doFinal(ciphertextBytes), &quot;UTF-8&quot;);</div><div>    }</div><div>}</div></div><div>很明显是ECB模式的AES加解密，密钥为SHA-1形式。</div><div><br/></div><div>已知密钥和密文，用Python脚本来解密：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import hashlib</div><div>import base64</div><div><br/></div><div>from Crypto.Cipher.AES import MODE_ECB</div><div>from Crypto.Cipher import AES</div><div><br/></div><div>key = b'742375c48a70da605b1649c9b7118e61'</div><div>cipher = base64.b64decode('MwDxTPEvfSLms0PVdgxjYwgpgN8Y8Xj3Hrkw9pFkV6o=')</div><div>aes = AES.new(hashlib.sha1(key).digest()[:16], MODE_ECB)</div><div>print(aes.decrypt(cipher))</div></div><div>输出：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>b'CTF{T00_Many_S3cr3t5}\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b'</div></div><div><br/></div><div>flag：CTF{T00_Many_S3cr3t5}</div><div><br/></div><div><span style="font-weight: bold;">238 [BSidesSF2020]toast-clicker3</span></div><div><br/></div><div>下载得到apk格式文件……为什么要把安卓逆向题放在Misc里啦x6，而且一个apk还出了三道题。</div><div><br/></div><div>jadx打开，在com.ctf.toast.MainActivity里找到这段代码：</div><div><img src="BUUCTF Misc 48（237-240）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void loadClass() {</div><div>    try {</div><div>        Class&lt;?&gt; loadedClass = new DexClassLoader(Uri.fromFile(new File(getExternalFilesDir((String) null), &quot;<font color="#FF0000">bacon-final.dex</font>&quot;)).toString(), (String) null, (String) null, ClassLoader.getSystemClassLoader().getParent()).loadClass(&quot;bacon.ToastDynamicFlag&quot;);</div><div>        Object obj = loadedClass.newInstance();</div><div>        String str = (String) loadedClass.getMethod(&quot;<font color="#FF0000">printThirdFlag</font>&quot;, new Class[]{String.class, String.class}).invoke(obj, new Object[]{<font color="#FF0000">&quot;ijiijiiijjjjjijijijiiijjijjjji&quot;, &quot;jjjiiiiijjjijijijjijiijji&quot;</font>});</div><div>    } catch (ClassNotFoundException e) {</div><div>        e.printStackTrace();</div><div>    } catch (InstantiationException e2) {</div><div>        e2.printStackTrace();</div><div>    } catch (IllegalAccessException e3) {</div><div>        e3.printStackTrace();</div><div>    } catch (NoSuchMethodException e4) {</div><div>        e4.printStackTrace();</div><div>    } catch (IllegalArgumentException e5) {</div><div>        e5.printStackTrace();</div><div>    } catch (InvocationTargetException e6) {</div><div>        e6.printStackTrace();</div><div>    }</div><div>}</div></div><div>根据前两题的经验，看到printThirdFlag，说明和第三个flag有关。同时注意到代码里的bacon-final.dex，搜索这段文本，找到另一段代码：</div><div><img src="BUUCTF Misc 48（237-240）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>DownloadManager.Request request = new DownloadManager.Request(Uri.parse(&quot;https://storage.googleapis.com/bsides-sf-ctf-2020-attachments/bacon-final.dex&quot;));</div></div><div>大概是说该dex文件是从这个URL下载到的，那么就去访问这个URL把文件下载来看看。</div><div><a href="BUUCTF Misc 48（237-240）_files/bacon-final.dex"><img src="BUUCTF Misc 48（237-240）_files/8738e61805d1fc774fd7bb2156ce86c3.png" alt="bacon-final.dex"></a></div><div><br/></div><div>用jadx打开，发现里面只有一个类bacon.ToastDynamicFlag：</div><div><img src="BUUCTF Misc 48（237-240）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>可以看到decode_map函数和encode_map函数的内容是把a-z的小写字母与五位i和j组成的字符串进行替换，类似于培根密码。同时该类里给出了一段由i和j组成的flagPart3，联想到之前的loadClass中也有两段类似的字符串。猜测将这三段字符串按照decode_map进行解密就能得到flag。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def rep(rawstr, dict_rep):</div><div>    for i in dict_rep:</div><div>        rawstr = rawstr.replace(i, dict_rep[i])</div><div>    return rawstr</div><div><br/></div><div>p1 = 'ijiij iiijj jjjij ijiji iijji jjjji '</div><div>p2 = 'jjjii iiijj jijij ijjij iijji '</div><div>p3 = 'jiiji iiijj iijji jijij iiijj jjjij jjjjj iiiii '</div><div>dic = {'iiijj ':'a', 'jjjii ':'b', 'jijij ':'c', 'jjijj ':'d', 'jjjjj ':'e', 'ijjjj ':'f', 'jjjji ':'g', 'iijii ':'h', 'ijiji ':'i', 'iiiji ':'j', 'jjjij ':'k', 'jijji ':'l', 'ijiij ':'m', 'iijji ':'n', 'ijjij ':'o', 'jiiji ':'p', 'ijijj ':'q', 'jijii ':'r', 'iiiii ':'s', 'jjiij ':'t', 'ijjji ':'u', 'jiiij ':'v', 'iiiij ':'w', 'iijij ':'x', 'jjiji ':'y', 'jijjj ':'z'}</div><div><br/></div><div>print(rep(p1 + p2 + p3, dic))</div></div><div>输出：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>makingbaconpancakes</div></div><div><br/></div><div>flag：CTF{makingbaconpancakes}</div><div><br/></div><div><span style="font-weight: bold;">239 [b01lers2020]minecraft_purdue</span></div><div><br/></div><div>下载得到W0rldF1le.zip，解压得到Minecraft的世界数据，将文件夹放到Minecraft对应目录下，进入游戏。</div><div><img src="BUUCTF Misc 48（237-240）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>进游戏后天黑黑的还在下雨，视野内什么都没有。因为是作弊模式所以输入/gamemode 1 [玩家名字]可以切换到创造模式。然后就不会玩了……总之抄一下<a href="https://github.com/b01lers/b01lers-ctf-2020/blob/master/misc/minecraft_purdue/writeup.md">Writeup</a>：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1. The user has to look at the map after they spawn and see that there is a replica of Purdue.</div><div>2. Then they have to recon to see which building b01lers makes and competitors in CTF's.</div><div>3. After they will have to find HAAS in game where they will see the flag on the ground</div></div><div><br/></div><div>flag：pctf{M1NE}</div><div><br/></div><div><span style="font-weight: bold;">240 [b01lers2020]image_adjustments</span></div><div><br/></div><div>下载得到png格式文件。大小1500x200，内容是一些红色和黑色的竖线。</div><div><img src="BUUCTF Misc 48（237-240）_files/attachment.png" type="image/png" data-filename="attachment.png"/></div><div>其他常见隐写方式都无法得到线索，从图片本身内容入手。仔细观察可以发现规律：所有的红色竖线的长度都相等（除了图片最右边的一段以外），且每一列中只有一段红色竖线。猜测红线竖线可能是定位点，尝试把每一列进行移位，直到每一列的红色竖线在水平方向上处于同一位置。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/attachment.png')</div><div>x, y = img.size</div><div><br/></div><div>pixel = img.load()</div><div>for r in range(x):</div><div>    column = []</div><div>    for c in range(y):</div><div>        column += [pixel[r, c]] # 取得每一列的像素并存入column列表</div><div>    done = False</div><div>    for i in range(y):</div><div>        if done:</div><div>            break</div><div>        for c in range(y):</div><div>            pixel[r, (c + i) % y] = column[c] # 在原图高度的范围内对每一列像素进行移位</div><div>            if (pixel[r, 0] == (255, 0, 0, 255) and pixel[r, 199] == (255, 255, 255, 255)):</div><div>                # 如果满足该列开头像素为红色，且末尾像素为白色，认为该列移位完成</div><div>                done = True</div><div><br/></div><div>img.save('C:/Users/Administrator/Desktop/res.png')</div></div><div><br/></div><div><img src="BUUCTF Misc 48（237-240）_files/res.png" type="image/png" data-filename="res.png"/></div><div>因为最右边一段的红色竖线长度不同，所以列移位完成的定位条件可能需要多次尝试，例如上方对齐或下方对齐。最后以上方对齐的条件获得了正确结果。</div><div><br/></div><div>flag：flag{ShuFfLiNg_Fl4gs}</div></span>
</div></body></html> 