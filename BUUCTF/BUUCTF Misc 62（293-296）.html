<html>
<head>
  <title>BUUCTF Misc 62（293-296）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="636"/>
<h1>BUUCTF Misc 62（293-296）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div><span><div><span style="font-weight: bold;">293 [INSHack2018]On Whose Authority</span></div><div><br/></div><div>下载得到md格式文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>This is an on-site challenge. Join us!</div><div>A Raspberry Pi is connected to a wifi network. There is a big &quot;ON WHOSE AUTHORITY?!?&quot; sign nearby. The whole setup seems pretty shady.</div></div><div><br/></div><div>这是一道现场题……总之也只能记录一下Writeup了：</div><div><a href="https://github.com/seclib/inshack-2018/blob/master/network/on-whose-authority/writeup.md">https://github.com/seclib/inshack-2018/blob/master/network/on-whose-authority/writeup.md</a></div><div><br/></div><div>flag：INSA{2f272cd8e3f6d2e26cd4c9c09a0d530c322cc572b80fa473e30c4be6d14395d6}</div><div><br/></div><div><span style="font-weight: bold;">294 [INSHack2018]INSA Access Control</span></div><div><br/></div><div>下载得到md格式文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>This is an on-site challenge. Join us!</div><div>What allowed you to stay here?</div></div><div><br/></div><div>又是一道现场题……先记录一下Writeup：</div><div><a href="https://github.com/seclib/inshack-2018/blob/master/misc/insa-access-control/writeup.md">https://github.com/seclib/inshack-2018/blob/master/misc/insa-access-control/writeup.md</a></div><div>好像也用不着Writeup……现场队伍直接看徽章，大概上面就写着flag。而且本题对现场队伍是0分。</div><div><br/></div><div>flag：INSA{3ba90bbe5f985118}</div><div><br/></div><div><span style="font-weight: bold;">295 黑科技</span></div><div>题目：<span style="font-size: unset; color: unset; font-family: unset;">据说国外有黑科技可以通过振动还原声音，要不大家也试试？已知framerate=48000, nframes=1194240</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">下载得到png格式文件：</span></div><div><img src="BUUCTF Misc 62（293-296）_files/flag.png" type="image/png" data-filename="flag.png" width="2400"/><br/></div><div>是一段声音的波形图。</div><div><br/></div><div>本题需要读取图片像素信息，得到各个点的坐标，然后根据给出的参数逆向还原为波形文件。通过搜索可以确定这张波形图是通过<a href="https://docs.huihoo.com/scipy/scipy-zh-cn/index.html">《用Python做科学计算》</a>实战篇<a href="https://docs.huihoo.com/scipy/scipy-zh-cn/wave_pyaudio.html#id2">“读Wave文件”一节</a>中的脚本生成的。</div><div><br/></div><div>尝试后发现本题的难点在于，波形图失真过于严重，损失信息较多，不可能完整地还原为波形文件。而波形文件的特征决定了即使得到一个在整体形状上较为相似的波形，其声音也很可能与原始音频相差极大。要还原出原始波形音频中附带的信息，必须在还原波形整体形状的基础上，确保波形的“音色”也与原始音频来源（很可能是人声）一致，否则用简单的正弦波或方形波来拟合整体形状得到的依然是噪声或信号音。</div><div>当然容易想到还有一种方法，即通过波形的形状特征来猜测原始音频内容，假定原始音频（或至少后半部分）的内容是逐字念出flag，那么可以确定20秒后的第一个字符是F(/ɛf/)，因为其/ɛ/音较重而/f/音较轻的特征非常明显。但该方法也无法还原出所有信息，例如，D(/ˈdiː/)和E(/ˈiː/)在波形图上的形状几乎是完全一样的。</div><div>因此本题暂时放弃，若有哪位知道解法，还请不吝赐教。</div><div><br/></div><div>2021.10.24 可能是因为日子比较吉利，通过[过于奇妙，不予展示]获得了flag。而且我肉眼看出来的f形状真的是f，就很奇妙。</div><div><br/></div><div>flag：[过于奇妙，不予展示]，</div><div><br/></div><div><span style="font-weight: bold;">296 洞拐洞拐洞洞拐</span></div><div><br/></div><div>下载得到png格式文件：</div><div><img src="BUUCTF Misc 62（293-296）_files/2239f085-4e8c-425b-9e8e-793c982c42f5.png" type="image/png" data-filename="2239f085-4e8c-425b-9e8e-793c982c42f5.png" width="320"/><br/></div><div>宽高均为320像素，仅由黑白两种像素组成。</div><div><br/></div><div>尝试以黑色为1，白色为0，转为二进制数据：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/0707007.png')</div><div>data = ''</div><div><br/></div><div>for i in range(320):</div><div>    for j in range(320):</div><div>        p = img.getpixel((i, j))</div><div>        if p == (255, 255, 255):</div><div>            data += '0'</div><div>        elif p == (0, 0, 0):</div><div>            data += '1'</div><div>print(data)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>0011010100110010001101000011100100110100001101100011010000110110010001100100001100110001001110000011000</div><div>……（后略）</div></div><div>观察结果可以发现，如果每8位分组，每组的开头数字似乎都是0，考虑每8位ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>d1, d2 = '', ''</div><div><br/></div><div>for i in range(320):</div><div>    for j in range(320):</div><div>        p = img.getpixel((i, j))</div><div>        if p == (255, 255, 255):</div><div>            d1 += '0'</div><div>        elif p == (0, 0, 0):</div><div>            d1 += '1'</div><div>        if len(d1) == 8:</div><div>            d2 += chr(int(d1, 2))</div><div>            d1 =''</div><div>print(d2)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>52494646FC18000057415645666D742010000000010001000A000000140000000200100064617461D818000001C001C001C001C</div><div>……（后略）</div></div><div>所有字符都是十六进制数字，尝试将其在十六进制编辑器里保存为文件：</div><div><img src="BUUCTF Misc 62（293-296）_files/Image.png" type="image/png" data-filename="Image.png" width="816"/><br/></div><div>从文件头可以看出是wav格式波形音频文件。</div><div><br/></div><div>修改文件后缀名，用audacity打开：</div><div><img src="BUUCTF Misc 62（293-296）_files/Image [1].png" type="image/png" data-filename="Image.png" width="1189"/><br/></div><div>如果以最高和最低分别为1和-1，那么波形高度共有8种：1、3/4、1/2、1/4、0、-1/4、-1/2、-3/4。特别是可以注意到， 不存在-1高度的波形，因此8种波形高度应该是刻意为之的，从而联想到八进制数据。</div><div>尝试后可以发现，如果波形高度从下到上记为0-7，那么开头几位为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>115 132 127 107</div></div><div>都在ASCII可打印字符范围内，八进制ASCII转码为MZWG，注意到这是字符串flag进行base32转码后的开头。此外，从波形中可以看出，每位八进制数字对应10个采样点。由此可以确定后续步骤如下：先每隔10个采样点取得wav波形高度，转换为八进制数字，然后每3位八进制数字进行ASCII转码，最后对得到的结果进行base32解码。</div><div><br/></div><div>写Python脚本提取wav波形数据并转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import wave</div><div><br/></div><div>w = wave.open('C:/Users/Administrator/Desktop/out.wav', 'r')</div><div>frame = w.getnframes()</div><div>data = w.readframes(frame)</div><div><br/></div><div>h = [0] * (len(data) // 2)</div><div>for i in range(0, len(data), 20):</div><div>    h[i // 20] = data[i + 1] * 256 + data[i]</div><div><br/></div><div>hmin, hmax = int(h[10] - 65536), int(h[8])</div><div>o, res = '', ''</div><div>for i in range(len(h)):</div><div>    if h[i] &gt; hmax:</div><div>        h[i] -= 65536</div><div>    o += str(round((int(h[i]) - hmin) / hmax / 0.25, 0))[0]</div><div>    if len(o) == 3:</div><div>        res += chr(int(o, 8))</div><div>        o = ''</div><div>print(res)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>MZWGCZ33G44GGNRTHE3DEMZSGQ4TQMZQMY2WCNRZGZSDCOBYHBRGMMZUMFSWIMZSGVRTQY3DGIZWIZDBO5SDKML2PJYXUMRTGMZTGYLBPU（后面是非ASCII可打印字符）</div></div><div>base32解码得到flag。</div><div><br/></div><div>flag：flag{78c639623249830f5a696d1888bf34aed325c8cc23ddawd51zzqz23333aa}</div></span>
</div></body></html> 