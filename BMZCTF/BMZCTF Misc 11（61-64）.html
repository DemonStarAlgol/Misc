<html>
<head>
  <title>BMZCTF Misc 11（61-64）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="5663"/>
<h1>BMZCTF Misc 11（61-64）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">61 BJDCTF-2020-Misc-藏藏藏</span></div><div><br/></div><div>下载得到jpg格式文件。十六进制编辑器查看，文件尾后有额外数据，是个zip格式压缩文件：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>提取并解压，得到 福利.docx ，打开发现二维码：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>扫码得到flag。</div><div><br/></div><div>flag：flag{you are the best!}</div><div><br/></div><div><span style="font-weight: bold;">62 BMP</span></div><div><br/></div><div>下载得到bmp格式文件。直接打开报错，十六进制编辑器查看：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>大量FF字节中间夹杂着少量其他字节。注意到字节总数为202800个，联想到24位色的BMP格式图像用3个字节来记录1个像素的RGB值，若将这些字节视作BMP格式图像的数据部分，则正好对应202800/3=67600=260*260个像素，且大量的FF FF FF字节正好对应背景的白色。猜测这是某个BMP格式图像文件去掉了文件头后剩下的数据部分。</div><div><br/></div><div>尝试将其还原为BMP格式图像，用三种方法。</div><div>1、直接绘图法。一般来说24位色BMP格式图像存储像素颜色的规则是从下往上、从左往右，单个像素颜色通道顺序为BGR。从而可以写出脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>data = open('C:/Users/Administrator/Desktop/24.bmp', 'rb').read()</div><div>w = 260  # 在67600的因数中切换直到得到合适结果为止</div><div>h = len(data) // (3 * w)</div><div><br/></div><div>img = Image.new('RGB', (w, h))</div><div>for y in range(h):</div><div>    for x in range(w):</div><div>        n = x + y * w</div><div>        b, g, r = data[n * 3], data[n * 3 + 1], data[n * 3 + 2]</div><div>        img.putpixel((x, h - y - 1), tuple([r, g, b]))</div><div>img.save('C:/Users/Administrator/Desktop/1.bmp')</div></div><div>得到图像：</div><div><img src="BMZCTF Misc 11（61-64）_files/1.bmp" type="image/bmp" data-filename="1.bmp"/></div><div>2、修复文件法。根据BMP格式图像数据格式规范，人工制作相应的文件头和信息头：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>文件头</b></div><div>bfType（2位）：文件标识符，字符BM，42 4D</div><div>bfSize（4位）：文件的总大小，本例中即202800+文件头及信息头大小，转十六进制后以小端序存放</div><div>bfReserved1（2位）：保留位，00 00</div><div>bfReserved2（2位）：保留位，00 00</div><div>bfOffBits（4位）：偏移量，24位色位图没有调色板，因此相当于文件头及信息头大小，转十六进制后以小端序存放</div><div><b>以上合计14位字节</b></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>信息头</b></div><div>biSize（4位）：信息头结构体大小</div><div>biWidth（4位）：图像宽度，转十六进制后小端序存放，本例中260即04 01 00 00</div><div>biHeight（4位）：图像高度，转十六进制后小端序存放，本例中260即04 01 00 00</div><div>biPlanes（2位）：图像数据平面，对于BMP格式总为1，即01 00</div><div>biBitCount（2位）：图像像素位数，本例中已判定为24位，十六进制小端序即18 00</div><div>biCompression（4位）：图像压缩算法，不压缩为0，即00 00 00 00</div><div>biSizeImage（4位）：图像数据大小，本例中为202800，十六进制小端序即30 18 03 00</div><div>biXPelsPerMeter（4位）：图像水平分辨率，单位为像素/米，可以瞎编</div><div>biYPelsPerMeter（4位）：图像垂直分辨率，单位为像素/米，可以瞎编</div><div>biClrUsed（4位）：图像实际使用调色板索引数，本例没有使用调色板，即00 00 00 00</div><div>biClrImportant（4位）：图像重要调色板索引数，本例没有使用调色板，即00 00 00 00</div><div><b>以上合计40位字节</b></div></div><div>计算一下刚才未知的几个参数值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>bfSize：202800+14+40=202854，十六进制小端序即66 18 03 00</div><div>bfOffBits：14+40=54，十六进制小端序即36 00 00 00</div><div>biSize：40，十六进制小端序即28 00 00 00</div></div><div>全部拼起来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>42 4D 66 18 03 00 00 00 00 00 36 00 00 00 28 00 00 00 04 01 00 00 04 01 00 00 01 00 18 00 00 00 00 00 30 18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div></div><div>插入到附件开头位置：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>保存后同样得到图像：</div><div><img src="BMZCTF Misc 11（61-64）_files/2.bmp" type="image/bmp" data-filename="2.bmp"/></div><div>3、Gimp法。用Gimp打开文件，文件类型选择“原始图像数据”：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>然后根据已经判定的高度、宽度和数据格式选择参数：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>得到图像，不过是反的，需要再上下反转一次：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{2bbec037bca695ab4059afb8623ee041}</div><div><br/></div><div><span style="font-weight: bold;">63 base_python</span></div><div><br/></div><div>下载得到txt格式文件。有8.28MB大，可怕，建议不要双击直接用记事本打开，会卡死。总之看一下开头：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>PE&lt;iKPE&lt;}rPHJl~QEF9pPDE9DQF&gt;%WPI^f(O+-;NPDMpBQF&gt;%XPE&lt;uOPE=7cO?qoHO+;09PDD{KPE&lt;`bPDD{LO;k}bO)yn?PE=JhPE&lt;iKPgGV$PHI_sPef8jO&gt;0ScQbbNePDNEQO+-;</div><div>……（后略）</div></div><div>看起来像是某种base编码，先分析一下出现的字符数量：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from collections import Counter</div><div><br/></div><div>c = open('C:/Users/Administrator/Desktop/base_python.txt').read()</div><div>c = Counter(c)</div><div>print(len(c))</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">运行结果：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>85</div></div><div>尝试base85解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import base64</div><div><br/></div><div>c = open('C:/Users/Administrator/Desktop/base_python.txt', 'rb').read()</div><div>print(base64.b85decode(c).decode())</div></div><div>运行结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>NTA0NTNDNjk0QjUwNDUzQzdENzI1MDQ4NEE2QzdFNTE0NTQ2Mzk3MDUwNDQ0NTM5NDQ1MTQ2M0UyNTU3NTA0OTVFNjYyODRGMkIy</div><div>……（后略）</div></div><div>很明显是base64编码，继续尝试解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>50453C694B50453C7D7250484A6C7E5145463970504445394451463E255750495E66284F2B2D3B4E50444D704251463E2558</div></div><div>很明显是base16编码，因此可以确定，本题是多种base套娃编码题。</div><div><br/></div><div>尝试用正则表达式判定base编码类型并逐层解码，脚本如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import base64, re</div><div><br/></div><div>f = open('C:/Users/Administrator/Desktop/base_python.txt', 'rb').read()</div><div><br/></div><div>while True:</div><div>    if 'flag{' in f.decode():</div><div>        print(f.decode())</div><div>        break</div><div>    elif re.match('^[0-9A-F]+$', f.decode()):</div><div>        f = base64.b16decode(f)</div><div>    elif re.match('^[2-7A-Z=]+$', f.decode()):</div><div>        f = base64.b32decode(f)</div><div>    elif re.match('^[0-9a-zA-Z+/=]+$', f.decode()):</div><div>        f = base64.b64decode(f)</div><div>    elif re.match('^[0-9A-Za-z!#$%&amp;()*+-;&lt;=&gt;?@^_`{|}~&quot;]+$', f.decode()):</div><div>        f = base64.b85decode(f)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{OTRhZTkyOTE0NmJiNGFjNWZhNDMzOTM1ZjkxYzg4Njk==}</div></div><div>大括号内明显也是base64编码（但多了一个=），解码得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>94ae929146bb4ac5fa433935f91c8869</div></div><div><br/></div><div>flag：flag{94ae929146bb4ac5fa433935f91c8869}</div><div><br/></div><div><span style="font-weight: bold;">64 小明的演讲t</span></div><div><br/></div><div>下载得到pptx格式文件。直接打开会报错：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>作为压缩包打开，在\ppt\media\路径下找到不可读取内容，是一个zip格式压缩包：</div><div><img src="BMZCTF Misc 11（61-64）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>再次解压得到两个txt文本文件和一个加密的flag.zip。根据文件名提示，需要破解两段密文得到压缩包密码。先看第一部分：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>2053250813784316</div></div><div>可以发现进制转换和常见的以数字为密文的替换式古典密码均无法得到有意义结果。注意到密文长度为4的倍数，尝试<a href="http://code.mcdvisa.com/">标准中文电码</a>，得到结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">我是密码</span></div></div><div>再看第二部分，直接打开文本显示为乱码，十六进制编辑器查看：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>FF FE 62 11 4E 5F 66 2F 5B C6 78 01</div></div><div>注意到汉字“我”的Unicode编码是\u6211，去掉开头两个字节后每两个字节Unicode转码得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>我也是密码</div></div><div>实际上，FF FE是UTF-16编码（小端序）的BOM头，而这段编码很明显是大端序的，BOM头应为FE FF（<a href="https://blog.csdn.net/ysh1042436059/article/details/80905062">参考资料</a>）。因此只需要把开头两字节改为FE FF就能直接打开文本看到明文。最后拼接得到密码为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>我是密码我也是密码</div></div><div>解压得到flag.txt：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>c3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzZmxhZ3twcHR4cG93ZXJwb2ludH0=</div></div><div>base64解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sssssssssssssssssssssssssssflag{pptxpowerpoint}</div></div><div><br/></div><div>flag：flag{pptxpowerpoint}</div></span>
</div></body></html> 