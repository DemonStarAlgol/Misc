<html>
<head>
  <title>BMZCTF Misc 20（97-100）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="7057"/>
<h1>BMZCTF Misc 20（97-100）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">97 2018 安洵杯 boooooom</span></div><div><br/></div><div>下载得到zip格式文件。是加密压缩包，根据题目名称，爆破一下：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>解压得到happy文件夹，内含两个加密的zip格式压缩包和password.py。先看后者：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import base64</div><div>import hashlib</div><div>f = open(&quot;password.txt&quot;,'r')</div><div>password = f.readline()</div><div>b64_str = base64.b64encode(password.encode('utf-8'))</div><div>hash = hashlib.md5()</div><div>hash.update(b64_str)</div><div>zip_passowrd = hash.hexdigest()</div><div>print(zip_passowrd)</div></div><div>输入password.txt。输出某段密码。而password.txt在password.zip里，看一下：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>注意到文件大小仅为8，如果字符空间较小（例如仅为数字），则有希望通过CRC32碰撞得到文件内容。尝试一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import zipfile, binascii, string, itertools</div><div><br/></div><div>zip = zipfile.ZipFile('C:/Users/Administrator/Desktop/happy/password.zip', 'r')</div><div>crc = zip.getinfo('password.txt').CRC</div><div><br/></div><div>for i in itertools.product(string.digits, repeat=8):</div><div>    if binascii.crc32(''.join(i).encode()) == crc:</div><div>        print(''.join(i))</div><div>        break</div></div><div>运行得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>08646247</div></div><div>代入password.py中运行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import base64, hashlib</div><div><br/></div><div>password = '08646247'</div><div>b64_str = base64.b64encode(password.encode('utf-8'))</div><div>hash = hashlib.md5()</div><div>hash.update(b64_str)</div><div>zip_passowrd = hash.hexdigest()</div><div>print(zip_passowrd)</div></div><div>运行得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>95c800c52134a571dfe69114c378e4be</div></div><div><br/></div><div>解压flag.zip得到flag.png。010editor打开，模板功能提示IHDR块CRC错误。图像能正常显示，说明高度被修改过。<span style="font-size: unset; color: unset; font-family: unset;">爆破一下真实高度：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import struct</div><div>import binascii</div><div>from Crypto.Util.number import bytes_to_long</div><div><br/></div><div>img = open('C:/Users/Administrator/Desktop/happy/flag.png', 'rb').read()</div><div><br/></div><div>for i in range(0xFFFF):</div><div>    stream = img[12:20] + struct.pack('&gt;i', i) + img[24:29]</div><div>    crc = binascii.crc32(stream)</div><div>    if crc == bytes_to_long(img[29:33]):</div><div>        print(i, hex(i))</div></div><div>运行结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>500 0x1f4</div></div><div>在十六进制编辑器中修改高度位，得到图片：</div><div><img src="BMZCTF Misc 20（97-100）_files/flag.png" type="image/png" data-filename="flag.png"/></div><div>得到flag。</div><div><br/></div><div>flag：flag{a184929e2c170e2b7dc12eb3106f0a16}</div><div><br/></div><div><span style="font-weight: bold;">98 2018 HEBTUCTF USB流量分析</span></div><div><br/></div><div>下载得到pcap格式文件，wireshark打开：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>观察一下特征，均为USB协议流量，每个数据包的数据长度均为8，且会发生变化的主要是其中第3字节。这是USB键盘流量的特征，试着用大佬的<a href="https://github.com/WangYihang/UsbKeyboardDataHacker">USB键盘流量一把梭脚本</a>梭一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# python UsbKeyboardDataHacker.py USBattack.pcap</div><div>Running as user &quot;root&quot; and group &quot;root&quot;. This could be dangerous.</div><div>[-] Unknow Key : 01</div><div>[-] Unknow Key : 01</div><div>[+] Found : HBTU&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;EBTUCTF{USA&lt;DEL&gt;B&lt;DEL&gt;_&lt;DEL&gt;&lt;DEL&gt;_attack_-is_-very_-interesting_-&lt;RET&gt;</div></div><div>有未能辨识的字符，且得到的结果似乎也不完整，这可能是由于脚本中对组合键输入处理不够完整导致的。那么就只能手动分析，首先用tshark提取出键盘输入数据，注意流量包中键盘来源为1.25.1，并保留有效的第1和第3字节：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# tshark -r USBattack.pcap -Y 'usb.src == &quot;1.25.1&quot;' -T fields -e usb.capdata | cut -c 1-2,5-6 &gt; data.txt</div></div><div>然后找到<a href="https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf">USB官方文档</a>的53页，有击键信息和键位的对应关系：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>简而言之，第1字节的8个bit分别对应左右Ctrl键、Shift键、Alt键和GUI键（即Windows的Win键，Mac的Apple键等）等功能键。由于其他按键对输入没有影响，通常只需要判断Shift是否被按下即可。第3字节按表中顺序对应各个按键，如04对应A键，05对应B键。<span style="font-size: unset; color: unset; font-family: unset;">写个脚本把每行的击键信息转为按键：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>d = open('C:/Users/Administrator/Desktop/data.txt', 'r').readlines()</div><div>m = ['aA', 'bB', 'cC', 'dD', 'eE', 'fF', 'gG', 'hH', 'iI', 'jJ', 'kK', 'lL', 'mM', 'nN', 'oO', 'pP', 'qQ', 'rR', 'sS', 'tT', 'uU', 'vV', 'wW', 'xX', 'yY', 'zZ', '1!', '2@', '3#', '4$', '5%', '6^', '7&amp;', '8*', '9(', '0)', ['&lt;Enter&gt;', '&lt;Enter&gt;'], ['&lt;Esc&gt;', '&lt;Esc&gt;'], ['&lt;Backspace&gt;', '&lt;Backspace&gt;'], ['&lt;Tab&gt;', '&lt;Tab&gt;'], ['&lt;Space&gt;', '&lt;Space&gt;'], '-_', '=+', '[{', ']}', '\\|', '`~', ';:', '\'&quot;', ',&lt;', '.&gt;', '/?', ['&lt;CapsLock&gt;', '&lt;CapsLock&gt;']]</div><div>r = open('C:/Users/Administrator/Desktop/res.txt', 'a')</div><div><br/></div><div>for i in d:</div><div>    key1, key2 = int(i.strip()[:2], 16), int(i.strip()[2:], 16)</div><div>    if key2 != 0:</div><div>        r.write(i.strip() + ' ')</div><div>        if 4 &lt;= key2 &lt;= 57:</div><div>            if key1 &amp; 2 or key1 &amp; 32:</div><div>                r.write(m[key2 - 4][1] + ' ')</div><div>            else:</div><div>                r.write(m[key2 - 4][0] + ' ')</div><div>        r.write('\n')</div></div><div>但输出结果与之前得到的结果几乎没有区别，即提取出的键盘输入信息为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>HEBTUCTF{U_attack_is_very_interesting_</div></div><div>回到流量包，注意到来自1.24.1的131到1476号包，每个包中的数据为7字节，显然来自另一种设备。但观察后没有发现类似USB鼠标的特征（连续的三个字节存在不断变化，且其中第一个字节为00 01或02，后两个变化范围为00-FF）。因此从这里也没有找到其他线索。</div><div><br/></div><div>通过搜索找到了一些其他资料：<span style="font-size: unset; color: unset; font-family: unset;">Github上该场比赛的相关文件：</span><a href="https://github.com/HECTF/write-ups-2018/tree/master/Misc/USB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88ERROR404%EF%BC%89" style="font-size: unset; font-family: unset;">仓库一</a><span style="font-size: unset; color: unset; font-family: unset;">，</span><a href="https://github.com/hebtuerror404/HEBTUCTF/tree/master/2018-%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%8C%91%E6%88%98%E8%B5%9B/Misc/USB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88ERROR404%EF%BC%89" style="font-size: unset; font-family: unset;">仓库二</a><span style="font-size: unset; color: unset; font-family: unset;">；</span><span style="font-size: unset; color: unset; font-family: unset;">该场比赛的Writeup：</span><a href="https://www.jianshu.com/p/35de50cfe877" style="font-size: unset; font-family: unset;">简书</a><span style="font-size: unset; color: unset; font-family: unset;">（审核中，无法查看），</span><a href="https://www.meiwen.com.cn/subject/ghdfqqtx.html" style="font-size: unset; font-family: unset;">某网站的转载</a><span style="font-size: unset; color: unset; font-family: unset;">。</span><span style="font-size: unset; color: unset; font-family: unset;">对比一下可以发现：</span><span style="font-size: unset; color: unset; font-family: unset;">Github提供的题目名称和附件与BMZCTF是一致的，某网站转载的Writeup中“这个USB包竟然如此的奇怪呢”一题的flag在BMZCTF可以提交通过；但Writeup中的题目名称和BMZCTF、Github都不同，且这一题目名称也从未在Github仓库中出现过。由于转载网站丢失了所有图片，无法判断两个题目名所指代的是否同一道题目，暂时只能怀疑是漏看了131到1476号包的USB设备。本题待补完。</span></div><div><br/></div><div>flag（存疑）：HEBTUCTF{USB_task_1s_s0_e@sy!_rsjtsfrxcgbh}</div><div>反映之后本题已暂时下线。</div><div><br/></div><div><span style="font-weight: bold;">99 2018 QCTF Noise</span></div><div><br/></div><div>下载得到wav格式文件。波形没有看出可疑之处，尝试听一下，从歌词可以听出这是《My little Pony》的相关歌曲，进一步搜索可以发现是《My Little Pony Theme Song》。此外可以听到音频中似乎夹杂着一些噪音，比如25秒左右就很明显。猜测需要将噪音提取出来。</div><div><br/></div><div>用audacity打开音频：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>发现两个声道的波形比较相似，播放之后都是音乐+人声的混合。换言之，额外的噪音很可能已经被混音进了歌曲的原始音频。搜索“音频 消声”或“音频 提取”等关键词，找到<a href="http://www.audiobar.cn/forum.php?mod=viewthread&amp;tid=246374">这个链接</a>，看到4楼的回复：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>根据同样的原理，如果我们能找到歌曲的原声，与附件音频抵消，就能得到只剩下额外噪声的音频了。据出题人说歌曲音频是从网易云音乐下载的，我从<a href="https://blog.csdn.net/u011297466/article/details/81059248">这位大佬的WP</a>中给出的百度网盘链接下载到了原声.mp3。</div><div><br/></div><div>用audacity分左右声道播放一遍附件音频，判断添加的噪音可能在右声道。在audacity中点击“分离立体声到单声道”：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>同样导入原声.mp3，分离左右声道，然后选中两个声道，点击菜单-效果-反相（上下）：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>分别选择附件和原声的左声道，点击菜单-轨道-混音并渲染，对两个右声道也同样处理：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>此时听一下右声道（上方那个）已经可以听到比较明显的无线电信号音，尤其是开头一段，很明显是SSTV（慢扫描电视）信号的开头部分。事实上此时这段音频已经能够被SSTV软件识别，启动MMSSTV后，播放右声道音频，可以得到图像：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>出现了明显的QCTF{字样。但由于人声的波形大多居中，仅依靠相似音频的反相混合难以完全消除，只能削弱（实际播放时也能发现，人声部分虽然变得较轻，但仍然比信号音更加明显），对SSTV接受到的图像造成了一定干扰。因此简单的反相消声效果并不好，需要进一步消除人声。</div><div><br/></div><div>尝试了多种方法，例如利用spleeter、Goldwave等工具在反相消声前或后消除人声，或对SSTV转换得到的图像进行噪音过滤和图像去模糊化等处理，但暂时没有得到特别满意的结果。由于没有安装Adobe Audition，<a href="https://blog.csdn.net/u011297466/article/details/81059248">这篇WP</a>里提到的调整-180°相位的方法还没有尝试过，待尝试了再作更新。目前得到比较清晰的图像：</div><div><img src="BMZCTF Misc 20（97-100）_files/202110060830.bmp" type="image/bmp" data-filename="202110060830.bmp"/><img src="BMZCTF Misc 20（97-100）_files/202110060902.jpg" type="image/jpeg" data-filename="202110060902.jpg"/></div><div>配合起来勉强也算能看出flag……剩下的就等装了Adobe Audition再说吧。</div><div><br/></div><div>flag：QCTF{Th4t_1s_v3ry_Har5h}</div><div><br/></div><div><span style="font-weight: bold;">100 纪念屈原</span></div><div><br/></div><div>套娃题。下载得到加密的RAR格式压缩包：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>注释：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>屈原的姓、氏、名、字分别为哪四个字？拼接起来md5加密后即为解压密码</div></div><div>文化常识了属于是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>md5(芈屈平原) = 16ccb09f96f27af192f541992560d695</div></div><div><br/></div><div>解压得到三个文件，base_data.txt、password和先来看看这个吧，那就先来看看这个吧。十六进制编辑器查看文件头，确认为JPG格式图像，顺便可以发现文件尾后有额外数据：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>首先是一段字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>4pe777iO4pmL77iO4qyn77iO4qyn77iO4qyl77iO4pah77iO4p2S77iO4pmO77iOIOKZk++4juKsp++4jiDimYvvuI4g4pmM77iO4p2N77iO4pe777iOIOKZkO+4juKZk++4juKXj++4juKZj++4jiDirKXvuI7imZPvuI7ip6vvuI7imZLvuI4g4pmL77iOIOKZjO+4juKZk++4juKnq++4jiDimY7vuI7imY/vuI7il7vvuI7ip6vvuI7imZLvuI4g4pah77iO4pmQ77iOIO2gve23j++4ju2gve2zhO+4jg==</div></div><div>转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>◻︎♋︎⬧︎⬧︎⬥︎□︎❒︎♎︎ ♓︎⬧︎ ♋︎ ♌︎❍︎◻︎ ♐︎♓︎●︎♏︎ ⬥︎♓︎⧫︎♒︎ ♋︎ ♌︎♓︎⧫︎ ♎︎♏︎◻︎⧫︎♒︎ □︎♐︎ ������︎������︎</div></div><div>可能在不同平台会存在显示差异，但应该能看到几个星座符号。联想到Windows的Wingdings字体，当然，由于这里转码得到的Wingdings字符串实际上是Unicode字符，所以需要自行对照转换表或利用<a href="https://lingojam.com/WingDing">在线工具</a>进行解码。不过可能是因为编码之类的原因，我这里直接转码得到的Wingding密文末尾出现了乱码，解码后得到的结果是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>p︎a︎s︎s︎w︎o︎r︎d︎ i︎s︎ a︎ b︎m︎p︎ f︎i︎l︎e︎ w︎i︎t︎h︎ a︎ b︎i︎t︎ d︎e︎p︎t︎h︎ o︎f︎ ������︎������︎</div></div><div>微妙地缺失了重要信息，不过已经得到了明确线索，password这个文件是个颜色深度为某未知数的BMP格式图像。</div><div><br/></div><div>那么接下来看password，十六进制编辑器打开：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>没有BMP文件头，很明显只保留了BMP的数据部分。常用的BMP颜色深度包括单色（1位，虽然叫单色实际上是黑白两色）、16色（4位）、256色（8位）、16位、24位和32位（带Alpha通道）。观察数据特征，大部分数据都表现出4字节的重复周期，在32位色深模式下正好表现为相同颜色的像素。如果是其他颜色深度，则图像背景部分会变得非常杂乱，因此暂时猜测上一步因为编码问题没有得到的颜色深度为32。</div><div><span style="font-size: unset; color: unset; font-family: unset;">确定色深后下一步需要判断图像的宽度和高度。</span><span style="font-size: unset; color: unset; font-family: unset;">注意到文件总大小为324212字节，其中包含2字节的00 00文件尾，剩余的324210字节无法被4整除。从而可以猜测，该文件并非去除了BMP文件头，而是将合计54字节（文件头14字节+信息头40字节）的文件头部全部替换成了重复字节。按照这一猜测，实际的数据部分长度为324212-2-54=324156，对应81039像素，分解质因数得到</span>3x7x17x227，宽度的可能备选项为81039的所有因数。</div><div><br/></div><div>能够确定的文件头和信息头内容如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-weight: bold;">文件头</span></div><div>bfType（2位）：文件标识符，字符BM，42 4D</div><div>bfSize（4位）：文件的总大小，324212，74 F2 04 00</div><div>bfReserved1（2位）：保留位，00 00</div><div>bfReserved2（2位）：保留位，00 00</div><div>bfOffBits（4位）：偏移量，32位色位图没有调色板，因此为十进制54，36 00 00 00</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-weight: bold;">信息头</span></div><div>biSize（4位）：信息头结构体大小，十进制40，28 00 00 00</div><div>biWidth（4位）：图像宽度，转十六进制后小端序存放,</div><div>biHeight（4位）：图像高度，转十六进制后小端序存放</div><div>biPlanes（2位）：图像数据平面，对于BMP格式总为1，01 00</div><div>biBitCount（2位）：图像像素位数，本例中已判定为32位，20 00</div><div>biCompression（4位）：图像压缩算法，不压缩为0，00 00 00 00</div><div>biSizeImage（4位）：图像数据大小，本例中为324156，3C F2 04 00</div><div>biXPelsPerMeter（4位）：图像水平分辨率，单位为像素/米，可以瞎编</div><div>biYPelsPerMeter（4位）：图像垂直分辨率，单位为像素/米，可以瞎编</div><div>biClrUsed（4位）：图像实际使用调色板索引数，本例没有使用调色板，00 00 00 00</div><div>biClrImportant（4位）：图像重要调色板索引数，本例没有使用调色板，00 00 00 00</div></div><div>然后写个脚本，把所有可能的宽高都生成一次文件头，然后合成文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>list = []</div><div>for i in range(1, 81040):</div><div>    if 81039 % i == 0:</div><div>        list += [i]</div><div><br/></div><div>bmp = open('C:/Users/Administrator/Desktop/端午/password', 'rb').read()[54:]</div><div>head1 = 0x424D74F20400000000003600000028000000.to_bytes(18, 'big')</div><div>head2 = 0x01002000000000003CF2040000000000000000000000000000000000.to_bytes(28, 'big')</div><div>for w in list:</div><div>    h = 81039 // w</div><div>    with open(f'C:/Users/Administrator/Desktop/端午/out/{str(w)}.bmp', 'wb') as out:</div><div>        out.write(head1 + w.to_bytes(4, 'little') + h.to_bytes(4, 'little') + head2 + bmp)</div></div><div>输出结果：</div><div><img src="BMZCTF Misc 20（97-100）_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div>很明显宽度357的结果是正确的图像：</div><div><img src="BMZCTF Misc 20（97-100）_files/357.bmp" type="image/bmp" data-filename="357.bmp"/></div><div>当然这一步也可以参考 <a href="BMZCTF Misc 11（61-64）.html" style="color: rgb(105, 170, 53);">BMZCTF Misc 11（61-64）</a>62题中的Gimp法，手动调整宽度得到图像。总之最后得到密码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>74636cc4cfe7cc222130ea50bb2e23c2</div></div><div><br/></div><div>接着进行一个base_data.txt的看：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>MjAyMS0wNi0wOCAxMzoxMzoxMCA6IGYzNjFkY2U5ZmZhNzhlZDY3MTIyMmE5ZmU3NTc2YjM5OWE3NTlkMTZhNTQ4NTMyMmM1ZDYyYmY5NDE3M2RmN2NmMTJhYjBlZTQ1YzYzZjk5OTM0ZmM2N2I2ZmEwMDYwNjQxZTQwOGM4YTcwMjhhYmEzYTg3MDY4ZWYxYTcyZWQ0NDdlMzI3YjM4YmQ0</div><div>MjAyMS0wNi0wOCAxMzoxMzozNyA6IDZmZGQ3MjYzZWUyOGJmNGY2Y2U2MGU5MjBjYWUyOGZmODg1NjZjOTNiZjY2M2VkM2QxMTkzYjFkM2YwMTU4OTI3YTI4YmE1YmMxODBhOWEzYzg0N2UyNTlkZTgwYWQ4NTZiN2RiZGRiZWVmODAxNTkyZjYzMWNmNmE1MzA0MWNlNGYwYTRiZDhkODYz</div><div>MjAyMS0wNi0wOCAxMzoxMjoyMiA6IGE3NDU3ZDU1MzM0YzMyNDRmOTM5YWRlOWFjYTNmNGRmMmYwZWIwMDc3OTc0ZGUyYjM2ZjhmOTc5Nzc1MWVlZDgwNGU0YTAwMGNjZGVhMGNkMzRmMzNhNjc1MzI1OWI5NDZiZGYwYTIzYjM4YmMyZGJiMGJkYzJiNTU0ZmNmN2M4YjBiNjcwMGE2NmU2</div><div>MjAyMS0wNi0wOCAxMzowOTowNiA6IDAxZjRjNjQ4N2YwZTY5OTQ2Yzc2NzdjMTliYThmOTViYjJjNjRiZjQxNDE1MDFhMzQxYzkxMTAwMDEzMWFjMjgxMDI3ZjhjNGEzZWJiZjYyMWFlYjcwZDJmY2U0MDQ1M2FkZWIzNTI0ZjRmMzY3NGFhMjViOWY4MjQ0MDhiNzJhNzM4NzI0ZGFmOTkx</div><div>……（后略）</div></div><div>对前几行进行一个base64的解：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>2021-06-08 13:13:10 : f361dce9ffa78ed671222a9fe7576b399a759d16a5485322c5d62bf94173df7cf12ab0ee45c63f99934fc67b6fa0060641e408c8a7028aba3a87068ef1a72ed447e327b38bd4</div><div>2021-06-08 13:13:37 : 6fdd7263ee28bf4f6ce60e920cae28ff88566c93bf663ed3d1193b1d3f0158927a28ba5bc180a9a3c847e259de80ad856b7dbddbeef801592f631cf6a53041ce4f0a4bd8d863</div><div>2021-06-08 13:12:22 : a7457d55334c3244f939ade9aca3f4df2f0eb0077974de2b36f8f9797751eed804e4a000ccdea0cd34f33a6753259b946bdf0a23b38bc2dbb0bdc2b554fcf7c8b0b6700a66e6</div><div>2021-06-08 13:09:06 : 01f4c6487f0e69946c7677c19ba8f95bb2c64bf4141501a341c911000131ac281027f8c4a3ebbf621aeb70d2fce40453adeb3524f4f3674aa25b9f824408b72a738724daf991</div></div><div>很明显，要按照时间戳排列十六进制字符串，然后转字节数据得到某种东西，进行一个脚本的写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import base64</div><div>import time as tm</div><div><br/></div><div>base_data = open('C:/Users/Administrator/Desktop/端午/base_data.txt', 'rb').read().splitlines()</div><div>base_data = [base64.b64decode(i).decode() for i in base_data]</div><div><br/></div><div>time, data = [], []</div><div>for i in base_data:</div><div>    temp_t = i.split(' : ')[0]</div><div>    temp_t = tm.strptime(temp_t, '%Y-%m-%d %H:%M:%S')</div><div>    time += [tm.mktime(temp_t)]</div><div><br/></div><div>    temp_d = i.split(' : ')[1]</div><div>    temp_l = len(temp_d) // 2</div><div>    temp_d = int(temp_d, 16).to_bytes(temp_l, 'big')</div><div>    data += [temp_d]</div><div><br/></div><div>res = b''</div><div>sort_time = sorted(time)</div><div>for i in sort_time:</div><div>    idx = time.index(i)</div><div>    res += data[idx]</div><div>print(res[:20])</div><div>with open('C:/Users/Administrator/Desktop/端午/res', 'wb') as r:</div><div>    r.write(res)</div></div><div>进行一个脚本的运行，输出得到res文件，从文件头可以判断是zip格式压缩包。</div><div><br/></div><div>用上上步得到的密码解压上一步得到的压缩包，得到DuanWu.png.txt和This-Is-Flag.png，先看后者。010Editor打开，报了IHDR块的CRC校验错误。爆破一下宽度和高度：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import zlib</div><div>import struct</div><div><br/></div><div># 同时爆破宽度和高度</div><div>filename = 'C:/Users/Administrator/Desktop/端午/DuanWu/This-Is-Flag.png'</div><div>with open(filename, 'rb') as f:</div><div>    all_b = f.read()</div><div>    crc32key = int(all_b[29:33].hex(), 16)</div><div>    data = bytearray(all_b[12:29])</div><div>    n = 4095</div><div>    for w in range(n):</div><div>        width = bytearray(struct.pack('&gt;i', w))</div><div>        for h in range(n):</div><div>            height = bytearray(struct.pack('&gt;i', h))</div><div>            for x in range(4):</div><div>                data[x+4] = width[x]</div><div>                data[x+8] = height[x]</div><div>            crc32result = zlib.crc32(data)</div><div>            if crc32result == crc32key:</div><div>                print(&quot;宽为：&quot;, end = '')</div><div>                print(width, end = ' ')</div><div>                print(int.from_bytes(width, byteorder='big'))</div><div>                print(&quot;高为：&quot;, end = '')</div><div>                print(height, end = ' ')</div><div>                print(int.from_bytes(height, byteorder='big'))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>宽为：bytearray(b'\x00\x00\x05\xdc') 1500</div><div>高为：bytearray(b'\x00\x00\x00\xc8') 200</div></div><div>十六进制编辑器修改对应字节得到图片：</div><div><img src="BMZCTF Misc 20（97-100）_files/This-Is-Flag.png" type="image/png" data-filename="This-Is-Flag.png"/></div><div>并没有flag。</div><div><br/></div><div>继续看DuanWu.png.txt：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>……（前略）0000000a0a1a0d074e40598</div></div><div>很明显是PNG格式图像的十六进制数据倒转，写个脚本转回来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>d = open('C:/Users/Administrator/Desktop/端午/DuanWu/DuanWu.png.txt', 'r').read()[::-1]</div><div>r = open('C:/Users/Administrator/Desktop/端午/DuanWu/res.png', 'ab')</div><div>for i in range(0, len(d), 2):</div><div>    r.write(int(d[i: i+2], 16).to_bytes(1, 'big'))</div></div><div>得到图片：</div><div><img src="BMZCTF Misc 20（97-100）_files/res.png" type="image/png" data-filename="res.png"/></div><div>观察一下，图像中存在红色和蓝色的竖线条，每列的蓝色线条仅有一条（含被上下边缘分割的情况）且长度相同，容易联想到[b01lers2020]image_adjustments一题（见 <a href="evernote:///view/30668439/s39/c9514257-e6fa-4ac3-b8f7-19ebb2c12d27/c9514257-e6fa-4ac3-b8f7-19ebb2c12d27/" style="color: #69aa35;">BUUCTF Misc 48（237-240）</a>240题），抄一下自己的脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/端午/DuanWu/res.png')</div><div>x, y = img.size</div><div><br/></div><div>pixel = img.load()</div><div>for r in range(x):</div><div>    column = []</div><div>    for c in range(y):</div><div>        column += [pixel[r, c]] # 取得每一列的像素并存入column列表</div><div>    done = False</div><div>    for i in range(y):</div><div>        if done:</div><div>            break</div><div>        for c in range(y):</div><div>            pixel[r, (c + i) % y] = column[c] # 在原图高度的范围内对每一列像素进行移位</div><div>            if (pixel[r, 0] == (0, 0, 255) and pixel[r, 199] == (255, 255, 255)):</div><div>                # 如果满足该列开头像素为蓝色，且末尾像素为白色，认为该列移位完成</div><div>                done = True</div><div><br/></div><div>img.save('C:/Users/Administrator/Desktop/端午/DuanWu/res2.png')</div></div><div>运行得到图片：</div><div><img src="BMZCTF Misc 20（97-100）_files/res2.png" type="image/png" data-filename="res2.png"/></div><div>所以另外一张图实际上是提示这一结果用的，预期解实际上应该是把蓝色线条移到最下方。</div><div><br/></div><div>flag：BMZCTF{Mochu7&amp;Cyz-Wish-You-Happy-DuanWu-Festival}</div></span>
</div></body></html> 