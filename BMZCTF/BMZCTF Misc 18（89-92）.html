<html>
<head>
  <title>BMZCTF Misc 18（89-92）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="6055"/>
<h1>BMZCTF Misc 18（89-92）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">89 2020sdnisc-懂得都懂</span></div><div><br/></div><div>下载得到png格式文件。十六进制编辑器常规方法穷举一遍没有可疑之处，那么遇事不决zsteg：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# zsteg flag.png</div><div>b1,bgr,lsb,xy       .. &lt;wbStego size=68, ext=&quot;\x00\x18E&quot;, data=&quot;\x83\xBCXyA\x0F;L\xB5\xE5&quot;..., even=false&gt;</div><div>……（后略）</div></div><div>用Stegsolve看一下，确实也能看到R/G/B Plane 0的左上角有明显的LSB隐写痕迹：</div><div><img src="BMZCTF Misc 18（89-92）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>虽然zsteg提示可能是来自wbStego的隐写，但wbStego并不支持PNG格式。限定Plane 0，用zsteg再次穷举一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# zsteg -a -b1 flag.png</div><div>b1,bgr,lsb,xy       .. &lt;wbStego size=68, ext=&quot;\x00\x18E&quot;, data=&quot;\x83\xBCXyA\x0F;L\xB5\xE5&quot;..., even=false&gt;</div><div>b1,abgr,msb,xy      .. file: PGP Secret Key -</div><div>b1,r,msb,yx,prime   .. file: MPEG ADTS, layer II, v1, 112 kbps, Stereo</div><div>b1,rgb,msb,yx,prime .. file: Apple DiskCopy 4.2 image \377\377\307\377\377\377\377\037, 4041473807 bytes, 0x3870e0 tag size, 0xff encoding, 0xc7 format                                                                                                 </div><div>b1,rgba,lsb,XY,prime.. file: compacted data</div><div>b1,rgba,msb,XY,prime.. file: MPEG ADTS, AAC, v2 SSR, 48 kHz, surround + side</div><div>b1,abgr,msb,XY,prime.. file: MPEG ADTS, AAC, v4 Main, 22.05 kHz, surround + side</div><div>b1,rgba,lsb,YX,prime.. file: old packed data</div><div>b1,rgb,lsb,xY       .. file: AIX core file fulldump 64-bit</div><div>b1,rgb,msb,Yx,prime .. file: AIX core file fulldump 32-bit</div><div>b1,bgr,msb,Yx,prime .. file: AIX core file fulldump 32-bit</div></div><div>基本没有任何结果，从而可以猜测LSB隐写写入的数据是加密过的，很可能使用了某种基于LSB原理且可加密的隐写工具。</div><div><br/></div><div>那么首要嫌疑对象就是<a href="https://github.com/livz/cloacked-pixel">cloacked-pixel</a>，由于没有找到关于密码的其他提示，考虑爆破：</div><div>写出Python脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from lsb import extract</div><div>import os</div><div><br/></div><div>f = open('/usr/share/wordlists/dirb/others/best1050.txt', 'r+').readlines()</div><div>for line in f:</div><div>    p = line.rstrip()</div><div>    out = './res/' + p</div><div>    extract('flag.png', out, p)</div><div>    o = open(out).read()</div><div>    if 'flag{' in o:</div><div>        print('txt: ' + p)</div><div>        os.rename(out, out + '.txt')</div><div>        break</div><div>    o = open(out, 'rb').read()[0:4]</div><div>    if o == b'\x50\x4b\x03\x04':</div><div>        print('zip: ' + p)</div><div>        os.rename(out, out + '.zip')</div><div>        break</div><div>    if o == b'\x52\x61\x72\x21':</div><div>        print('rar: ' + p)</div><div>        os.rename(out, out + '.rar')</div><div>        break</div><div>    if o == b'\x89\x50\x4e\x47':</div><div>        print('png: ' + p)</div><div>        os.rename(out, out + '.png')</div><div>        break</div><div>    if o[0:3] == b'\xff\xd8\xff':</div><div>        print('jpg: ' + p)</div><div>        os.rename(out, out + '.jpg')</div><div>        break</div></div><div>将字典文件和Python脚本都放到cloacked-pixel-master目录下，并建立res目录后用Python2运行脚本，输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/lsb# python2 1.py</div><div>[+] Image size: 640x640 pixels.</div><div>[+] Written extracted data to ./res/------.</div><div>[+] Image size: 640x640 pixels.</div><div>[+] Written extracted data to ./res/0.</div><div>[+] Image size: 640x640 pixels.</div><div>[+] Written extracted data to ./res/00000.</div><div>[+] Image size: 640x640 pixels.</div><div>[+] Written extracted data to ./res/000000.</div><div>[+] Image size: 640x640 pixels.</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">……（中略）</span></div><div>[+] Written extracted data to ./res/1234.</div><div>[+] Image size: 640x640 pixels.</div><div>[+] Written extracted data to ./res/12345.</div><div>[+] Image size: 640x640 pixels.</div><div>[+] Written extracted data to ./res/123456.</div><div>txt: 123456</div><div><br/></div><div>root@kali:~/Desktop/lsb# cat ./res/123456.txt</div><div>flag{6e9fbfe27c40bbad06db30c42c04c4d6}</div></div><div><br/></div><div>flag：flag{6e9fbfe27c40bbad06db30c42c04c4d6}</div><div><br/></div><div><span style="font-weight: bold;">90 2020sdnisc-过去和现在</span></div><div><br/></div><div>下载得到png格式文件。010Eidtor打开，模板报错，移动到出现错误的文件尾部看一下：</div><div><img src="BMZCTF Misc 18（89-92）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>可以看到第二个IDAT块自称长度位为0x5C(=92)，但其数据区长度很明显没有这么长（即使把IEND块也包进去，依然无法达到宣称的长度，从而导致模板在尝试寻找其数据区结尾时超出了文件尾部，于是就报错了）。此外其数据区的开头字节是78 9C，很明显是zlib压缩数据的文件头，因此这个IDAT块必然是来自额外的zlib压缩数据。</div><div><br/></div><div>为了提取该zlib压缩数据内容，使用binwalk。这样一来，首先binwalk -e会检测zlib压缩数据的头和尾并将其提取，其次该工具会把提取到的压缩数据全部尝试解压，从而一次操作直接获取解压后内容。记住zlib头78 9C字节的位置0x21154，然后：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# binwalk -e flag.png</div><div><br/></div><div>DECIMAL       HEXADECIMAL     DESCRIPTION</div><div>--------------------------------------------------------------------------------</div><div>0             0x0             PNG image, 600 x 379, 8-bit/color RGB, non-interlaced</div><div>179           0xB3            Zlib compressed data, best compression</div><div>135508        0x21154         Zlib compressed data, default compression</div><div><br/></div><div>root@kali:~/Desktop# ls ./_flag.png.extracted/</div><div>21154  21154.zlib  B3  B3.zlib</div><div>root@kali:~/Desktop# cat ./_flag.png.extracted/21154</div><div>flag{fc25cbb7b85959fe03738241a96bf23d}</div></div><div><br/></div><div>flag：flag{fc25cbb7b85959fe03738241a96bf23d}</div><div><br/></div><div><span style="font-weight: bold;">91 2020sdnisc-左上角的秘密</span></div><div><br/></div><div>下载得到enc.py和flag_enc.hex。顾名思义，前者是加密脚本，后者是flag被加密后的数据文件。先看前者：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># encoding=utf-8</div><div>flag_enc = open(&quot;flag_enc.hex&quot;, &quot;wb&quot;)</div><div><br/></div><div>def file_encode(flag):</div><div>    i = 1</div><div>    while True:</div><div>        byte_str = flag.read(1)</div><div>        if (byte_str == b''):</div><div>            exit()</div><div>        byte_str = hex_encode(byte_str)</div><div>        file_write(flag_enc, byte_str)</div><div>        # print(byte_str, end=&quot;&quot;)</div><div>        i = i + 1</div><div><br/></div><div>def hex_encode(byte_str):</div><div>    tmp = int.from_bytes(byte_str, byteorder=&quot;big&quot;)</div><div>    if (tmp % 2 == 0):</div><div>        tmp = (tmp + 1) ^ 128</div><div>    else:</div><div>        tmp = (tmp - 1) ^ 128</div><div>    tmp = bytes([tmp])</div><div>    return tmp</div><div><br/></div><div>def file_write(flag_enc, byte_str):</div><div>    flag_enc.write(byte_str)</div><div><br/></div><div>if __name__ == '__main__':</div><div>    with open(&quot;./flag.png&quot;, &quot;rb&quot;) as flag:</div><div>        file_encode(flag)</div><div>    flag_enc.close()</div></div><div>捋一下加密过程，实际就是对flag的每个字节，根据奇偶分别加1或减1后与128按位异或，然后写入flag_enc文件。</div><div><br/></div><div>对照写出解密脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>d = open('C:/Users/Administrator/Desktop/flag_enc.hex', 'rb').read()</div><div>res = open('C:/Users/Administrator/Desktop/res', 'ab')</div><div>for i in d:</div><div>    res.write(((i + 1 - i % 2 * 2) ^ 128).to_bytes(1, 'big'))</div></div><div>十六进制编辑器查看运行结果，从文件头判断为PNG格式图像，重命名：</div><div><img src="BMZCTF Misc 18（89-92）_files/res.png" type="image/png" data-filename="res.png"/></div><div>联想到题目名称，左上角的这条线就显得非常可疑。无论用图像编辑软件还是Stegsolve等工具都能发现这条线里每个像素点的颜色都是不同的，写脚本取个色：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/res.png')</div><div>for i in range(100):</div><div>    if img.getpixel((i, i)) != (255, 255, 255):</div><div>        print(img.getpixel((i, i)))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(1, 90, 1)</div><div>(2, 109, 2)</div><div>(3, 120, 3)</div><div>(4, 104, 4)</div><div>(5, 90, 5)</div><div>(6, 51, 6)</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">……（中略）</span></div><div>(49, 78, 49)</div><div>(50, 110, 50)</div><div>(51, 48, 51)</div><div>(52, 61, 52)</div></div><div>可以看到R和B通道从1递增到52，G通道数值则全都位于ASCII可打印字符范围内。把G通道数值ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/res.png')</div><div>for i in range(100):</div><div>    if img.getpixel((i, i)) != (255, 255, 255):</div><div>        print(chr(img.getpixel((i, i))[1]), end='')</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ZmxhZ3tjNmU0Yzk5YTYzODhjNWQyYTlhZTZlZjZhODQzY2VhNn0=</div></div><div>然后base64解码得到flag。</div><div><br/></div><div>flag：flag{c6e4c99a6388c5d2a9ae6ef6a843cea6}</div><div><br/></div><div><span style="font-weight: bold;">92 music</span></div><div>题目：提示：来听段音乐 let’s enjoy the music hint1:注意观察音轨(Pay attention to the audio track) hint2:不用audicity和隐写的一些软件来尝试解题 (it is not possible to solve this challenge with audicity or some stego softwares) hint3:波形不是波形</div><div><br/></div><div>下载得到pk格式和wav格式文件。先看后者，虽然提示说不样用audacity，但还是先audacity打开看看：</div><div><img src="BMZCTF Misc 18（89-92）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>上方声道出现了间隔的长短音，很明显是摩斯电码，记录下来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</div></div><div>解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>5BC925649CB0188F52E617D70929191C</div></div><div>包上flag格式提交成功。所以pk文件是干什么的，为什么提示不让用audacity，预期解难道是人耳直接听出摩斯电码，不明白。</div><div><br/></div><div>flag：flag{5BC925649CB0188F52E617D70929191C}</div></span>
</div></body></html> 