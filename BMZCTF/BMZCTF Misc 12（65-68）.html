<html>
<head>
  <title>BMZCTF Misc 12（65-68）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="5733"/>
<h1>BMZCTF Misc 12（65-68）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">65 [RoarCTF2020]Hi_433MHz</span></div><div><br/></div><div>下载得到rf.s8文件，没见过的扩展名，file命令看一下文件类型：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# file rf.s8</div><div>rf.s8: data</div></div><div>嗯……所以是某种数据的文件，从文件名里的MHz这个单位来看可能是与声音相关的数据，尝试拖进audacity：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>按说明导入数据，选项看不懂，暂时保持默认：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>拉伸一下横坐标轴，可以看到长音和短音组成的多组声音信号：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>观察一下规律：</div><div>1、每组有9个声音信号；</div><div>2、每组的开头和结尾必然是短音。</div><div>尝试将长音和短音分别替换成1和0，记录开头四组：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>011001100 011011000 011000010 011001110</div></div><div>联想到 flag 的二进制ASCII码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01100110 01101100 01100001 01100111</div></div><div>显然每组声音信号去掉末尾的0就是对应字符的二进制ASCII码。</div><div><br/></div><div>记录全部声音信号：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>011001100 011011000 011000010 011001110 011110110 001100100 001101010 011000110 001100100 001100010 011000100 001100000 011001000 001011010 001101100 011000010 001100010 001100010 001011010 001101000 001100110 001100010 001100100 001011010 001110010 001101110 001100010 011000100 001011010 001101000 001100100 001110000 011001000 001100000 001100010 011000110 011001000 011000110 001101010 001100110 001101000 011111010</div></div><div>去掉每组末尾的0：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01100110 01101100 01100001 01100111 01111011 00110010 00110101 01100011 00110010 00110001 01100010 00110000 01100100 00101101 00110110 01100001 00110001 00110001 00101101 00110100 00110011 00110001 00110010 00101101 00111001 00110111 00110001 01100010 00101101 00110100 00110010 00111000 01100100 00110000 00110001 01100011 01100100 01100011 00110101 00110011 00110100 01111101</div></div><div>二进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{25c21b0d-6a11-4312-971b-428d01cdc534}</div></div><div><br/></div><div>flag：flag{25c21b0d-6a11-4312-971b-428d01cdc534}</div><div><br/></div><div><span style="font-weight: bold;">66 crymisc</span></div><div><br/></div><div>下载得到docx格式文件。直接打开报错：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>用7-Zip作为压缩文件打开，内含1.txt和3.jpg，注意到3.jpg是加密压缩的：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>尝试解压，1.txt中不含有效信息，同时可以发现用7-Zip解压3.jpg时未弹出密码输入框，而是直接提示密码错误：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>说明伪加密的可能性很大，ZIpCenOp处理一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\暴力破解\ZipCenOp&gt;java -jar ZipCenOp.jar r crymisc.docx</div><div>success 2 flag(s) found</div></div><div>然后解压得到3.jpg。</div><div><br/></div><div>十六进制编辑器打开3.jpg，文件尾后有额外数据：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>首先是一段字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SSB3YXMgcmVqZWN0ZWQuLi4uLi5USElTIElTIFRIRSBQQVNTV09SRDpJIFdhbm5hIENyeXl5ISEh</div></div><div>base64解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>I was rejected......THIS IS THE PASSWORD:I Wanna Cryyy!!!</div></div><div>接下来注意到字符串之后，0x31AE开始的两字节为03 04，结合后续字节可以判定这是一个缺少了文件头两字节50 4B的zip格式压缩包。将其提取后补全文件头，获取加密压缩包，用base64解码获得的密码解压，得到crymisc.txt：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>🔭💙🐰✊🌻🐧💙😘🌻🍶💐🍌🏊🍩🚁🏊👹🐶😀🐶😀😘👹💙🍂💇😀😀😩🌻🍟👂🍶💐🍌🏊🍩👆🏠🙇🍂🍂👼😱🚔🐶👉✊😱🏠🙇🍂🍂👼😱🚊😧💨💙💕</div><div>That is what i told her↑↑↑</div></div><div>是一串emoji。常见的以emoji为密文的加密方式包括<a href="https://foundation.mozilla.org/en/campaigns/codemoji/">codemoji</a>、<a href="https://aghorler.github.io/emoji-aes/">emoji-aes</a>或以emoji符号为字符表的<a href="https://github.com/AdamNiederer/base100">base100</a>，经过尝试可以排除base100以及需要密钥的emoji-aes。由Mozilla开发的codemoji虽然也需要密钥，但其密钥为单个emoji符号，因此可以在有限时间内爆破。</div><div><br/></div><div>从github找到对应的<a href="https://github.com/pavelvodrazka/ctf-writeups/tree/master/hackyeaster2018/challenges/egg17/files/cracker">cracker</a>工具，打开cracker.html，填入密文后点击Decrypt：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>从而得到密钥和明文。</div><div><br/></div><div>flag：GACTF{H4ppy_Mi5c_H4ppy_L1fe}</div><div><br/></div><div><span style="font-weight: bold;">67 [2020首届祥云杯]xixixi</span></div><div>题目：室友最近沉迷y神，又氪又肝，还ghs。为了他的身体着想，我把他的s图整没了。但我明明删了脚本啊，为什么还能被他发现......8说了，医院的空调真舒服~。</div><div><br/></div><div>下载得到vhd格式文件。这是微软虚拟磁盘（Microsoft Virtual Hard Disk format）格式镜像，用DiskGenius打开：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>可以找到一张kejin.png，但文件结构已被损坏，用可以忽略错误的图片查看器打开也仅能看到最上方一部分内容。根据题目内容，有某个脚本被删掉了，查看一下回收站目录：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>有4个py格式文件，恢复后逐个查看，发现$RQLO56E.py和$RXSRKT0.py中有可识别内容，分别为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import struct</div><div><br/></div><div>class FAT32Parser(object):</div><div>    def __init__(self, vhdFileName):</div><div>        with open(vhdFileName, 'rb') as f:</div><div>            self.diskData = f.read()</div><div>        self.DBR_off = self.GetDBRoff()</div><div>        self.newData = ''.join(self.diskData)  # 后续步骤需要注释掉这一行再继续，否则运行可能报错</div><div><br/></div><div>    def GetDBRoff(self):</div><div>        DPT_off = 0x1BE</div><div>        target = self.diskData[DPT_off+8:DPT_off+12]</div><div>        DBR_sector_off, = struct.unpack(&quot;&lt;I&quot;, target)</div><div>        return DBR_sector_off * 512</div><div><br/></div><div>    def GetFAT1off(self):</div><div>        target = self.diskData[self.DBR_off+0xE:self.DBR_off+0x10]</div><div>        FAT1_sector_off, = struct.unpack(&quot;&lt;H&quot;, target)</div><div>        return self.DBR_off + FAT1_sector_off * 512</div><div><br/></div><div>    def GetFATlength(self):</div><div>        target = self.diskData[self.DBR_off+0x24:self.DBR_off+0x28]</div><div>        FAT_sectors, = struct.unpack(&quot;&lt;I&quot;, target)</div><div>        return FAT_sectors * 512</div><div><br/></div><div>    def GetRootoff(self):</div><div>        FAT_length = self.GetFATlength()</div><div>        FAT2_off = self.GetFAT1off() + FAT_length</div><div>        return FAT2_off + FAT_length</div><div><br/></div><div>    def Cluster2FAToff(self, cluster):</div><div>        FAT1_off = self.GetFAT1off()</div><div>        return FAT1_off + cluster * 4</div><div><br/></div><div>    def Cluster2DataOff(self, cluster):</div><div>        rootDir_off = self.GetRootoff()</div><div>        return rootDir_off + (cluster - 2) * 512</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import struct</div><div>from xixi import FAT32Parser</div><div>from xixixi import Padding, picDepartList</div><div><br/></div><div>def EncodePieces():</div><div>    global clusterList</div><div>    res = []</div><div>    Range = len(picDepartList)    # 58</div><div>    # GetRandomClusterList(n) - Generate a random cluster list with length n</div><div>    clusterList = GetRandomClusterList(Range)</div><div><br/></div><div>    for i in range(Range):</div><div>        if i != Range - 1:</div><div>            newCRC = struct.pack(&quot;&lt;I&quot;, clusterList[i+1])</div><div>            plainData = picDepartList[i][:-4] + newCRC</div><div>        else:</div><div>            plainData = picDepartList[i]</div><div><br/></div><div>        # Show the first piece to him, hhh</div><div>        if i == 0:</div><div>            newPiece = plainData</div><div>        else:</div><div>            newPiece = ''</div><div>            key = clusterList[i] &amp; 0xFE</div><div>            for j in plainData:</div><div>                newPiece += chr(ord(j) ^ key)</div><div>        # Padding() -- Fill to an integral multiple of 512 with \xFF</div><div>        res.append(Padding(newPiece))</div><div>    return res</div></div><div>后者import的两个库中，xixi显然就是$RQLO56E.py，xixixi暂时未知。整理一下后者的代码逻辑：</div><div>1、将图片整体分为58块，并准备将其随机分布于磁盘中的不同簇中；</div><div>2、除了最后一块以外，每块的最后四位CRC校验字节被替换成了下一块的簇号；</div><div>3、除了第一块以外，每块的字节都与key进行了异或加密，key的值是 该块的簇号 &amp; 0xFE 的结果。</div><div>可以发现，打乱后的58块实际上是分布在磁盘的不连续簇中的，磁盘操作由xixi中的FAT32Parser类执行。因此挂载镜像后直接导出的kejin.png中并不包含完整数据，后续块的数据需要直接从镜像中取得。</div><div><br/></div><div>重命名xixi.py，然后写个还原脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import binascii</div><div>from xixi import FAT32Parser</div><div><br/></div><div>def xor(bindata, key):</div><div>    out = b''</div><div>    for i in bindata:</div><div>        out += (i ^ key).to_bytes(1, 'big')</div><div>    return out</div><div><br/></div><div>data = open('C:/Users/Administrator/Desktop/new.vhd', 'rb')</div><div>res = open('C:/Users/Administrator/Desktop/kejin.png', 'ab')</div><div>start = data.read().index(b'\x89\x50\x4e\x47')</div><div>data.seek(start)</div><div>res.write(data.read(8))</div><div><br/></div><div>FAT = FAT32Parser('C:/Users/Administrator/Desktop/new.vhd')</div><div>key = 0</div><div><br/></div><div>while True:</div><div>    length, ctype = xor(data.read(4), key), xor(data.read(4), key)</div><div>    dat = xor(data.read(int.from_bytes(length, 'big')), key)</div><div>    crc = xor(data.read(4), key)</div><div>    res.write(length + ctype + dat + crc) # 没有改为正确CRC，因此部分图片查看器中可能无法正确显示</div><div><br/></div><div>    if  binascii.crc32(ctype + dat) &amp; 0xffffffff != int.from_bytes(crc, 'big'):</div><div>        cluster = int.from_bytes(crc, 'little')</div><div>        print(cluster)</div><div>        data.seek(FAT.Cluster2DataOff(cluster))</div><div>        key = cluster &amp; 0xFE</div><div><br/></div><div>    if ctype == b'IEND':</div><div>        break</div></div><div>运行得到图片（已缩小）：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>按照从上往下顺序拼接得到flag。</div><div><br/></div><div>flag：flag{0cfdd1ad80807da6c0413de606bb0ae4}</div><div><br/></div><div><span style="font-weight: bold;">68 2018 hackergame 游园会的集章卡片</span></div><div><br/></div><div>下载得到题目描述.docx和25张文件名为乱码的PNG格式图片：</div><div><img src="BMZCTF Misc 12（65-68）_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>题目描述有点长，总结一下就是要拼图，那么就开始拼。</div><div><br/></div><div>首先用ImageMagick的montage命令把图片拼成5x5的一大张，5x5是根据题目描述里的样图判断的：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop\fragments&gt;magick montage *.png -tile 5x5 -geometry 125x125+0+0 out.png</div></div><div><img src="BMZCTF Misc 12（65-68）_files/out.png" type="image/png" data-filename="out.png"/></div><div>然后上gaps：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/gaps/bin# python gaps --image=out.png --generations=50 --population=25 --size=125 --save</div></div><div>由于原图画面比较简单，可能会跑出比较微妙的结果，例如：</div><div><img src="BMZCTF Misc 12（65-68）_files/out_solution.jpg" type="image/jpeg" data-filename="out_solution.jpg"/></div><div>实际上已经足够看出flag，当然有强迫症的话也可以多跑几遍找到更好的结果（话说在前面，不一定能找到），或者用顺手的图像编辑软件自己再拼一下。</div><div><br/></div><div>flag：flag{H4PPY_1M4GE_PR0CE551NG}</div></span>
</div></body></html> 