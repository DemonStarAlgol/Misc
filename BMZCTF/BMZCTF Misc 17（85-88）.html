<html>
<head>
  <title>BMZCTF Misc 17（85-88）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="6039"/>
<h1>BMZCTF Misc 17（85-88）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">85 [2021-红明谷]我的心是冰冰的</span></div><div><br/></div><div>下载得到无扩展名文件rar。十六进制编辑器查看，文件格式与RAR格式压缩文件一致，但重命名后直接打开报错：</div><div><img src="BMZCTF Misc 17（85-88）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>懒得看到底哪里文件结构被破坏了，直接用WinRAR的工具-修复压缩文件：</div><div><img src="BMZCTF Misc 17（85-88）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>修复完的压缩包就可以正常解压了。顺带一提本题大概是RAR伪加密，其他解法可参考<a href="evernote:///view/30668439/s39/017623e3-7c3d-41ec-94e5-cc293d0ee728/017623e3-7c3d-41ec-94e5-cc293d0ee728/" style="color: rgb(105, 170, 53);">BUUCTF Misc 64（301-304）</a>303题。</div><div><br/></div><div>解压得到bingbing.jpg和bingbing.zip，后者是加密压缩包。先看前者。各类常见隐写方式没有找到隐藏信息，考虑现成隐写工具，穷举尝试后发现是<a href="https://github.com/ww23/BlindWatermark">Java盲水印</a>：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>D:\CTFToolkit-v1.1.0\信息隐藏\JavaBlindWaterMark&gt;java -jar BlindWatermark.jar decode -c bingbing.jpg out.jpg</div></div><div>输出结果：</div><div><img src="BMZCTF Misc 17（85-88）_files/out.jpg" type="image/jpeg" data-filename="out.jpg"/></div><div>靠强而有力的眼神得到解压密码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>gnibgnib</div></div><div><br/></div><div>解压bingbing.zip得到bingbing.pcapng，wireshark打开：</div><div><img src="BMZCTF Misc 17（85-88）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>全都是USB协议流量，从设备到主机的数据包中数据长度为8字节，且仅第3字节的数据有变化，这是USB键盘流量的特征。直接用大佬的<a href="https://github.com/WangYihang/UsbKeyboardDataHacker">USB键盘流量一把梭脚本</a>梭一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# python UsbKeyboardDataHacker.py bingbing.pcapng</div><div>Running as user &quot;root&quot; and group &quot;root&quot;. This could be dangerous.</div><div>[+] Found : 666c61677b3866396564326639333365662&lt;DEL&gt;31346138643035323364303334396531323939637d</div></div><div>结果整理一下，将&lt;DEL&gt;前一个字符删除，然后十六进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{8f9ed2f933ef14a8d0523d0349e1299c}</div></div><div><br/></div><div>flag：flag{8f9ed2f933ef14a8d0523d0349e1299c}</div><div><br/></div><div><span style="font-weight: bold;">86 2020sdnisc-CTF的起源</span></div><div><br/></div><div>下载得到txt格式文件，看一下内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Q1RGIChDYXB0dXJlIFRoZSBGbGFnKSBpcyBvcmlnaW5hdGVkIG==</div><div>aW4gdGhlIDE5OTYgREVGQ09OIEdsb2JhbCBIYWNraW5nIENvbmZlcmVuY2UsIG==</div><div>YSBjb21wZXRpdGl2ZSBnYW1lIGFtb25nIGN5YmVyc2VjdXJpdHkgZW50aHVzaWFzdHMu</div><div>VGhlIENURiBjb21wZXRpdGlvbiBjb3ZlcnMgYSB3aWRl</div><div>cmFuZ2Ugb2YgZmllbGRzIGFuZCBoYXMgYSB=</div><div>Y29tcGxleCBjb250ZW50LiBBdCB0aGUgc2FtZSB0aW1lLCC=</div></div><div>有很多行base64编码，联想到base64隐写，其特征是，末尾带有=的行，解码后再编码，末尾部分字符会出现差异。那么就来验证一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>原文：Q1RGIChDYXB0dXJlIFRoZSBGbGFnKSBpcyBvcmlnaW5hdGVkI<span style="color: rgb(255, 0, 0);">G</span>==</div><div>解码：CTF (Capture The Flag) is originated</div><div>编码：Q1RGIChDYXB0dXJlIFRoZSBGbGFnKSBpcyBvcmlnaW5hdGVkI<span style="color: rgb(255, 0, 0);">A</span>==</div></div><div><br/></div><div>判定为base64隐写，这样一来就不需要每行解码，直接套base64隐写脚本即可：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import re</div><div>import base64</div><div><br/></div><div>b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</div><div><br/></div><div>f = open('base64stego.txt', 'r')</div><div>base64str = f.readline()</div><div><br/></div><div>pattern2 = r'(\S)==$'</div><div>pattern1 = r'(\S)=$'</div><div><br/></div><div>binstring = ''</div><div><br/></div><div>while(base64str):</div><div>    if <a href="http://re.compile(pattern2).findall(base64str/">re.compile(pattern2).findall(base64str</a>):</div><div>        mstr = <a href="http://re.compile(pattern2).findall(base64str/">re.compile(pattern2).findall(base64str</a>)[0]</div><div>        mbin = bin(b64chars.find(mstr))</div><div>        mbin2 = mbin[0:2] + mbin[2:].zfill(6)</div><div>        stegobin = mbin2[-4:]</div><div>        binstring += stegobin</div><div>    elif <a href="http://re.compile(pattern1).findall(base64str/">re.compile(pattern1).findall(base64str</a>):</div><div>        mstr = <a href="http://re.compile(pattern1).findall(base64str/">re.compile(pattern1).findall(base64str</a>)[0]</div><div>        mbin = bin(b64chars.find(mstr))</div><div>        mbin2 = mbin[0:2] + mbin[2:].zfill(6)</div><div>        stegobin = mbin2[-2:]</div><div>        binstring += stegobin</div><div>    base64str = f.readline()</div><div>for i in range(0, len(binstring), 8):</div><div>    print(chr(int(binstring[i:i+8], 2)), end='')</div></div><div>运行结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{944776b2c95a350bb27d7038d42b273a</div></div><div><br/></div><div>flag：flag{944776b2c95a350bb27d7038d42b273a}</div><div><br/></div><div><span style="font-weight: bold;">87 2020sdnisc-简单的js</span></div><div><br/></div><div>下载得到js格式文件。看一下代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Pseudo md5 hash function</div><div>* @param {string} string</div><div>* @param {string} method The function method, can be 'ENCRYPT' or 'DECRYPT'</div><div>* @return {string}</div><div>*/</div><div>function pseudoHash(string, method) {</div><div>  // Default method is encryption</div><div>  if (!('ENCRYPT' == method || 'DECRYPT' == method)) {</div><div>    method = 'ENCRYPT';</div><div>  }</div><div>  // Run algorithm with the right method</div><div>  if ('ENCRYPT' == method) {</div><div>    // Variable for output string</div><div>    var output = '';</div><div>    // Algorithm to encrypt</div><div>    for (var x = 0, y = string.length, charCode, hexCode; x &lt; y; ++x) {</div><div>      charCode = string.charCodeAt(x);</div><div>      if (128 &gt; charCode) {</div><div>        charCode += 128;</div><div>      } else if (127 &lt; charCode) {</div><div>        charCode -= 128;</div><div>      }</div><div>      charCode = 255 - charCode;</div><div>      hexCode = charCode.toString(16);</div><div>      if (2 &gt; hexCode.length) {</div><div>        hexCode = '0' + hexCode;</div><div>      }</div><div>      </div><div>      output += hexCode;</div><div>      </div><div>    }</div><div>    // Return output</div><div><br/></div><div>    return output;</div><div>  } else if ('DECRYPT' == method) {</div><div>    // DECODE MISS</div><div>    // Return ASCII value of character</div><div>    return string;</div><div>  }</div><div>}</div><div>document.getElementById('password').value = pseudoHash('19131e18041b1d4c47191d19194f1949481a481a1d4c1c461b4d484b191b4e474f1e4b1d4c02', 'DECRYPT');</div></div><div>加密函数的大致逻辑是，对每个字节，若在0-127之间，则加上128，否则减去128，然后输出其与255的差的十六进制形式。但实际上既然输入值为可打印字符串，那么每个字节必然在0-127之间。从而可以写出解密脚本如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>s = '19131e18041b1d4c47191d19194f1949481a481a1d4c1c461b4d484b191b4e474f1e4b1d4c02'</div><div>for i in range(0, len(s), 2):</div><div>    print(chr(127 - int(s[i: i+2], 16)), end='')</div></div><div>运行得到flag。</div><div><br/></div><div>flag：flag{db38fbff0f67e7eb3c9d274fd180a4b3}</div><div><br/></div><div><span style="font-weight: bold;">88 2020sdnisc-损坏的流量包</span></div><div><br/></div><div>下载得到pcapng格式文件。尝试用wireshark打开：</div><div><img src="BMZCTF Misc 17（85-88）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>哦呼，打不开。十六进制编辑器查看：</div><div><img src="BMZCTF Misc 17（85-88）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>发现有可以识别的类似URL的字符串，说明流量包的数据部分还在，很可能只有pcapng格式文件的数据结构被修改了。那么想一想，不会用wireshark时我们是怎么做流量分析的呢？所以就来试一下strings、binwalk和foremost吧。</div><div><br/></div><div>先是strings：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# strings 1.pcapng</div><div>……（前略）</div><div>{}sR</div><div>{}sR</div><div>Counters provided by dumpcap</div><div>key.txtUT</div><div>ZmxhZ3tzZG5pc2NfbmV0X3NRMlgzUTl4fQ==</div><div>key.txtUT</div></div><div>有个开头很熟悉的base64编码字符串，解个码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{sdnisc_net_sQ2X3Q9x}</div></div><div><br/></div><div>虽然有了flag，但还是用binwalk或foremost再试试：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# foremost 1.pcapng</div><div>Processing: 1.pcapng</div><div>|foundat=key.txtUT</div><div>*|</div><div>root@kali:~/Desktop# tree output</div><div>output</div><div>├── audit.txt</div><div>└── zip</div><div>    └── 00000220.zip</div><div><br/></div><div>1 directory, 2 files</div></div><div>提取到了一个zip压缩包，看一下内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# unzip -l ./output/zip/00000220.zip</div><div>Archive:  ./output/zip/00000220.zip</div><div>  Length      Date    Time    Name</div><div>---------  ---------- -----   ----</div><div>       37  2020-10-30 05:24   key.txt</div><div>---------                     -------</div><div>       37                     1 file</div><div><br/></div><div>root@kali:~/Desktop# unzip ./output/zip/00000220.zip -d ./</div><div>Archive:  ./output/zip/00000220.zip</div><div>extracting: ./key.txt               </div><div>root@kali:~/Desktop# cat key.txt</div><div>ZmxhZ3tzZG5pc2NfbmV0X3NRMlgzUTl4fQ==</div></div><div>跟之前得到的base64编码字符串完全相同。事实上strings得到的结果里这段base64编码前后之所以会有两个key.txt，就是因为识别到了这个以存储模式压缩的zip压缩包中被压缩文件名的部分。后续步骤和前面相同。</div><div><br/></div><div>flag：flag{sdnisc_net_sQ2X3Q9x}</div></span>
</div></body></html> 