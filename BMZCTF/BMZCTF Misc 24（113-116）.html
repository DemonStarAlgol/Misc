<html>
<head>
  <title>BMZCTF Misc 24（113-116）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="8636"/>
<h1>BMZCTF Misc 24（113-116）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">113 </span><span style="font-weight: bold;">[2021CISCN线上赛]robot</span></div><div>题目：分析给出的机器人仿真程序和流量包，提取机器人程序控制机器人写出的字符串，flag为&quot;CISCN{md5(机器人绘制的字符串)}&quot;，(md5值小写)</div><div><br/></div><div>下载附件得到一个pcapng格式流量包，一个Robot.rspag文件，一个Control文件夹。</div><div><br/></div><div>文件夹里有几个dll文件和一个Robot Control.exe可执行文件，运行了一下当场报错……好像是.NET环境的问题。扩展名rspag搜索了一下是一个机器人仿真程序RobotStudio的工程文件。那么大致可以猜测Robot.rspag和Control文件就是题目里提到的机器人仿真程序，剩下的就是流量包。预期步骤可能是用RobotStuido打开仿真程序确认机器人绘图时传输的参数格式，再从流量包里找到相应的参数还原绘图路径。<span style="font-size: unset; color: unset; font-family: unset;">RobotStudio相关部分可以</span>参考<a href="http://www.snowywar.top/?p=2190">魔法少女雪殇的WP</a><span style="font-size: unset; color: unset; font-family: unset;">。</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">我这里不想装多余软件，</span><span style="font-size: unset; color: unset; font-family: unset;">尝试一下能否仅通过流量包找到线索。wireshark打开，统计-会话：</span></div><div><img src="BMZCTF Misc 24（113-116）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>合计只有三条TCP流，从传输的数据量来看主要内容应该在流0中。实际上流1是TLS协议，没有密钥暂时无法解密，流3是HTTP流，一直在重复访问同一个地址和返回同样的内容。</div><div><br/></div><div>那么来看TCP流0，合计三万多个数据包，主要在本地的49824和49825端口间通信。直接追踪TCP流：</div><div><img src="BMZCTF Misc 24（113-116）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: unset;">不难发现从1086号数据包开始，出现了大量从49825端口发往49824端口的数据包，其中包含类似这样的内容：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>GET·/127.0.0.1/·CurrentMaster2·-Domain RAPID</div></div><div>注意其中的 · 实际上是00字节。从格式来看这很可能是向机器人仿真程序传输的命令数据。反方向传回的数据看起来则可能是仿真程序返回的结果，例如几次传输-Domain RAPID都得到了-Status NoMaster的结果。</div><div><br/></div><div>在追踪流窗口将全部数据按ASCII格式另存为文本文件（这样一来所有不可打印字符将变成点.，包括00字节），然后用以下脚本提取所有看起来类似刚才看到的命令的内容：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import re</div><div><br/></div><div>f = open('C:/Users/Administrator/Desktop/1.txt', 'r').read()</div><div>r = r'[GS]ET\.\/127\.0\.0\.1\/.*?\.\.'</div><div>s = re.findall(r, f)</div><div><br/></div><div>out = open('C:/Users/Administrator/Desktop/2.txt', 'a')</div><div>for i in s:</div><div>    out.write(i + '\n')</div></div><div>得到结果：</div><div><img src="BMZCTF Misc 24（113-116）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>可以看到从第90条命令开始，大约每隔十条出现了三个数字的参数。提取出来看一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import re</div><div><br/></div><div>f = open('C:/Users/Administrator/Desktop/1.txt', 'r').read()</div><div>r = r'\[\d+,\d+,\d+\]'</div><div>s = re.findall(r, f)</div><div>for i in s:</div><div>    print(i)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>[27,36,0]</div><div>[28,35,0]</div><div>[29,35,0]</div><div>[31,35,0]</div><div>[32,35,0]</div><div>[33,35,0]</div><div>……（后略）</div></div><div>观察一下规律，最后一个数字均为0，前两个数字呈现较为连续的变化趋势，符合操作机器人进行绘画时坐标的变化特征。此外三元的数组也符合机器人的操作壁应该可以在三维空间运动的特征，有理由怀疑这是一组连续变化的坐标。</div><div><br/></div><div>最后将这些坐标绘制成图像：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import re</div><div>from PIL import Image</div><div><br/></div><div>f = open('C:/Users/Administrator/Desktop/1.txt', 'r').read()</div><div>r = r'\[(\d+),(\d+),0\]'</div><div>s = re.findall(r, f)</div><div><br/></div><div>axis1, axis2 = [int(i[0]) for i in s], [int(i[1]) for i in s]</div><div>img = Image.new('1', (max(axis1)+20, max(axis2)+20), 0)</div><div>for x, y in zip(axis1, axis2):</div><div>    img.putpixel((x, y), 255)</div><div>img.save('C:/Users/Administrator/Desktop/1.png')</div></div><div>得到：</div><div><img src="BMZCTF Misc 24（113-116）_files/1.png" type="image/png" data-filename="1.png"/></div><div>转MD5：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>easy_robo_xx</div><div>d4f1fb80bc11ffd722861367747c0f10</div></div><div><br/></div><div>最后再重复一下，从仿真程序入手，不需要猜的正规做法请参照<a href="http://www.snowywar.top/?p=2190">魔法少女雪殇的WP</a><span style="font-size: unset; color: unset; font-family: unset;">。</span></div><div>flag：CISCN{d4f1fb80bc11ffd722861367747c0f10}</div><div><br/></div><div><span style="font-weight: bold;">114 [2021强网拟态]Bar</span></div><div><br/></div><div>下载得到gif格式文件。图像大小为20x100，共334帧，每帧只有黑白灰三种颜色。</div><div><br/></div><div>先提取信息，暂时以黑色为0，白色为1，灰色为2尝试转换每帧颜色：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/output.gif')</div><div><br/></div><div>res = '0'</div><div>for i in range(1, 334):</div><div>    img.seek(i)</div><div>    p = img.getpixel((0, 0))[0]</div><div>    res += str({0: 0, 255: 1, 56: 2}[p])</div><div>print(res)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>010120002011212000012111002<font color="#FF0000">010100001</font>001110101011101011001011101011011101010111011001101011001011011011110101010101111010111101011011101011101101011010111001101011001011011001101011001010111011101101011110101011011101001110101011110101001011101011011011001110101011011101001101011011110101011011101010111011111111111111111111<font color="#FF0000">010100001</font>0</div></div><div>观察规律，发现2（即灰色帧）只在接近开头部分出现了6次，且每两个2之间最多有5帧。如果将2看作分隔符，被其分隔的内容为：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>0101 000 011 1 00001 11100</div></div><div>两种符号、不定长、最长为5位，符合摩斯电码的特征，尝试后发现0对应长音，1对应短音：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>-.-. --- -.. . ----. ...--</div><div>code93</div></div><div><br/></div><div><a href="https://en.wikipedia.org/wiki/Code_93">Code93</a>是一种一维条形码，为Code39的更新版本。查阅文档可知，其开头/结尾标识是101011110。注意这里的1代表黑色条，即黑白黑白黑黑黑黑白。对比一下可知，这与附件中最后一个灰色帧之后的动画帧序列是相符的，对应上方输出结果中标红部分。那么把这段提取出来还原成条形码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>C:\Users\Administrator\Desktop&gt;magick convert output.gif ./tmp/frame%03d.png</div><div>（手动删除000-026.png）</div><div>C:\Users\Administrator\Desktop\tmp&gt;magick montage *.png -tile 307x1 -geometry 20x100+0+0 out.png</div><div>C:\Users\Administrator\Desktop\tmp&gt;magick convert out.png -resize 1228x500! out1.png</div></div><div><img src="BMZCTF Misc 24（113-116）_files/out1.png" type="image/png" data-filename="out1.png"/></div><div>可以看出这个条形码很明显缺失了结束标识前的一段。参考<a href="https://web.archive.org/web/20090225114452/http://www.barcodeisland.com/code93.phtml">编码规则</a>（<a href="http://www.appsbarcode.com/sc20130113/Code%2093.php">中文版</a>），Code93编码由开始标识、数据区、模47校验码C、模47校验码K和结束标识组成，其中每个标识（以及数据区的每个字符）都由宽度为9的三黑三百六条线构成。因此这里实际上缺失了两位校验码，从而无法扫描。</div><div><br/></div><div>改为直接提取编码数据然后根据编码表解码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>import re</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/output.gif')</div><div>chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%'</div><div>codes = ['100010100', '101001000', '101000100', '101000010', '100101000', '100100100', '100100010', '101010000', '100010010', '100001010', '110101000', '110100100', '110100010', '110010100', '110010010', '110001010', '101101000', '101100100', '101100010', '100110100', '100011010', '101011000', '101001100', '101000110', '100101100', '100010110', '110110100', '110110010', '110101100', '110100110', '110010110', '110011010', '101101100', '101100110', '100110110', '100111010', '100101110', '111010100', '111010010', '111001010', '101101110', '101110110', '110101110']</div><div><br/></div><div>res = ''</div><div>for i in range(36, 307):</div><div>    img.seek(i)</div><div>    p = img.getpixel((0, 0))[0]</div><div>    res += str(1 - p // 255)</div><div>c = re.findall(r'.{9}', res)</div><div><br/></div><div>n = [codes.index(i) for i in c]</div><div>print(''.join([chars[i] for i in n]))</div></div><div>得到结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>F0C62DB973684DBDA896F9C5F6D962</div></div><div>可以手动计算出两个校验位然后画出条形码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># 校验位</div><div>n.append(sum([n[i] * ((len(n) - 1 - i) % 20 + 1) for i in range(len(n))]) % 47)</div><div>n.append(sum([n[i] * ((len(n) - 1 - i) % 15 + 1) for i in range(len(n))]) % 47)</div><div>print(''.join([chars[i] for i in n]))</div><div><br/></div><div>t = ''.join([codes[i] for i in n])</div><div>t = '101011110' + t + '101011110'</div><div>ti = Image.new('1', (len(t), 1), 255)</div><div>for i in range(len(t)):</div><div>    if t[i] == '1':</div><div>        ti.putpixel((i, 0), 0)</div><div>ti =ti.resize((len(t) * 4, 150), Image.Resampling.LANCZOS)</div><div>ti.save('C:/Users/Administrator/Desktop/1.png')</div></div><div><img src="BMZCTF Misc 24（113-116）_files/1 [1].png" type="image/png" data-filename="1.png"/></div><div>可以看出和上面得到的缺少校验位的条形码是大体一致的，也可以正常扫描出来。</div><div><br/></div><div>但<span style="color: unset; font-family: unset; font-size: unset;">根据网上的部分WP（</span><a href="https://jishuin.proginn.com/p/763bfbd6a660" style="font-family: unset; font-size: unset;">1</a> <a href="https://blog.csdn.net/qq_49422880/article/details/123953109" style="font-family: unset; font-size: unset;">2</a><span style="color: unset; font-family: unset; font-size: unset;"> </span><a href="https://github.com/ChaMd5Team/Venom-WP/blob/main/2021-%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81%E9%98%B2%E5%BE%A1%E5%9B%BD%E9%99%85%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B-WriteUp.pdf" style="font-family: unset; font-size: unset;">3</a><span style="color: unset; font-family: unset; font-size: unset;">）说法，需要将两位校验码对应的字符也计入flag，且flag中的字母为全小写。并且这些WP中的两位校验码（um）和上述脚本得到的校验码（W空格）并不一致。对此我进行了一点考证。首先，这些WP中的解法到手动读取二进制串解码为止都是一致的，结果也均为：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>F0C62DB973684DBDA896F9C5F6D962</div></div><div>但这些WP后续的步骤采取了另一种方法，即：</div><div>1、先将上述字符串转为小写；</div><div>2、用在线工具生成这段字符串的Code93条形码；</div><div>3、从条形码图像中识别两位校验码并根据编码表转为字符。</div><div><br/></div><div>这就产生了一个问题，原版的Code93（也有地方称为Code93 Standard）的47字符表不包含小写字母，仅包含大写字母。因此，用小写字母去生成Code93条形码，实际上用的将会是Full ASCII Code 93（也有地方称为Code93 Extended），其编码表可以编码完整的128位ASCII码。但其实现仍然基于原来的47字符表，通过在部分字符前增加或组合43、44、45、46这四个未被使用的控制符，以支持原编码表中未出现的字符，例如小写字母。具体的编码表参见<a href="https://en.wikipedia.org/wiki/Code_93">维基百科</a>或<a href="http://www.appsbarcode.com/sc20130113/Code%2093.php">编码介绍</a>。</div><div><span style="font-size: unset; color: unset; font-family: unset;">实际上，Full ASCII Code 93中的小写字母，是在大写字母前增加46号编码符(+)实现的，因此如果对比一下从附件gif中生成的条形码和这些WP中生成的条形码：</span></div><div><img src="BMZCTF Misc 24（113-116）_files/145cefa2579f8bfbc0de233a1c6a6180.png" type="image/png" data-filename="145cefa2579f8bfbc0de233a1c6a6180.png"/></div><div>会发现很明显WP里的条形码要长很多，这是因为所有的小写字母前都多了一位编码46/(+)/100110010的原因。既然数据区的编码内容发生了改变，校验码当然也就有所不同。这就是为何这些WP会得到校验码为um（实际上即使按照Full ASCII Code 93编码规则也应该是UM）的原因。</div><div>因为无法找到官方给出的WP和flag，也没有找到原题的提示和描述，无法确定究竟是缺少了比赛当时题目说明或hint中给出的额外提示，还是题目本身忘了区分Code93与Full ASCII Code 93，总之有点难受。</div><div><br/></div><div>不管怎么样还是给一个能得到网上WP版本flag的脚本。得到这个结果需要添加额外的条件：1、将附件中Code93条形码对应的字符串转小写；2、小写字符串重新生成Full ASCII Code 93条形码；3、取得Full ASCII Code 93条形码的两个校验位；4、将校验位对应的编码字符再次转小写后附加在前述字符串以后。按照这个步骤得到的flag才是下面的flag。脚本如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>import re</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/output.gif')</div><div>chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%'.lower()</div><div>codes = ['100010100', '101001000', '101000100', '101000010', '100101000', '100100100', '100100010', '101010000', '100010010', '100001010', '110101000', '110100100', '110100010', '110010100', '110010010', '110001010', '101101000', '101100100', '101100010', '100110100', '100011010', '101011000', '101001100', '101000110', '100101100', '100010110', '110110100', '110110010', '110101100', '110100110', '110010110', '110011010', '101101100', '101100110', '100110110', '100111010', '100101110', '111010100', '111010010', '111001010', '101101110', '101110110', '110101110']</div><div><br/></div><div>res = ''</div><div>for i in range(36, 307):</div><div>    img.seek(i)</div><div>    p = img.getpixel((0, 0))[0]</div><div>    res += str(1 - p // 255)</div><div>c = re.findall(r'.{9}', res)</div><div><br/></div><div>nx, n = [codes.index(i) for i in c], []</div><div>for i in nx:</div><div>    if chars[i].isalpha():</div><div>        n += [46, i]</div><div>    else:</div><div>        n += [i]</div><div><br/></div><div># 校验位</div><div>n.append(sum([n[i] * ((len(n) - 1 - i) % 20 + 1) for i in range(len(n))]) % 47)</div><div>n.append(sum([n[i] * ((len(n) - 1 - i) % 15 + 1) for i in range(len(n))]) % 47)</div><div>print(''.join([chars[i] for i in nx + n[-2:]]))</div></div><div><br/></div><div>flag：flag{f0c62db973684dbda896f9c5f6d962um}</div><div><br/></div></body></html> 