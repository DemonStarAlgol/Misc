<html>
<head>
  <title>BMZCTF Misc 15（77-80）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="5825"/>
<h1>BMZCTF Misc 15（77-80）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">77 BJDCTF-2020-Misc-just a rar</span></div><div><br/></div><div>下载得到加密压缩包4.rar。根据文件名，尝试爆破4位数密码：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>解压得到flag.jpg，右键查看属性，在exif信息中得到flag：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{Wadf_123}</div><div><br/></div><div><span style="font-weight: bold;">78 2018 redhat NotOnlyWireshark</span></div><div><br/></div><div>下载得到pcapng格式文件。用wireshark打开，统计-协议分级：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>按字节百分比，大部分数据在HTTP协议中，导出HTTP对象：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>可以看到从673分组开始，所有HTTP对象都是在向example2.php的name变量进行GET传参，且参数值均为三位十六进制数字。记录开头的几个参数值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>123 404 B03 040 A00</div></div><div>注意到与这段数字非常接近的50 4B 03 04是zip格式压缩文件的文件头。继续往下看：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>十六进制数字66 6C 61 67对应ASCII字符flag，根据zip文件格式，这可能是压缩包中文件的文件名。继续往下：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>接近末尾的位置出现了50 4B 05 06，这是zip格式压缩文件文件尾的特征。</div><div><br/></div><div>由此可以判断，将这些十六进制数字连接并修改开头后可以得到一个zip格式压缩文件的十六进制字节数据，且压缩包内含名为flag的文件。尝试提取这些数字：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# strings &quot;Not Only Wireshark.pcapng&quot; | grep &quot;example2.php?name=&quot; | rev | cut -c10-12 | rev | xargs</div><div>ker ?na ker %3E 3C/ 123 404 B03 040 A00 010 800 007 39C 8C4 B7B 36E 495 200 000 001 400 000 004 000 000 666 C61 678 1CD 460 EB6 201 516 8D9 E64 B06 FC1 712 365 FDE 5F9 879 16D D8A 524 16E 83F DE9 8FB 504 B01 023 F00 0A0 001 080 000 739 C8C 4B7 B36 E49 520 000 000 140 000 000 400 240 000 000 000 000 020 000 000 000 000 006 66C 616 70A 002 000 000 000 000 100 180 00D B39 B54 3D7 3D3 01A 1ED 915 43D 73D 301 F99 066 543 D73 D30 150 4B0 506 000 000 000 100 010 056 000 000 420 000 000 000</div></div><div>留下要用的部分并修改文件头：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>504B03040A0001080000739C8C4B7B36E495200000001400000004000000666C616781CD460EB62015168D9E64B06FC1712365FDE5F987916DD8A52416E83FDE98FB504B01023F000A0001080000739C8C4B7B36E4952000000014000000040024000000000000002000000000000000666C61670A00200000000000010018000DB39B543D73D301A1ED91543D73D301F99066543D73D301504B0506000000000100010056000000420000000000</div></div><div>在十六进制编辑器中保存为zip格式文件，得到加密的zip压缩包。</div><div><br/></div><div>尝试伪加密和爆破密码均无结果，猜测压缩包密码可能在流量包中。继续看HTTP对象列表：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>发现关键字key，接下来开始跟出题人对脑电波，对完脑电波得到密码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>?id=1128%23</div></div><div>最后解压得到flag。</div><div><br/></div><div>flag：flag{1m_s0_ang4y_1s}</div><div><br/></div><div><span style="font-weight: bold;">79 X*CTF 2021-puzzle</span></div><div><br/></div><div>下载得到png格式文件。看一下：</div><div><img src="BMZCTF Misc 15（77-80）_files/puzzle.png" type="image/png" data-filename="puzzle.png"/></div><div>图像大小为 1892 x 1075 ，横向44块，纵向25块，每个小块拼图的尺寸为 43 x 43。从图像内容来看，应该是在某张风景照片上写了黑色的flag再打乱成拼图，拼好就有flag。</div><div><br/></div><div>总之先祈祷出题人没有旋转每个小拼图块，试一下用gaps梭之：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/gaps/bin# python gaps --image=puzzle.png --generations=100 --population=1100 --size=43 --save</div></div><div>有一说一，运算量还是挺大的，要跑比较久的时间，而且最终效果未必很好，比如说这样：</div><div><img src="BMZCTF Misc 15（77-80）_files/puzzle_solution.jpg" type="image/jpeg" data-filename="puzzle_solution.jpg"/></div><div>白云部分拼合效果较好，花的部分由于图像内容太杂乱拼合效果非常差。可以依稀看出flag和what's here、{you等字样，但零碎的拼图块还是很多，考虑换个办法。</div><div><br/></div><div>观察一下gaps的拼图结果，发现干扰因素主要来自花丛部分。尝试尽可能排除干扰项，只保留包含黑色文字的拼图块，并重排列为2-4行。首先取色得到文字部分的RGB颜色值，然后写脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/puzzle.png')</div><div><br/></div><div>def check(x, y):</div><div>    count = 0</div><div>    for i in range(43):</div><div>        for j in range(43):</div><div>            p = img.getpixel((x + i, y + j))</div><div>            if p == (43, 42, 42) or p == (43, 43, 42):</div><div>                return True</div><div>    return False</div><div><br/></div><div>c, h = 0, 4</div><div>w = (219 + h) // h</div><div>new = Image.new('RGB', (w * 43, h * 43), (255, 255, 255))</div><div>for x in range(44):</div><div>    for y in range(25):</div><div>        if check(x * 43, y * 43):</div><div>            tmp = img.crop([x * 43, y * 43, x * 43 + 43, y * 43 + 43])</div><div>            new.paste(tmp, [c % w * 43, c // w * 43, c % w * 43 + 43, c // w * 43 + 43])</div><div>            c += 1</div><div>new.save('C:/Users/Administrator/Desktop/puzzle2.png')</div></div><div><img src="BMZCTF Misc 15（77-80）_files/puzzle2.png" type="image/png" data-filename="puzzle2.png"/></div><div>然后继续gaps：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop/gaps/bin# python gaps --image=puzzle2.png --generations=100 --population=220 --size=43 --save</div></div><div>由于块数大幅减少，迭代速度快了一些，效果也还可以：</div><div><img src="BMZCTF Misc 15（77-80）_files/puzzle2_solution.jpg" type="image/jpeg" data-filename="puzzle2_solution.jpg"/></div><div>每种行数都多试几次，将结果全部保存，例如行数为2可能得到这样的结果：</div><div><img src="BMZCTF Misc 15（77-80）_files/puzzle2_solution [1].jpg" type="image/jpeg" data-filename="puzzle2_solution.jpg"/></div><div>结合多种自动拼图结果，提取出大块的正确部分，再手动用Photoshop拼一下可以看出部分文字。类似这样：</div><div><img src="BMZCTF Misc 15（77-80）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>由于文字颜色并不为纯色，例如有部分拼图块内的文字颜色实际为(43, 43, 43)，因此这里未能得到完整结果，但半自动拼就完了解法基本上就是这样了。</div><div><br/></div><div>继续转换思路，既然已知flag的RGB颜色值是(43, 42, 42) (43, 43, 42) (43, 43, 43)，那么只要能找到原图，就可以比对每一个小拼图块来确定其在原图中的位置。每个拼图块与原图中的43 x 43小块对比，忽略所有拼图中所有上述颜色值点，其他点的重合率若在70%以上，基本可以认为找到了拼图块对应原图的位置。但原图我没有找到（可能是某张1920 x 1080的桌面壁纸，但搜到的图都是重新上传压缩过的，像素并不一致），只能等以后再试了。记录一下采用这一思路的Writeup：</div><div><a href="https://www.cnblogs.com/LEOGG321/p/14298331.html">https://www.cnblogs.com/LEOGG321/p/14298331.html</a></div><div><br/></div><div>flag：flag{you_can_never_finish_the}</div><div><br/></div><div><span style="font-weight: bold;">80 hide</span></div><div><br/></div><div>下载得到jpg格式文件。常见隐写方式没有结果，结合题目名猜测可能为Jphide或steghide，但尝试无密码解Jphide隐写失败，因此可能是需要爆破密码的steghide隐写。爆破脚本如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># -*- coding: utf8 -*-</div><div>#author:pcat</div><div>#http://pcat.cnblogs.com</div><div>from subprocess import *</div><div><br/></div><div>def foo():</div><div>    stegoFile = 'hide.jpg'</div><div>    extractFile = 'hide.txt'</div><div>    passFile = 'serbian-english-wordlist-final-dirsearch-format-with-ext.txt'</div><div><br/></div><div>    errors = ['could not extract', 'steghide --help', 'Syntax error']</div><div>    cmdFormat = 'steghide extract -sf &quot;%s&quot; -xf &quot;%s&quot; -p &quot;%s&quot;'</div><div>    f = open(passFile, 'r')</div><div><br/></div><div>    for line in f.readlines():</div><div>        cmd = cmdFormat %(stegoFile, extractFile, line.strip())</div><div>        p = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT)</div><div>        content = unicode(p.stdout.read(), 'gbk')</div><div>        for err in errors:</div><div>            if err in content:</div><div>                break</div><div>        else:</div><div>            print content,</div><div>            print 'the passphrase is %s' %(line.strip())</div><div>            f.close()</div><div>            return</div><div><br/></div><div>foo()</div></div><div>各种字典都试了一遍，最后能跑出来的字典是从<a href="https://github.com/cujanovic/dirsearch-wordlist">这个github库</a>下载到的，比较吊诡的一点是这明明是个dirsearch用的字典。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>root@kali:~/Desktop# python2 SHbrute2.py</div><div>wrote extracted data to &quot;hide.txt&quot;.</div><div>the passphrase is $uxcox</div><div>root@kali:~/Desktop# cat hide.txt</div><div>flag{St3gh1d3_1s_N1u_B1}</div></div><div><br/></div><div>flag：flag{St3gh1d3_1s_N1u_B1}</div></span>
</div></body></html> 