<html>
<head>
  <title>CTFshow Misc 10（37-40）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2662"/>
<h1>CTFshow Misc 10（37-40）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">37 交通繁忙</span></div><div><br/></div><div>下载得到gif格式文件，是一个红绿灯的动画。GIFFrame打开，共有1168帧：</div><div><img src="CTFshow Misc 10（37-40）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>观察规律，可以看出大致以18帧为1个单元，共65个单元（最后一个单元为16帧）。每个单元内有9次“灯亮-灯暗”的循环，且第1次亮灯必定为绿灯，2-8次为绿灯或红灯，第9次亮灯必定为黄灯。猜测黄灯为分隔符，前8次亮灯的红绿信息是8位二进制数据。若以第1位绿灯对应0，红灯对应1，那么8位二进制数据正好对应1个ASCII字符。</div><div>用GIFFrame导出所有帧后，Python脚本逐帧提取像素信息并转换为字符：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>path = 'C:/Users/Administrator/Desktop/traffic/'</div><div><br/></div><div>flag = ''</div><div>for i in range(65):</div><div>    s = ''</div><div>    for j in range(8):</div><div>        n = i * 18 + j * 2</div><div>        img = Image.open(path + str(n) + '.png')</div><div>        if img.getpixel((110, 140)) == (7, 253, 8, 255):</div><div>            s += '0'</div><div>        if img.getpixel((110, 50)) == (254, 0, 0, 255):</div><div>            s += '1'</div><div>    flag += chr(int(s, 2))</div><div><br/></div><div>print(flag)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{Pl34s3_p4y_4tt3nt10n_t0_tr4ff1c_s4f3ty_wh3n_y0u_4r3_0uts1d3}</div></div><div><br/></div><div>flag：flag{Pl34s3_p4y_4tt3nt10n_t0_tr4ff1c_s4f3ty_wh3n_y0u_4r3_0uts1d3}</div><div><br/></div><div><span style="font-weight: bold;">38 我需要GPS</span></div><div>hint:图片无隐写，flag内容是石碑内容中的8位数字</div><div><br/></div><div>下载得到png格式文件：</div><div><img src="CTFshow Misc 10（37-40）_files/sign.png" type="image/png" data-filename="sign.png"/></div><div>图片内容为路牌，可以看到列举了全世界多个大城市以及对应的距离，能够看清的是北京和新加坡两条。根据题目名称及提示，猜测需要找到路牌所在的地点，然后在附近寻找石碑。比较直观的思路是利用北京和新加坡两条距离，计算球面坐标找到对应地点。但这里也可以用社工思路解答：</div><div><br/></div><div>首先，此类路牌很显然并没有指路意义，一般是在某些景点或特殊地标位置，用于标识该地点与世界各大城市的方向和距离，以体现“国际感”。</div><div>其次，从背景旗杆以及前景路牌的保养状况来看，应当时常有人维护，旅游景点的可能性更大，从背景的植物也可以看出此处并非极点一类的地标位置。</div><div>最后，从图中可以大致看出其与伦敦的距离在10000km以上，与北京距离则短得多，为3600km左右，大致可以判断地点更接近亚洲，而距离新加坡仅1500km左右，说明地点更接近东南亚。</div><div><br/></div><div>结合以上判断，东南亚+旅游景点=有国内游客去过=互联网上有游记会提到=很可能有游记把路牌上的数据记录了下来，因此直接用Google搜索“北京 3654.86km”：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>不需要点击任何搜索结果，从搜索页面的摘要就可以得知，该路牌位于婆罗洲的最北端。同时从图片搜索结果中可以看到一个地标性质的球形石碑，很可能就是题目里提到的石碑。</div><div><br/></div><div>Google Map搜索婆罗洲，定位到最北端，可以看到确实有一处旅游景点：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>选中该地点，在左边可以看到“照片”栏中有“街景和360度全景照”：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>点击后发现了刚才看过的石碑：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>找到合适的全景照，旋转拉近到合适视角，可以清晰看到石碑上的文字：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>唯一可以被称为八位数字的就是最后一行的日期了，得到flag。</div><div><br/></div><div>顺便记录一下预期解，也就是用球面坐标计算位置的WP：<a href="https://wp.ctf.show/d/77-gps" style="font-size: unset; font-family: unset;">https://wp.ctf.show/d/77-gps</a></div><div><br/></div><div>flag：flag{20040710}</div><div><br/></div><div><span style="font-weight: bold;">39 和36D没关系</span></div><div><br/></div><div>下载得到png格式文件，十六进制编辑器查看，文件尾后有额外数据，是另一张PNG图片：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>分离两张图片，发现图像内容非常相似，但Stegsolve的Image Combiner功能中XOR模式下有大量噪点：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>尝试盲水印等双图隐写方法，但没有得到很明确的结果。考虑到图片大小是128x128，猜测可能隐藏了二进制信息，尝试直接比较两张图片的像素：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img1 = Image.open('C:/Users/Administrator/Desktop/00000000.png')</div><div>img2 = Image.open('C:/Users/Administrator/Desktop/00000078.png')</div><div><br/></div><div>r1 = r2 = ''</div><div>for i in range(128):</div><div>    for j in range(128):</div><div>        p1 = img1.getpixel((i, j))[0:3]</div><div>        p2 = img2.getpixel((i, j))[0:3]</div><div>        if p1 == p2:</div><div>            r1 += '0'</div><div>        else:</div><div>            r1 += '1'</div><div>        if len(r1) == 8:</div><div>            r2 += str(hex(int(r1, 2)))[2:].zfill(2)</div><div>            r1 = ''</div><div>print(r2)</div></div><div>尝试后发现，选择参数为列优先、相同像素为0的情况下，输出结果有明显的png格式文件头：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>89504e470d0a1a0a0000000d49484452000000e60000002a0806000000a7402774000000017352474200aece1ce90000000467414d410000b18f0bfc6105000000097048597300000ec400000ec401952b0e1b0000078c49444154785eed9a3f6b1b4b10c047ef53c8601782b46e0c0f2c431a4148f39a483810a97aa44f61dc597661cb9d31a448195259861839cd2b020135019d21e0e2b90da888c1fa16f7666777eff6f6f64e77d2c95e5ee6076b79757bfb677666677657b510018661bce20ff5c9308c47d45ebe678fc930bef0f59dfce45096613c84435986f110364c86f110364c86f110364c86f110364c86f110364c86f110364c86f110364c86f110364c86f110364c86f110364c86f110c3300338add5a026d2eb21fc7bd9a1cf997aba1a66307c5d83cee56a5b29c6638d5f8e59b4138f3bfe4ea653ec4d9a99e85354a606a737ea0161d761a485c651fddcc8febbc7f65404271d18deab4c116e4e23b916938d21c7fb2174e8dd0232103f62174c8e2184dd8bf041e51f86ed44feffcea38d3f188400edf0e297ca2376db94874138517901f5c77c8fea817010a83cbe7db18bef1d9b6f495cf53d05720c4fdf8f08c75ce433090728f3f6b08c56c87931dfa1f970cc930987b28fcc6c7a8b7fb7a0b12ef362153d3b4275ddeb425d7dd53c9cc000fa308e3c62001fbbd7300846d0d5ef6d1f004e30f4bfcdf73fcdc307b8d8edc3ce894fbeeaf7a5f1ac0d7037cd8d62d030a5abdd41e580ab1eaca1ab4d86481a47a8644f74e4aa653abd9479777d8274b8149c18f5639a172e5078b454c859e1f8ed32274399cf3388f52e8cc2100eb6555e703f0561be11376334d301b4cc3248f33084f0b0a97279d4a1bb876bfdd15989b02d3d376618476941b94f1321b92bac33b61559edd87da9254352a75ed03bb21c3d6ff6f1cb6be86d8871fe436da6f44dbff343e8f20ece03bed15dc3ef44bf1d3242488797d249324c9cb4cf21adbe184e013adca49210a2036bd0db9c88d057a65f17d03eda893b258c72a3075b41fcfcb6dbc36117470c68e74ef641d70128846cc3c6debf1941f839f636e5a968fca932e8a5ee7ad0bb528f4d761bd050ffba083ea1dcb02f6f553fc8cb8a77ec852f472e29d61bd0c6d99896d94f9908056dde02867df1f80017b2d25eb80fbd2f9d688e27c7e8c913c6298c120de03896f564532c984699545f443dc2c00aecdd14a437012e56281551cfe8cd5fd0421db8fe324e1854f00d4d71b703ad3fc5022a22197c63f8806d1e40912571518a85b2f763185de100fe36bab2de82ce2e0ee4e794b2a44c28cc48a9d1137c18a2cb2ecc0ca677f8b1d9888dcce54d9e8202e3879b8f68840398441e0c0dfe1c8d57e534d39fd94b953edc11dedb0c6de91de1cdf7003e2845144ad56f96304e34cc2df5ef22a44270b5a015f3d82628c7f374d87ea616b8d9e5194507b11cd365c8588ef7e3b01e69be102673bbf8c283501d57231847750430c6b968bf6ac53a59155753509ae3a498619281a8fd4db46aa37788bc811ac0b3a41fa83fefa414339b3ab45e6169f442be9ddccd1fbf5e592d4fa88c37267fa2691527c39ba096d821122aab1919e83de6f972215351e45c0aef56d253db08ef6318140e547a2a5ae06630fe828bd071cbf2466619cc19217cb4f5a1b07449b65b28e56b187d5712a52d441b3acfab35cbfa9b7d5a68e2338434050f7f642c4d02c0705578460a65124ab73c7178211580da5b3256af860ac64f067d060d0a9be64d7413de62b471ddfd182f508ef0970e11e6acbc11f6beb52cb438c9504e786a9285b5afab0c5a9c751b32d11980c6d85fee1cc95054eacdb228b9ab70360a63130b491534e100f5a771eed8d32a8a192685694a0062452f1dbe94003d81de3790b04508f7d4a789558c9f147b1fa61be53d0e19e0b2a0615ea359d90748e5100aa56440465a6e5fe7466d614c8cfd652291dc71913c17a1ac2e639c545700450614ceae308c45899d62c435ddcb5ea40b19a63c7cb0560eda77a9ffad504333fb3e2a75f893028df441ec53e71c2daf9af9e34709d0fec4f25e56192da7c4158771526842fb4ae525636591cf3466997cb432db21e232a0918a03b0b2fbba9487c73cca486e83ead0d8c48fd47ccb88457a17597ef0223912f26e36565b729f3c07da7e6038fb698c232b16c626f5deb1d058e87d74ee2289ab0e41979e5917ec5997d9f85d54e6d7458826149751791479ce05ae79f9eaba205fe4427731961e7faaff7119b3ff897a0955cefc2ed55e46ff5c7daaec0706b23edd77d95eb20ebb4ff3d07d36df49f74dceb9398e64dbd9f24ac8c396a14b1fa94c5a3f5dfd94a4f5d1ee7ffadda41c052e59da14334c9da781c9241a4a09351abc4838e040e48b1a669c37db71299a89ddcf45a964fc56ffdbc3897b5252fdb5c7ed9659b20f761987ec745a483ef6dcd8ed8b94af5c367aec13b31e67df947166b6e378ae742fbbbfba8c29374366a69e39ea92b81c852577ac2739c75972cc975d4dfcc10a5703dd37014c567ce7e32ff24e0e82f8ca475c89ac897bbca5ee5e999512dd9356bb7fd514d18182a7b2f350a7968913d455ec6bfc45de41dabf3e49ef25ea8dade227a9cc93e0ba27ad123a1b30efeb5d90dfac043bbc906efd774286b66672872bba5c3a547a0c72425e2395ea9bb1c7cb4ef9a19b0f44a1ef42a17f015cfbdc0c561bca320cb3101585b20cc354091b26c378081b26c378081b26c378081b26c378081b26c378081b26c378081b26c37848ede57bfe8101c3f8c2d777f2937ff9c3301ec2a12cc37807c07f7f965ea048e7124c0000000049454e44ae426082000000000000000000</div></div><div>在十六进制编辑器中将其保存为PNG格式图片：</div><div><img src="CTFshow Misc 10（37-40）_files/1.png" type="image/png" data-filename="1.png"/></div><div><br/></div><div>flag：flag{36D_is_beautyful}</div><div><br/></div><div><b>40 和36D有关系</b></div><div><br/></div><div>下载得到png格式文件。文件名为LSB.png，图片内容和上一题相似，但是倒了过来：</div><div><img src="CTFshow Misc 10（37-40）_files/LSB.png" type="image/png" data-filename="LSB.png"/></div><div>尝试了常见的LSB隐写方法均没有得到有效信息，尝试用上一题里得到的原图（原图实际为上一题附件中文件尾部的PNG图片）和本题的图片进行比较。首先把本题的图片旋转180度，在Stegsolve中用Image Combiner功能与原图对比，SUB模式下得到结果：</div><div><img src="CTFshow Misc 10（37-40）_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>可以看出存在差异的像素布满了整张图片，合理的判断是整张图片的颜色通道最低位都携带了信息。用Stegsolve导出（旋转180度以后的）本题附件三个颜色通道<span style="color: unset; font-family: unset; font-size: unset;">以及原图三个颜色通道，</span><span style="color: unset; font-family: unset; font-size: unset;">也可以看出三个通道除plane 0以外的其他plane均完全一致。但另一方面也注意到，似乎仅R通道的plane 0存在差异。用脚本对比两张图颜色通道的最低位，输出有差异的像素点：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>i1 = Image.open('C:/Users/Administrator/Desktop/a_fox.png')</div><div>i2 = Image.open('C:/Users/Administrator/Desktop/LSB2.png')</div><div><br/></div><div>for i in range(128):</div><div>    for j in range(128):</div><div>        p1, p2 = i1.getpixel((i, j)), i2.getpixel((i, j))</div><div>        l1 = [p1[0] % 2, p1[1] % 2, p1[2] % 2]</div><div>        l2 = [p2[0] % 2, p2[1] % 2, p2[2] % 2]</div><div>        if l1 != l2:</div><div>            print(f'({i}, {j}): {l1}, {l2}')</div></div><div>部分输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(0, 0): [0, 1, 1], [1, 1, 1]</div><div>(0, 2): [1, 0, 0], [0, 0, 0]</div><div>(0, 4): [0, 1, 1], [1, 1, 1]</div><div>(0, 5): [1, 0, 0], [0, 0, 0]</div><div>(0, 8): [1, 0, 0], [0, 0, 0]</div><div>(0, 9): [0, 1, 1], [1, 1, 1]</div><div>(0, 10): [1, 0, 0], [0, 0, 0]</div><div>(0, 13): [1, 0, 0], [0, 0, 0]</div><div>(0, 14): [1, 0, 0], [0, 0, 0]</div><div>(0, 15): [1, 0, 0], [0, 0, 0]</div><div>(0, 18): [1, 0, 0], [0, 0, 0]</div><div>(0, 20): [0, 1, 1], [1, 1, 1]</div><div>(0, 22): [0, 0, 0], [1, 0, 0]</div><div>(0, 23): [0, 1, 0], [1, 1, 0]</div><div>(0, 24): [0, 1, 0], [1, 1, 0]</div><div>(0, 25): [1, 0, 1], [0, 0, 1]</div><div>(0, 29): [1, 0, 1], [0, 0, 1]</div></div><div>很明显，每个存在差异的像素点，其差异仅在于R通道的最低位。这样一来，每个像素点只能携带1bit的信息（G和B通道最低位没有改变，不携带任何信息），<span style="color: unset; font-family: unset; font-size: unset;">存在两种可能性：</span></div><div>1、R通道最低位就是隐写信息本身；但zsteg的-a模式会尝试这种可能性，没有得到结果。</div><div>2、R、G、B通道最低位经过运算后得到该像素点携带的信息，且该信息的0-1值可以通过反转其中一个算符来反转，符合这一条件的运算中最常见的就是异或。</div><div><br/></div><div>由于隐写信息的读取顺序暂时未知，有行优先和列优先两种可能性。用脚本计算每个像素点三个颜色通道最低位异或运算结果，然后分别输出首行和首列：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>img = Image.open('C:/Users/Administrator/Desktop/LSB2.png')</div><div><br/></div><div>row = col = ''</div><div>for i in range(128):</div><div>    p = img.getpixel((i, 0))</div><div>    r, g, b = p[0] % 2, p[1] % 2, p[2] % 2</div><div>    res = r ^ g ^ b</div><div>    row += str(res)</div><div>    p = img.getpixel((0, i))</div><div>    r, g, b = p[0] % 2, p[1] % 2, p[2] % 2</div><div>    res = r ^ g ^ b</div><div>    col += str(res)</div><div>print(row)</div><div>print(hex(int(row, 2)))</div><div>print(col)</div><div>print(hex(int(col, 2)))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>10000011011000111111010000010101111101011101110101110000110010010001011001000110000001110110001111000011001101100010111000100000</div><div>0x8363f415f5dd70c916460763c3362e20</div><div>10001001010100000100111001000111000011010000101000011010000010100000000000000000000000000000110101001001010010000100010001010010</div><div>0x89504e470d0a1a0a0000000d49484452</div></div><div>列优先的结果中发现了PNG格式图片的文件头89 50 4E 47，说明列优先是正确顺序。</div><div><br/></div><div>最终的隐写信息读取脚本，注意被读取的图片是附件旋转180度后的：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>img = Image.open('C:/Users/Administrator/Desktop/LSB2.png')</div><div>out = open('C:/Users/Administrator/Desktop/out.png', 'ab')</div><div><br/></div><div>res = ''</div><div>for i in range(128):</div><div>    for j in range(128):</div><div>        p = img.getpixel((i, j))</div><div>        r, g, b = p[0] % 2, p[1] % 2, p[2] % 2</div><div>        xor = r ^ g ^ b</div><div>        res += str(xor)</div><div>        if len(res) == 8:</div><div>            out.write(int(res, 2).to_bytes(1, byteorder = 'big'))</div><div>            res = ''</div></div><div>输出结果：</div><div><img src="CTFshow Misc 10（37-40）_files/out.png" type="image/png" data-filename="out.png"/></div><div><br/></div><div>flag：flag{36d@ctf_show}</div></span>
</div></body></html> 