<html>
<head>
  <title>CTFshow Misc 15（57-60）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3084"/>
<h1>CTFshow Misc 15（57-60）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div>
<span><div><span style="font-weight: bold;">57 知否</span></div><div><br/></div><div>下载得到png格式图片。Stegsolve查看，在Red/Green plane 0处发现线索：</div><div><img src="CTFshow Misc 15（57-60）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="CTFshow Misc 15（57-60）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>另一方面，注意到Red/Green Plane 0的右半部分和Blue Plane 0都是全黑的，这显然是经过处理的痕迹。换言之，隐写信息很可能就在R/G通道的最低位处。更确切地说，是在最左边80列像素的R/G通道最低位处，且读取时像素顺序可能为列优先。</div><div><br/></div><div>信息的隐藏方式有多种可能，分别用脚本输出开头部分：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>img = Image.open('C:/Users/Administrator/Desktop/flag_out.png')</div><div><br/></div><div># 先读全部像素R通道最低位，再读G通道最低位</div><div>res = ''</div><div>for i in range(200):</div><div>    p = img.getpixel((0, i))</div><div>    res += str(p[0] % 2)</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># 76 2d 21 b8 f2 f1 60 d0 7e 12 93 12 b2 33 bb 09 e0 43 9e 89 17 91 e9 eb 72</div><div><br/></div><div># 先读某个像素R通道最低位，再读G通道最低位，再读下个像素</div><div>res = ''</div><div>for i in range(100):</div><div>    p = img.getpixel((0, i))</div><div>    res += str(p[0] % 2)</div><div>    res += str(p[1] % 2)</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># 6e 79 19 b3 1c 56 9b d5 be 59 ee 47 3d 44 a2 44 2e ac 03 0c 82 0a 03 5d 9f</div><div><br/></div><div># 读取某个像素R通道最低位和G通道最低位的异或结果</div><div>res = ''</div><div>for i in range(200):</div><div>    p = img.getpixel((0, i))</div><div>    res += str((p[0] % 2) ^ (p[1] % 2))</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># db 78 4f e7 9f 5a 1a da 5c 00 93 0d c9 5b 67 53 40 42 19 56 12 10 88 7f 1a</div><div><br/></div><div># 对每个像素判断R通道最低位是否小于G通道最低位（绿肥红瘦）</div><div>res = ''</div><div>for i in range(200):</div><div>    p = img.getpixel((0, i))</div><div>    if p[0] % 2 &lt; p[1] % 2:</div><div>        res += '1'</div><div>    else:</div><div>        res += '0'</div><div>    if len(res) == 8:</div><div>        print(str(hex(int(res, 2)))[2:].zfill(2), end = ' ')</div><div>        res = ''</div><div># 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 00 00 01 56 00 00 00 14 08</div></div><div>最后一种方式输出了明显的PNG格式图片文件头，按这种方式读取全部80列像素并保存为PNG格式图片：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/flag_out.png')</div><div>png = open('C:/Users/Administrator/Desktop/flag.png', 'ab')</div><div>tmp = ''</div><div><br/></div><div>for i in range(80):</div><div>    for j in range(img.size[1]):</div><div>        p = img.getpixel((i, j))</div><div>        if p[0] % 2 &lt; p[1] % 2:</div><div>            tmp += '1'</div><div>        else:</div><div>            tmp += '0'</div><div>        if len(tmp) == 8:</div><div>            png.write(int(tmp, 2).to_bytes(1, 'big'))</div><div>            tmp = ''</div></div><div>运行得到图片：</div><div><img src="CTFshow Misc 15（57-60）_files/flag.png" type="image/png" data-filename="flag.png"/></div><div><br/></div><div>flag：flag{aff3a6fb7c7f6c6ae306e8ebde002ffc}</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">58 小球</span></div><div><br/></div><div>下载得到gif格式文件。查看图像信息，共有305帧，每帧的背景图都一致，除第0帧外，第1-304帧都是背景图上覆盖了一个大小、位置随机的圆，颜色有绿色和蓝色两种。第0帧：</div><div><img src="CTFshow Misc 15（57-60）_files/0.png" type="image/png" data-filename="0.png"/></div><div>第7帧：</div><div><img src="CTFshow Misc 15（57-60）_files/7.png" type="image/png" data-filename="7.png"/></div><div>第22帧：</div><div><span style="font-weight: bold;"><img src="CTFshow Misc 15（57-60）_files/22.png" type="image/png" data-filename="22.png"/></span></div><div><br/></div><div>显然这个圆就是携带信息的载体，其圆心坐标、半径和颜色都有可能携带了信息。但考虑到在像素图中半径是离散的整数值且取值范围不大，圆心坐标计算方式比较复杂，先从比较容易获取的颜色入手。记录除第1-16帧的小圆颜色：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>蓝绿绿蓝蓝绿绿蓝蓝绿绿蓝绿绿蓝蓝</div></div><div>容易联想到 fl 的二进制ASCII码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01100110 01101100</div></div><div>显然蓝色对应0，绿色对应1，除第0帧外的304帧正好对应38个字符。</div><div><br/></div><div>现在需要提取每一帧中小圆的颜色。容易想到的一种方法是循环读取每一帧的每个像素，一旦有像素的RGB值为纯蓝或纯绿就跳出循环，并记录该帧对应的颜色值。但这种方法在背景图中也包含纯蓝或纯绿像素时就会失效，因此尝试采用另一种更有通用性的方式，将每一帧与第0帧进行比较。如果某一帧的像素整体上“更蓝”，就可以判定该帧的小圆是蓝色。预先将每一帧导出为PNG格式图片后运行以下Python脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>def sum_B(img):</div><div>    B = 0</div><div>    for i in range(img.size[0]):</div><div>        for j in range(img.size[1]):</div><div>            B += img.getpixel((i, j))[2]</div><div>    return(B)</div><div><br/></div><div>img0 = Image.open('C:/Users/Administrator/Desktop/qiu/0.png')</div><div>B0 = sum_B(img0)</div><div><br/></div><div>res = ''</div><div>for i in range(1, 305):</div><div>    path = 'C:/Users/Administrator/Desktop/qiu/' + str(i) + '.png'</div><div>    B = sum_B(Image.open(path))</div><div>    if B &gt; B0:</div><div>        res += '0'</div><div>    else:</div><div>        res += '1'</div><div>    if len(res) == 8:</div><div>        print(chr(int(res, 2)), end = '')</div><div>        res = ''</div></div><div>该方法笨重、缓慢但是有效，而且flag一个字符一个字符蹦出来很有盲注的感觉。输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{82f6d14327ad10e0f9105b409122d5e1}</div></div><div><br/></div><div>flag：flag{82f6d14327ad10e0f9105b409122d5e1}</div><div><br/></div><div><span style="font-weight: bold;">59 LSB</span></div><div><br/></div><div><span style="font-size: unset;">做不来，告辞！</span></div><div>以下是参考出题人解答的解题脚本：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import wave</div><div>import numpy as np</div><div><br/></div><div>f = wave.open('C:/Users/Administrator/Desktop/example.wav', 'rb')</div><div>params = f.getparams()</div><div>nchaanels, sampwith, frameate, nframes = params[:4]</div><div>strData = f.readframes(nframes)</div><div>data = np.frombuffer(strData, dtype = np.int16).tolist()</div><div><br/></div><div>data = data[::-1]</div><div>tmp = ''</div><div>res = []</div><div>for i in data:</div><div>    if i % 2 == 1:</div><div>        tmp += '1'</div><div>    else:</div><div>        tmp += '0'</div><div>    if len(tmp) == 8:</div><div>        res += [int(tmp, 2)]</div><div>        tmp = ''</div><div><br/></div><div>png = open('C:/Users/Administrator/Desktop/1.png', 'wb')</div><div>png.write(bytes(res[::-1]))</div></div><div><br/></div><div>flag：flag{0eaf0a5e30b495f5490ec8baad0e9a53}</div><div><br/></div><div><span style="font-weight: bold;">60 红包题之圣诞快乐</span></div><div>题目：从附件中分析前车的目的地即可</div><div><br/></div><div>下载得到jpg格式文件：</div><div><img src="CTFshow Misc 15（57-60）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>通过以图搜图找到这篇文章：<a href="https://my.oschina.net/u/4581745/blog/4910660">https://my.oschina.net/u/4581745/blog/4910660</a>，得到答案：</div><div><img src="CTFshow Misc 15（57-60）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>flag：flag{antvorskov}</div></span>
</div></body></html> 