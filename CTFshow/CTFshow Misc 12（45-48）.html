<html>
<head>
  <title>CTFshow Misc 12（45-48）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605894 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2784"/>
<h1>CTFshow Misc 12（45-48）</h1>
<h2><a href="https://DemonStarAlgol.github.io/Misc/">[无关链接]</a></h2>

<div><span><div><span style="font-weight: bold;">45 koishi</span></div><div>题目描述：<a href="https://t.bilibili.com/315611166327031435">https://t.bilibili.com/315611166327031435</a></div><div><br/></div><div>给出了一条Bilibili动态的地址，访问后可以得到一张全部为透明的PNG图片。Stegsolve查看发现颜色通道有数据：</div><div><img src="CTFshow Misc 12（45-48）_files/Image.png" type="image/png" data-filename="Image.png" width="661"/><br/></div><div><img src="CTFshow Misc 12（45-48）_files/Image [1].png" type="image/png" data-filename="Image.png" width="661"/><br/></div><div>R/G/B通道的数据是一致的，plane 0处的数据提示了两方面的信息：</div><div>1、古明地恋的剪影当中填充了两种像素，很可能携带了某种二进制信息；</div><div>2、剪影最下方没有填充满，说明携带的信息长度有限，且填充像素时是按行优先的。</div><div><br/></div><div>用脚本提取图像中的部分像素：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/398cf145c92f920e637680e93707ee62cc6312f0.png')</div><div>for x in range(440, 450):</div><div>    print(img.getpixel((x, 43)))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(128, 128, 128, 0)</div><div>(128, 128, 128, 0)</div><div>(1, 1, 1, 0)</div><div>(0, 0, 0, 0)</div><div>(0, 0, 0, 0)</div><div>(0, 0, 0, 0)</div><div>(1, 1, 1, 0)</div><div>(128, 128, 128, 0)</div><div>(128, 128, 128, 0)</div><div>(128, 128, 128, 0)</div></div><div>其中Alpha通道均为0， (128, 128, 128, 0) 是背景（古明地恋剪影以外的部分）， (1, 1, 1, 0) 和 (0, 0, 0, 0) 显然就是携带二进制信息的两种像素。写Python脚本提取信息，按行优先，两种像素分别对应到1和0，再每八位转十六进制：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div><br/></div><div>img = Image.open('C:/Users/Administrator/Desktop/398cf145c92f920e637680e93707ee62cc6312f0.png')</div><div>res = tmp = ''</div><div><br/></div><div>for y in range(img.size[1]):</div><div>    for x in range(img.size[0]):</div><div>        p = img.getpixel((x, y))</div><div>        if p == (1, 1, 1, 0):</div><div>            tmp += '1'</div><div>        if p == (0, 0, 0, 0):</div><div>            tmp += '0'</div><div>        if len(tmp) == 8:</div><div>            res += str(hex(int(tmp, 2)))[2:].zfill(2)</div><div>            tmp = ''</div><div>print(res)</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>89504e470d0a1a0a0000000d4948445200000280000002d008060000000043c1d4000000097048597300000b</div><div>……（后略）</div></div><div>显然是个PNG格式图片的十六进制数据，将其在十六进制编辑器内保存为png格式文件（末尾会有大量的额外00字节，这是因为古明地恋剪影没有填充满，最下方的空像素也被读取的原因，但对保存后的文件无影响）：</div><div><img src="CTFshow Misc 12（45-48）_files/1.png" type="image/png" data-filename="1.png" width="640"/><br/></div><div><br/></div><div>flag：flag{Komeiji_Koishi_unC0n5cioUs}</div><div><br/></div><div><span style="font-weight: bold;">46 一个头两个大</span></div><div>题目描述：小明经常访问国外某hub网站，附件是他自制的色图。<span style="font-size: unset; color: unset; font-family: unset;">hint: 一个头像两个字符</span></div><div><br/></div><div>下载得到gif格式文件，GIFFrame打开：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [2].png" type="image/png" data-filename="Image.png" width="639"/><br/></div><div>共有10帧，每帧是240x240大的图片，背景为灰色(240, 240, 240)填充，内容为5行5列、呈左右对称的彩色像素。这是<a href="https://github.com/">Github</a>默认Identicons头像的特征。根据<a href="https://github.blog/2013-08-14-identicons/">Github官方说法</a>，这些头像是基于用户ID的hash值生成的，hash值各位的奇偶性决定了对应位置的像素是否存在。<span style="font-size: unset; color: unset; font-family: unset;">根据提示，九张头像各对应两位字符，很可能拼接起来就是flag。</span></div><div><br/></div><div><span style="font-weight: bold;">*注意*以下内容为错误思路，仅作记录。</span></div><div>容易想到采取爆破的方式，将所有双字符ID对应的Github头像下载到本地，再进行对比。尤其是Github官方提供了一个简单的途径，可以查看特定用户名对应的Identicons头像：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>https://identicons.github.com/[此处填入用户名].png</div></div><div>例如以下是<a href="https://github.com/identicons/davidcheyenneone.png">我的Identicons头像</a>：</div><div><img src="CTFshow Misc 12（45-48）_files/identicon.png" type="image/png" data-filename="identicon.png" width="420"/><br/></div><div><br/></div><div>写脚本下载所有合法的2字符用户名对应的头像，注意github用户名允许的字符仅有字母、数字和连接符-，且不区分大小写字符。所有-开头的用户名，以及1-、2-、fr、m-、q-等用户名不合法或不存在：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import string</div><div>import time</div><div>from urllib.request import urlretrieve</div><div><br/></div><div>dic = string.digits + string.ascii_lowercase + '-'</div><div>url = 'https://github.com/identicons/'</div><div>path = 'C:/Users/Administrator/Desktop/identicons/'</div><div><br/></div><div>err = []</div><div>for i in dic:</div><div>    for j in dic:</div><div>        time.sleep(0.5)</div><div>        fn = i + j + '.png'</div><div>        try:</div><div>            urlretrieve(url + fn, path + fn)</div><div>            print(fn)</div><div>        except:</div><div>            print(fn + ' ERROR')</div><div>            err += [fn] # 记录没有成功下载的图片</div><div>print(err)</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>err = [''] # 重新下载没有成功下载的图片</div><div>for fn in err:</div><div>    time.sleep(0.5)</div><div>    try:</div><div>        urlretrieve(url + fn, path + fn)</div><div>        print(fn)</div><div>    except:</div><div>        print(fn + ' ERROR')</div></div><div>最终可以得到1327张图片：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [3].png" type="image/png" data-filename="Image.png" width="1304"/><br/></div><div>但简单比较就可以发现，即使仅比较形状，题目附件中的10个头像也不存在于这其中。说明这一思路是错误的。</div><div><span style="font-weight: bold;">*注意*以上内容为错误思路，仅作记录。</span></div><div><br/></div><div>重点在于Github官方的这句描述：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Our Identicons are simple 5×5 “pixel” sprites that are generated using a hash of the user’s <b><font color="#FF0000">ID</font></b>.</div></div><div>这里的ID指的并不是用户名，而是每个Github用户唯一对应且不会改变的识别码（很可能是串数字）。因此问题的核心在于找到Github头像，或者说本题附件中头像的具体生成算法。进一步搜索可以找到Github上的<a href="https://github.com/stewartlord/identicon.js">identicon.js</a>项目。据描述，只要提供同样的hash值，该工具可以生成在形状上与Github头像完全一致的图案。</div><div><br/></div><div>查看<a href="https://github.com/stewartlord/identicon.js/blob/master/identicon.js">具体代码</a>，注意到以下段落：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if (typeof(hash) !== 'string' || hash.length &lt; 15) {</div><div>throw 'A hash of at least 15 characters is required.';</div></div><div>hash值至少需要15位。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// the first 15 characters of the hash control the pixels (even/odd)</div><div>// they are drawn down the middle first, then mirrored outwards</div></div><div>取hash值的前15位，分别判断奇偶性。然后从中间（第三列）开始纵向作图，接着镜像向外（即先第二/四列，最后一/五列）。</div><div><br/></div><div>这样一来，问题的关键转化为两个：</div><div>1、本题使用的是双字符串的哪一种hash值；</div><div>2、hash值每一位的奇偶性和头像中像素的有无如何对应（这一条理论上可以从上述js代码中找到，但我看不懂js代码）。</div><div>假定第一帧头像对应的字符为“fl”，尝试将它的各种hash值与头像的像素分布进行对比：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>头像（三、四、五列，从左到右，从上到下）：</div><div>无无有无有无有有无有有无有无无</div><div><br/></div><div>32位MD5：3d296788f2a7e19ffbd912521d94a5f4</div><div>奇奇偶奇偶奇偶偶奇偶偶奇偶奇奇</div><div><br/></div><div>16位MD5：f2a7e19ffbd91252</div><div>奇偶偶奇偶奇奇奇奇奇奇奇奇偶奇</div><div><br/></div><div>SHA1：d0cf1ef21f0ce65584e2453a3fb427f6591adca8</div><div>奇偶偶奇奇偶奇偶奇奇偶偶偶偶奇</div><div><br/></div><div>SHA256：593f2d04aab251f60c9e4b8bbc1e05a34e920980ec08351a18459b2bc7dbf2f6</div><div>奇奇奇奇偶奇偶偶偶偶奇偶奇奇奇</div></div><div>得出结论：使用的hash算法是MD5，奇数对应无像素（背景色），偶数对应有像素。</div><div><br/></div><div>接下来用脚本遍历所有10帧头像，通过颜色判断对应位置像素是否存在并记录，然后爆破所有2位字符串，将其MD5值前15位的奇偶性与像素分布情况对比，若一致则输出。Python脚本如下（首先将gif图像的10帧均导出为png格式）：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from PIL import Image</div><div>import hashlib</div><div>import string</div><div><br/></div><div>head = [''] * 10</div><div>for t in range(10):</div><div>    tmp = ''</div><div>    img = Image.open('C:/Users/Administrator/Desktop/head/' + str(t) + '.png')</div><div>    for i in range(3):</div><div>        for j in range(5):</div><div>            x, y = 210 + i * 71, 70 + j * 71</div><div>            p = img.getpixel((x, y))</div><div>            if p[:3] == (240, 240, 240):</div><div>                tmp += '1'</div><div>            else:</div><div>                tmp += '0'</div><div>    head[t] = tmp</div><div><br/></div><div>def check(s):</div><div>    md5 = hashlib.md5(s.encode('ascii')).hexdigest()[:15]</div><div>    tmp = ''</div><div>    for i in range(15):</div><div>        tmp += str(int(md5[i], 16) % 2)</div><div>    for i in range(10):</div><div>        if tmp == head[i]:</div><div>            return i + 1</div><div><br/></div><div>dic = string.printable[:-6]</div><div>flag = [''] * 10</div><div>for i in dic:</div><div>    for j in dic:</div><div>        s = i + j</div><div>        if check(s):</div><div>            flag[check(s) - 1] = s</div><div>print(''.join(flag))</div></div><div>输出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{ZhEnDeShAnGtOu}</div></div><div><br/></div><div>flag：flag{ZhEnDeShAnGtOu}</div><div><br/></div><div><span style="font-weight: bold;">47 滑天下之大稽</span></div><div><br/></div><div>下载得到rar格式文件，内含想不到吧.jpg和加密的flag.txt：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [4].png" type="image/png" data-filename="Image.png" width="1064"/><br/></div><div><br/></div><div>先看前者，十六进制编辑器打开，文件尾后有大量1和0组成的额外数据：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [5].png" type="image/png" data-filename="Image.png" width="815"/><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>100000001010000001100000001010101100101011101111101000100010110010001110111011101010110010001100011001100100011010100110100001100110011000100000110110100100101100110001100110100010110100011001000100100100000001100001010000001000111100001110100011111100010010101100100011011110110001101100101011001000110101000000000000000000000000010000011001011101011100100010111101000000010000000001010100001000000000000001010100010110000001100000010000001100010001101010001111010001111101000000000000000001000000010000001000000010000010100000000000001100000010100000001000010100000010111100101101100101001001100110000000000010000011100001010000100010010001001110001011000100101</div></div><div>共663位，不是任何常见的已知编码形式，也无法按字节对应转换成常见文件格式。根据题目名称的提示，直接用这段663位的字符串作为密码解压flag.txt，结果解压成功了……从而得到flag。</div><div><br/></div><div>flag：flag{d24c6928b1b76d75ed1b4399e9a163e9}</div><div><br/></div><div><span style="font-weight: bold;">48 ⎛⎝你喜欢龙猫吗⎠⎞</span></div><div><br/></div><div>下载得到Totoro.jpg和加密压缩包Key.zip。先看前者，直接打开提示数据损坏，十六进制编辑器打开：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [6].png" type="image/png" data-filename="Image.png" width="819"/><br/></div><div>与JPG格式文件头FF D8 FF E0 00 10 4A 46 49 46 00 01对比，很显然每个字节都减少了1（00减少1后变为FF）。用Python脚本将其修复：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f = open('C:/Users/Administrator/Desktop/Totoro.jpg', 'rb').read()</div><div>new = open('C:/Users/Administrator/Desktop/new.jpg', 'ab')</div><div><br/></div><div>for i in range(len(f)):</div><div>    n = (f[i] + 1) % 0x100</div><div>    new.write(n.to_bytes(1, 'big'))</div></div><div>得到修复完成的图片new.jpg：</div><div><img src="CTFshow Misc 12（45-48）_files/new.jpg" type="image/jpeg" data-filename="new.jpg" width="300"/><br/></div><div><br/></div><div>十六进制编辑器查看new.jpg，在文件尾后发现额外数据：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [7].png" type="image/png" data-filename="Image.png" width="819"/><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>3434364635463538333037323231</div></div><div>十六进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>446F5F58307221</div></div><div>再进行一次十六进制ASCII转码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Do_X0r!</div></div><div>这就是Key.zip的解压密码。</div><div><br/></div><div>解压得到无扩展名文件Key。首先注意到该文件的大小为76028字节，正好是new.jpg（以及Totoro.jpg）大小38014字节的两倍。十六进制编辑器打开：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [8].png" type="image/png" data-filename="Image.png" width="816"/><br/></div><div>发现该文件实际是个文本，且内容为大量十六进制数字。在十六进制编辑器中，将每两位数字转为一个字节保存为新文件Key1，从而Key1的大小正好和new.jpg（以及Totoro.jpg）完全一致：</div><div><img src="CTFshow Misc 12（45-48）_files/Image [9].png" type="image/png" data-filename="Image.png" width="815"/><br/></div><div>与new.jpg的文件头部对比，发现两者存在相似之处，例如new.jpg中的FF在Key1中对应D4，01对应2A。结合密码Do_X0r!，猜测Key1是new.jpg经过一次异或后的结果。将两个文件再次异或后寻找规律：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f1 = open('C:/Users/Administrator/Desktop/new.jpg', 'rb').read()</div><div>f2 = open('C:/Users/Administrator/Desktop/Key1', 'rb').read()</div><div><br/></div><div>for i in range(100):</div><div>    print(str(hex(f1[i] ^ f2[i]))[2:].zfill(2), end = ' ')</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b</div></div><div>因此Key1中的大部分字节是new.jpg中对应字节异或0x2b的结果，寻找不符合这一规律的特殊字节：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f1 = open('C:/Users/Administrator/Desktop/new.jpg', 'rb').read()</div><div>f2 = open('C:/Users/Administrator/Desktop/Key1', 'rb').read()</div><div><br/></div><div>for i in range(38014):</div><div>    if f1[i] ^ f2[i] != 0x2b:</div><div>        print(i, end = ' ')</div><div>        print(str(hex(f1[i] ^ f2[i]))[2:].zfill(2), end = ' ')</div><div>        print(chr(f1[i] ^ f2[i]))</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>37463 3f ?</div><div>37472 5b [</div><div>37473 3e &gt;</div><div>37474 3e &gt;</div><div>37477 3e &gt;</div><div>37482 3e &gt;</div><div>37489 3e &gt;</div><div>37498 3e &gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">……（中略）</span></div><div>37895 2d -</div><div>37896 2e .</div><div>37897 3e &gt;</div><div>37898 3e &gt;</div><div>37899 3e &gt;</div><div>37900 3e &gt;</div><div>37912 2e .</div><div>37913 3f ?</div></div><div>的确有部分字节异或结果不是0x2b，且这些字节的位置看起来是大致连续的。另一方面，异或结果对应的ASCII字符除开头和结尾的两个?外，仅包括[]&lt;&gt;-.和空格。注意到0x2b对应的ASCII字符是+，这很可能是一段Brainfuck代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>f1 = open('C:/Users/Administrator/Desktop/new.jpg', 'rb').read()</div><div>f2 = open('C:/Users/Administrator/Desktop/Key1', 'rb').read()</div><div><br/></div><div>for i in range(37464, 37913):</div><div>    print(chr(f1[i] ^ f2[i]), end = '')</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>++++++++[&gt;&gt;++&gt;++++&gt;++++++&gt;++++++++&gt;++++++++++&gt;++++++++++++&gt;++++++++++++++&gt;++++++++++++++++&gt;++++++++++++++++++&gt;++++++++++++++++++++&gt;++++++++++++++++++++++&gt;++++++++++++++++++++++++&gt;++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;++++++.&gt;----.&lt;-----.&gt;-----.&gt;-----.&lt;&lt;&lt;&lt;++++.&lt;.&gt;&gt;&gt;--.&lt;+++++.&gt;.&lt;&lt;++++++++.&gt;&gt;&gt;++++++++.&gt;-----.&lt;&lt;&lt;&lt;&lt;+++.&gt;&gt;&gt;.&lt;-.&lt;------------.&gt;&gt;&gt;&gt;--.&lt;.&gt;--.&lt;&lt;&lt;---.&lt;-.&gt;&gt;&gt;&gt;+++++++++++.</div></div><div>用在线工具将Brainfuck代码转为字符串，得到：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>flag{D0_U_Lov3_T@torQ?}</div></div><div><br/></div><div>flag：flag{D0_U_Lov3_T@torQ?}</div></span>
</div></body></html> 